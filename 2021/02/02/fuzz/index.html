<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;dark&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/17.jpeg"><link rel="icon" href="/img/17.jpeg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="fuzz的记录贴"><meta name="author" content="wizard"><meta name="keywords" content="fuzz"><title>fuzz记录 - zhd&#39;s blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:30,cursorChar:"/",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>zhd's blog</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://tva1.sinaimg.cn/large/0082zybply1gbss5d0prgj31900u0npq.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="fuzz记录"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-02-02 09:22" pubdate>2021年2月2日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 45 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">fuzz记录</h1><div class="markdown-body"><h2 id="What’s-this"><a href="#What’s-this" class="headerlink" title="What’s this?"></a>What’s this?</h2><p>虽然在大三的时候接触过fuzz，但是从来没有系统地学习、整理过fuzz的相关知识。这篇文章算是记录一下自己学习fuzz的历程吧。</p><p>主要分为以下几个模块：</p><ul><li>fuzz介绍<ul><li>fuzz是什么</li><li>fuzz的一些术语</li><li>分类</li><li>fuzz的流程</li><li>分类详细介绍</li></ul></li><li>流行的fuzzer<ul><li>AFL</li></ul></li><li>前沿研究动态</li><li>一个fuzzer的实现</li></ul><h2 id="fuzz介绍"><a href="#fuzz介绍" class="headerlink" title="fuzz介绍"></a>fuzz介绍</h2><blockquote><p>有两篇不错的fuzz综述：《Fuzzing: a survey》和《Fuzzing: Art, Science, and Engineering》</p></blockquote><h3 id="fuzz是什么"><a href="#fuzz是什么" class="headerlink" title="fuzz是什么"></a>fuzz是什么</h3><p>Fuzz的中文名称为模糊测试，是一种基于黑盒或灰盒的模糊测试技术，通过自动化生成大量的随机测试用例来发现产品或协议的未知漏洞。相比于其他漏洞检测方法，fuzz的准确率更高，且具有更好的扩展性，见<code>《Fuzzing a survey》</code>中的table1:</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/76.png" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="fuzz的一些术语"><a href="#fuzz的一些术语" class="headerlink" title="fuzz的一些术语"></a>fuzz的一些术语</h3><p><code>Fuzzing: Art, Science, and Engineering》</code>中整理出的的一些术语：</p><ul><li>PUT：测试的程序</li><li>Fuzzing test：测试PUT是否违反了安全策略</li><li>Fuzz Campaign: 在特定安全策略下的一轮fuzz，目的是发现违反安全策略的bug</li><li>Bug Oracle：检测程序执行是否违反安全策略的一种机制</li><li>Fuzz Configuration：Fuzz算法的参数值</li><li>Fuzz algorithm：模糊算法，依赖于输入外的一些参数且有通用模型</li><li>seed：输入，对于不同的测试对象，输入的种类不同。可能是文件、流量包或一系列UI事件或修改生成的测试用例</li><li>seed pool：fuzzer维护的种子集合，不断扩展</li></ul><h3 id="fuzz分类"><a href="#fuzz分类" class="headerlink" title="fuzz分类"></a>fuzz分类</h3><p>fuzzer可以根据生成器策略分为基于生成规则的fuzzer和基于变异的fuzzer。基于生成规则的fuzzer需要目标对象输入的相关知识内容，而基于变异的fuzzer需要一个初始的输入数据集合。二者的对比如<code>《Fuzzing a survey》</code>中的table2所示：</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/77.png" srcset="/img/loading.gif" lazyload alt=""></p><p>如果从探索策略的角度来看，fuzzer可以分为定向fuzzing和覆盖导向fuzzing。定向fuzzing的目的是生成覆盖目标代码和目标路径的测试用例，而基于覆盖的fuzzing尽可能生成覆盖更多程序代码的测试用例。</p><p>fuzzer还可以分为智能fuzzer和非智能fuzzer。智能fuzzer有类似于神经网络反向传播的机制，基于比那一段fuzzer会结合反馈信息来决定哪部分测试用例需要变异以及如何变异。</p><p><code>Fuzzing: Art, Science, and Engineering》</code>中的Fig 1从fuzz目标对象的角度整理了01年到18年的流行fuzzer：</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/79.png" srcset="/img/loading.gif" lazyload alt=""></p><p>而Table 1介绍了fuzzer使用的核心技术：</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/80.png" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="fuzz的流程"><a href="#fuzz的流程" class="headerlink" title="fuzz的流程"></a>fuzz的流程</h3><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>一些fuzzer在第一次执行fuzz前会初始化fuzz configurations。预处理一般分为以下几个步骤：</p><ul><li>插桩</li><li>种子选择</li><li>种子修剪</li><li>准备驱动程序</li></ul><h5 id="插桩"><a href="#插桩" class="headerlink" title="插桩"></a>插桩</h5><p>插桩可以是动态插桩也可以是静态插桩，相比于动态插桩，静态插桩的时间更小。静态插桩通常是在编译过程中在源代码或中间代码上进行插桩。如果PUT依赖于库，那么必须对它们进行单独插桩。动态插桩虽然开销大于静态插桩，但是动态插桩的优势是可以插桩动态链接库。</p><h5 id="种子选择"><a href="#种子选择" class="headerlink" title="种子选择"></a>种子选择</h5><p>好的种子选择策略可以改进fuzzing的效率和效果。根据研究显示，种子的代码覆盖率增加1%就会使发现bug的百分比增加0.92%。fuzzer通常遵循以下原则来选取种子：</p><ul><li>覆盖更多代码的种子、有可能触发异常的种子具有更高的优先级</li><li>减少重复路径执行</li><li>最优化选择能够覆盖更深和更有可能出现异常的种子</li></ul><h5 id="种子修剪"><a href="#种子修剪" class="headerlink" title="种子修剪"></a>种子修剪</h5><p>较小的种子意味着内存消耗更小，吞吐量更高。一些fuzzer尝试减小种子的尺寸来提升fuzzer的效率。</p><h5 id="准备驱动程序"><a href="#准备驱动程序" class="headerlink" title="准备驱动程序"></a>准备驱动程序</h5><p>当应用程序难以直接fuzz时，通常会为其准备一个模糊驱动程序。比如当fuzz库时，需要准备一个调用库函数的驱动程序。</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>在fuzz中，调度意味着为下一个模糊运行选择模糊配置，不同的fuzzer拥有不同的调度算法。在黑盒设置中，调度算法可以使用的唯一信息是配置的模糊结果，而灰盒设置中，调度算法可以选择使用关于每种配置的更丰富的信息集。有关调度，之后会结合fuzzer进行分析。</p><h3 id="输入生成"><a href="#输入生成" class="headerlink" title="输入生成"></a>输入生成</h3><p>由于测试用例的内容决定了是否出发漏洞，因此输入生成技术是模糊测试中最有影响力的设计决策之一。正如前面介绍的，fuzzer可以分为基于生成的fuzzer和基于变异的fuzzer。</p><h4 id="基于生成的fuzzer"><a href="#基于生成的fuzzer" class="headerlink" title="基于生成的fuzzer"></a>基于生成的fuzzer</h4><p>基于生成的fuzzer是基于给定模型生成测试用例，该模型描述了测试程序可以接受的输入或执行，比如精确表征输入格式的语法或不太精确的约束。</p><p>Peach、Spike等fuzzer可以使用用户配置的预定义的模型。其他基于生成的fuzzer针对特定的语言或语法，并且该语言的模型内置于fuzzer本身。</p><p>推断模型而不是依赖于预定义的逻辑或用户提供的模型，但是只有一小部分fuzzer采用腿短模型这种技术。推断模型可以分为：<code>Preprocess</code>和<code>ConfUpdate</code>。</p><p><code>Preprocess</code>：一些fuzzer将模型推断为模糊测试前的第一步。</p><p><code>ConfUpdate</code>：在每个模糊迭代中，fuzzer都更新模型。</p><h4 id="基于变异的fuzzer"><a href="#基于变异的fuzzer" class="headerlink" title="基于变异的fuzzer"></a>基于变异的fuzzer</h4><p>比特翻转是许多基于变异的fuzzer常使用的技术。除了比特翻转之外，诸如AFL和Hongfuzz等fuzzer，它们将所选字节序列视作整数并对该值进行简单算术。此举称为算数变异。例如AFL，AFL从种子中选择一个4字节的值，将该值视作整数i。然后用i+r或i-r替换种子中的值(r是随机生成的小整数)。</p><p>除此之外，一些fuzzer还使用基于块的变异以及基于字典的变异两种方法。在基于块的变异中，块石种子的字节序列。fuzzer首先将随机生成的块插入种子的随机位置，接着从种子中删除随机选择的块，随后fuzzer用随机值替换随机选择的块冰随机置换一系列块的顺序。最后fuzzer通过附加随机区来调整种子的大小并从种子中取一个随机块来插入/替换另一个种子的随机块。</p><h4 id="白盒fuzzer"><a href="#白盒fuzzer" class="headerlink" title="白盒fuzzer"></a>白盒fuzzer</h4><p>白盒fuzzer也可以分为基于生成的fuzzer和基于变异的fuzzer。传统的符号执行在基于变异的fuzzer中不需要任何模型，但一些符号执行器需要利用输入模型，如输入语法指导符号执行。</p><p>一些fuzzer利用静态/动态程序分析技术来增强fuzz的有效性，比如获取有关测试程序的有用信息的高代价程序分析以及在先前分析指导下生成测试用例。</p><h3 id="输入评估"><a href="#输入评估" class="headerlink" title="输入评估"></a>输入评估</h3><p>输入评估可以分为执行优化和分类两大部分。</p><p>生成输入数据后，fuzzer执行输入并对输入进行处理。而每个fuzzer都需要处理的一个问题就是fuzz的效率。例如AFL提供了fork-server功能，它允许每个新的模糊迭代从已经初始化的进程中fork。</p><p>分类是分析和报告导致违反策略的测试用例的过程。分类可以分为三个步骤：重复数据删除，优先级排序和测试用例最小化。重复数据删除是从输出集中修剪与其它测试样例触发相同的错误的测试样例的过程，理想情况下，重复数据删除会返回一组测试用例，其中每个测试用例都会触发一个独特的错误。目前在实践中使用了两种主要的重复数据删除实现：<code>堆栈回溯哈希</code>和<code>基于覆盖的重复数据删除</code>。优先级是根据严重性和唯一性对违反测试用例进行排名或分组的过程。传统上使用模糊测试来发现内存漏洞，在这种情况下，优先级更好地称为确定崩溃的可利用性。而分类的另一个重要部分是测试用例最小化。测试用例最小化是识别触发违规所必需的违规测试用例部分的过程，并且可选地产生比原始测试用例更小且更简单但仍然导致违规的测试用例。</p><h3 id="配置更新"><a href="#配置更新" class="headerlink" title="配置更新"></a>配置更新</h3><h4 id="进化种子库更新"><a href="#进化种子库更新" class="headerlink" title="进化种子库更新"></a>进化种子库更新</h4><p>进化算法是一种启发式的算法，其最重要的一步就是维持一个种子库，将新配置添加到配置集中。大多数fuzzer通常使用节点或分支覆盖作为适应度函数：如果测试用例发现新节点或分支，则将其添加到种子池中。 AFL 进一步考虑了分支机构被采取的次数。Angora通过考虑每个分支的调用上下文来改进AFL的适应性标准。 Steelix 检查哪个输入偏移影响测试程序的比较指令的过程以及进化种子池的代码覆盖率。</p><h4 id="维护Minset"><a href="#维护Minset" class="headerlink" title="维护Minset"></a>维护Minset</h4><p>由于能够创建新的模糊测试配置，因此还存在创建过多配置的风险。用于降低此风险的常见策略是维护最小化或最小化测试用例集，以最大化覆盖度量。一些fuzzer使用维护专用于配置更新的minset的变体。AFL使用剔除程序将minset配置标记为有利，而不是完全删除不在minset中的配置。通过调度函数，有利的模糊测试配置被选择用于模糊测试的可能性显著提高。</p><h3 id="fuzz中的关键问题"><a href="#fuzz中的关键问题" class="headerlink" title="fuzz中的关键问题"></a>fuzz中的关键问题</h3><ul><li>如何变异种子输入</li><li>如何提高代码覆盖率</li><li>输入的测试数据如何通过测试程序的验证</li></ul><h3 id="定向fuzz与覆盖导向fuzz"><a href="#定向fuzz与覆盖导向fuzz" class="headerlink" title="定向fuzz与覆盖导向fuzz"></a>定向fuzz与覆盖导向fuzz</h3><p>接着上文分类来看，按照探索策略，fuzz可以分为定向fuzz(directed fuzz)和覆盖导向fuzz(coverage-based fuzz)。大多数的灰盒模糊测试都是基于覆盖导向的，这种设计的目的是在有限的时间预算内覆盖尽可能多的程序路径。但是将不同的代码视为相同的是不合适的，有些代码的bug可能性会更大，通过盲目地扩展代码覆盖范围来测试软件效率较低，因此才会有定向模糊测试。定向模糊测试会将大部分时间花在<strong>特定目标位置</strong>（容易出bug的地方）。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>种子选择策略不同：覆盖导向fuzz的目的是最大化路径覆盖，因此它会优先选择触发新路径的种子。定向fuzz的目的是到达代码中的特定位置，因此它会优先选择更接近目标的种子。选择策略不同导致定向fuzz评估种子的指标产生很大变化，包括距离、覆盖、路径和概率。</li><li>目标设置不同：定向fuzz会对程序进行目标设置，从而使整个fuzz流程更具备方向性。</li><li>fuzz阶段不同：定向fuzz有两个阶段，第一个阶段的目的是使得fuzzing可以获得更多的信息，可能有更多的突变的种子；第二个阶段的目的只是让种子接近目标。</li></ul><h4 id="定向fuzz-DGF"><a href="#定向fuzz-DGF" class="headerlink" title="定向fuzz(DGF)"></a>定向fuzz(DGF)</h4><blockquote><p>有篇关于定向灰盒fuzz的综述文章：《SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing》。</p></blockquote><p>这篇文章调研了18-20年间的28个定向型fuzzer，并根据相应的指标对这些工作使用核心技术的进行分析。</p><p>总体来说，定向型fuzzer主要有以下核心技术：</p><ul><li>目标标记</li><li>输入优化</li><li>种子选择策略</li><li>能量调度</li><li>突变策略优化</li><li>数据流分析</li></ul><h5 id="目标标记"><a href="#目标标记" class="headerlink" title="目标标记"></a>目标标记</h5><p>起初的目标标记是基于手动标记来实现的，之后出现了使用目标序列来引导的fuzzer。</p><h5 id="输入优化"><a href="#输入优化" class="headerlink" title="输入优化"></a>输入优化</h5><p>标记完目标后，定向fuzzer需要生成种子输入来调用模糊过程，而良好的种子输入可以使模糊过程更接近目标位置，提高后期突变过程的性能。</p><h5 id="种子选择策略"><a href="#种子选择策略" class="headerlink" title="种子选择策略"></a>种子选择策略</h5><p>DGF的关键是优先选取某些指标下表现更好的种子，而常见的指标如下：距离、相似度、概率。</p><ul><li>距离：基于距离指标，优先选择距离近的种子。AFLGO是第一个距离指标的，在编译过程中AFLGO会记录源码并通过输入的测试程序的调用图以及控制流图的边数来计算到目标基本块的距离。基于距离的方法的缺点在于它只关注最短的距离，当有多个路径到达相同目标时，较长的选项可能被忽略，导致误差。</li><li>相似度：相似度表示某些目标的相似度(如目标序列)。Hawkeye利用静态分析技术，结合基本块跟踪距离和覆盖函数相似度进行种子排序和功率调度。UAFL使用操作序列覆盖作为反馈来指导测试用例生成。</li><li>概率：根据种子达到目标的可能性来确定种子的优先级。V-FUZZ和SUZZER基于深度学习模型来预测脆弱概率，并给脆弱函数中的每个基本块一个评分，对于每个输入，计算所有分数的总和，依据总和来决定优先级。</li></ul><h5 id="能量调度"><a href="#能量调度" class="headerlink" title="能量调度"></a>能量调度</h5><p>大多数定向fuzzer在能量调度阶段都适用模拟退火算法。AFLGO使用该算法将能量调度给距离更近的种子并减少传递到距离远的种子的能量。</p><h5 id="突变策略优化"><a href="#突变策略优化" class="headerlink" title="突变策略优化"></a>突变策略优化</h5><p>一些fuzzer通过对突变策略进行优化从而辅助定向fuzzing。Hawkeye通过自适应突变策略进行分类。粗粒度的突变器用于在突变期间更改大量字节，细粒度突变器只会修改几个字节。当种子可以到达目标函数时，Hawkeye只提供较少的发送粗粒度突变的机会，当种子到达目标，进行细粒度突变的时间就会增加。其他fuzzer也有类似的策略：V-FUZZ将突变策略分为轻微突变和严重突变，并通过阈值来动态调整突变策略。</p><h5 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h5><p>通过数据流分析(如污点分析)可以反应突变对生成的输入的影响，从而优化突变策略和输入生成。UAFL采用信息流分析来是吧条件语句中的输入与程序变量之间的关系，并对这些信息流强度高的输入字节赋予更高的突变可能性。然而数据流分析通常会增加运行时开销。</p><h2 id="流行的fuzzer"><a href="#流行的fuzzer" class="headerlink" title="流行的fuzzer"></a>流行的fuzzer</h2><h3 id="AFL"><a href="#AFL" class="headerlink" title="AFL"></a>AFL</h3><blockquote><p>官方编写了<a target="_blank" rel="noopener" href="https://lcamtuf.coredump.cx/afl/technical_details.txt">《AFL白皮书》</a>对AFL的策略进行了整体上的介绍。</p></blockquote><h4 id="AFL简介"><a href="#AFL简介" class="headerlink" title="AFL简介"></a>AFL简介</h4><h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><p>首先，AFL是一个基于覆盖引导的fuzzer，它的工作流程如下：</p><ul><li>编译时插桩，记录代码覆盖率</li><li>选择一些输入文件作为初始的PUT加入输入队列</li><li>依据策略对输入数据进行突变</li><li>如果经过变异的输入更新了覆盖范围，则将其保留在队列中</li><li>重复以上过程，记录触发crash的输入</li></ul><h5 id="fuzz准备工作"><a href="#fuzz准备工作" class="headerlink" title="fuzz准备工作"></a>fuzz准备工作</h5><h6 id="被测试程序构建"><a href="#被测试程序构建" class="headerlink" title="被测试程序构建"></a>被测试程序构建</h6><p>使用AFL，首先要使用afl-gcc/afl-clang等工具来编译目标，afl会在编译的时候以每个基本块为单位,进行代码插桩。</p><h6 id="语料库构建"><a href="#语料库构建" class="headerlink" title="语料库构建"></a>语料库构建</h6><p>高质量的语料库可以提高fuzzing效率，而构建语料库时一般都会涉及到三个问题：</p><ul><li>如何选择输入文件</li><li>从哪里寻找输入文件</li><li>如何精简找到的文件</li></ul><p>构建方法：对于输入文件的选择，可以从项目提供的测试用例或者一些开源的语料库中选取，尽量选择小体积的输入文件。</p><p>一些开源的语料库：</p><p><a target="_blank" rel="noopener" href="https://gitlab.anu.edu.au/lunar/moonshine">moonshine</a></p><p><a target="_blank" rel="noopener" href="https://github.com/MozillaSecurity/fuzzdata">fuzzdata</a></p><p><a target="_blank" rel="noopener" href="https://samples.libav.org/">libav samples</a></p><p><a target="_blank" rel="noopener" href="http://lcamtuf.coredump.cx/afl/demo/">afl generated image test sets</a></p><p>不过开源语料库包含大量的文件，使用时需要对其进行修剪，做语料库蒸馏。AFL提供了两个工具来帮助我们完成这部工作——<code>afl-cmin</code>和<code>afl-tmin</code>。这两个工具的逻辑是有去区别的，<code>afl-cmin</code>的工作逻辑是寻找与语料库全集具有相同覆盖范围的最小子集，而<code>afl-tmin</code>的工作逻辑是缩减输入文件的体积。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h4 id="使用AFL-进行fuzz"><a href="#使用AFL-进行fuzz" class="headerlink" title="使用AFL 进行fuzz"></a>使用AFL 进行fuzz</h4></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/fuzz/">fuzz</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/fuzz/">fuzz</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2021/03/02/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">符号执行记录</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2021/01/19/dns%E8%BD%AF%E4%BB%B6%E6%A0%88/"><span class="hidden-mobile">关于DNS软件栈的一些思考</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/boot.js"></script></body></html>