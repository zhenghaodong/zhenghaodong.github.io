<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;dark&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/17.jpeg"><link rel="icon" href="/img/17.jpeg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="阅读几款开源DNS软件栈的源码"><meta name="author" content="wizard"><meta name="keywords" content="DNS"><title>关于DNS软件栈的一些思考 - zhd&#39;s blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:30,cursorChar:"/",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>zhd's blog</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://tva1.sinaimg.cn/large/0082zybply1gbss5d0prgj31900u0npq.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="关于DNS软件栈的一些思考"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-01-19 09:22" pubdate>2021年1月19日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 69 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">关于DNS软件栈的一些思考</h1><div class="markdown-body"><blockquote><p>阅读了流行的dns软件栈的源码，从安全角度理解这些软件栈的设计思路并尝试在其中挖掘一些逻辑上的漏洞。</p><p>长期更新～</p></blockquote><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><h2 id="bind9逻辑"><a href="#bind9逻辑" class="headerlink" title="bind9逻辑"></a>bind9逻辑</h2><h3 id="工作模式总览"><a href="#工作模式总览" class="headerlink" title="工作模式总览"></a>工作模式总览</h3><p>在bind9初始化时，创建cpu个数个线程与管理这些线程的manager。每个线程运行时调用run函数对manager中的task进行操作。每个线程会从ready_task中选择一个task循环的执行task中的event的回调，在循环task时，如果发现task中的事件为空或者执行的事件的数目超过一定的数值以后，就跳出task的循环；如果一个task中没有事件了那就释放 task的内存，然后会有俩个条件变量的处理，最后如果task还要事件未处理完的话就再次放入到ready_task队列中。</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><blockquote><p>create_managers()</p></blockquote><h4 id="创建任务-manager"><a href="#创建任务-manager" class="headerlink" title="创建任务 manager"></a>创建任务 manager</h4><p>bind9中关于task manager结构的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">isc__taskmgr</span> &#123;</span><br>	<span class="hljs-comment">/* Not locked. */</span><br>	<span class="hljs-keyword">isc_taskmgr_t</span> common;<br>	<span class="hljs-keyword">isc_mem_t</span> *mctx;<br>	<span class="hljs-keyword">isc_mutex_t</span> lock;<br>	<span class="hljs-keyword">isc_mutex_t</span> halt_lock;<br>	<span class="hljs-keyword">isc_condition_t</span> halt_cond;<br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> workers;<br>	<span class="hljs-keyword">atomic_uint_fast32_t</span> tasks_running;<br>	<span class="hljs-keyword">atomic_uint_fast32_t</span> tasks_ready;<br>	<span class="hljs-keyword">atomic_uint_fast32_t</span> curq;<br>	<span class="hljs-keyword">atomic_uint_fast32_t</span> tasks_count;<br>	<span class="hljs-keyword">isc__taskqueue_t</span> *queues;<br>	<span class="hljs-keyword">isc_nm_t</span> *nm;<br>	<span class="hljs-comment">/* Locked by task manager lock. */</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> default_quantum;<br>	LIST(<span class="hljs-keyword">isc__task_t</span>) tasks;<br>	<span class="hljs-keyword">atomic_uint_fast32_t</span> mode;<br>	<span class="hljs-keyword">atomic_bool</span> pause_req;<br>	<span class="hljs-keyword">atomic_bool</span> exclusive_req;<br>	<span class="hljs-keyword">atomic_bool</span> exiting;<br>	<span class="hljs-comment">/* Locked by halt_lock */</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> halted;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Multiple threads can read/write &#x27;excl&#x27; at the same time, so we need</span><br><span class="hljs-comment">	 * to protect the access.  We can&#x27;t use &#x27;lock&#x27; since isc_task_detach()</span><br><span class="hljs-comment">	 * will try to acquire it.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">isc_mutex_t</span> excl_lock;<br>	<span class="hljs-keyword">isc__task_t</span> *excl;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到每个manager会管理多个任务线程并维护每个任务线程的queue。每个线程都有一个queue，queue上存放对应线程需要处理的task，每个线程的threadid都在queue上注册，而queue本身又是manager结构体中的一个变量，因此每个线程相当于在manager中申请了一个位置。</p><p>有关queue的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">isc__taskqueue</span> &#123;</span><br>	<span class="hljs-comment">/* Everything locked by lock */</span><br>	<span class="hljs-keyword">isc_mutex_t</span> lock;<br>	<span class="hljs-keyword">isc__tasklist_t</span> ready_tasks;<br>	<span class="hljs-keyword">isc__tasklist_t</span> ready_priority_tasks;<br>	<span class="hljs-keyword">isc_condition_t</span> work_available;<br>	<span class="hljs-keyword">isc_thread_t</span> thread;<br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid;<br>	<span class="hljs-keyword">isc__taskmgr_t</span> *manager;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有关task的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">isc__task</span> &#123;</span><br>	<span class="hljs-comment">/* Not locked. */</span><br>	<span class="hljs-keyword">isc_task_t</span> common;<br>	<span class="hljs-keyword">isc__taskmgr_t</span> *manager;<br>	<span class="hljs-keyword">isc_mutex_t</span> lock;<br>	<span class="hljs-comment">/* Locked by task lock. */</span><br>	<span class="hljs-keyword">task_state_t</span> state;<br>	<span class="hljs-keyword">int</span> pause_cnt;<br>	<span class="hljs-keyword">isc_refcount_t</span> references;<br>	<span class="hljs-keyword">isc_eventlist_t</span> events;<br>	<span class="hljs-keyword">isc_eventlist_t</span> on_shutdown;<br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nevents;<br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> quantum;<br>	<span class="hljs-keyword">isc_stdtime_t</span> now;<br>	<span class="hljs-keyword">isc_time_t</span> tnow;<br>	<span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];<br>	<span class="hljs-keyword">void</span> *tag;<br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid;<br>	<span class="hljs-keyword">bool</span> bound;<br>	<span class="hljs-comment">/* Protected by atomics */</span><br>	<span class="hljs-keyword">atomic_uint_fast32_t</span> flags;<br>	<span class="hljs-comment">/* Locked by task manager lock. */</span><br>	LINK(<span class="hljs-keyword">isc__task_t</span>) link;<br>	LINK(<span class="hljs-keyword">isc__task_t</span>) ready_link;<br>	LINK(<span class="hljs-keyword">isc__task_t</span>) ready_priority_link;<br>&#125;;<br></code></pre></td></tr></table></figure><p>create_manager()函数通过调用isc_create_taskmgr()函数来创建task manager，函数一开始会出实话manager中的一些信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">manager = isc_mem_get(mctx, <span class="hljs-keyword">sizeof</span>(*manager));<br>*manager = (<span class="hljs-keyword">isc__taskmgr_t</span>)&#123; .common.impmagic = TASK_MANAGER_MAGIC,<br>                            .common.magic = ISCAPI_TASKMGR_MAGIC &#125;;<br>atomic_store(&amp;manager-&gt;mode, isc_taskmgrmode_normal);<br>isc_mutex_init(&amp;manager-&gt;lock);<br>isc_mutex_init(&amp;manager-&gt;excl_lock);<br>isc_mutex_init(&amp;manager-&gt;halt_lock);<br>isc_condition_init(&amp;manager-&gt;halt_cond);<br>manager-&gt;workers = workers;<br><span class="hljs-keyword">if</span> (default_quantum == <span class="hljs-number">0</span>) &#123;<br>  default_quantum = DEFAULT_DEFAULT_QUANTUM;<br>&#125;<br>manager-&gt;default_quantum = default_quantum;<br><span class="hljs-keyword">if</span> (nm != <span class="hljs-literal">NULL</span>) &#123;<br>  isc_nm_attach(nm, &amp;manager-&gt;nm);<br>&#125;<br>INIT_LIST(manager-&gt;tasks);<br>atomic_store(&amp;manager-&gt;tasks_count, <span class="hljs-number">0</span>);<br><span class="hljs-comment">//设置queue大小，大小为工作线程数*taskqueue结构体大小</span><br>manager-&gt;queues = isc_mem_get(mctx, workers * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">isc__taskqueue_t</span>));<br>RUNTIME_CHECK(manager-&gt;queues != <span class="hljs-literal">NULL</span>);<br>atomic_init(&amp;manager-&gt;tasks_running, <span class="hljs-number">0</span>);<br>atomic_init(&amp;manager-&gt;tasks_ready, <span class="hljs-number">0</span>);<br>atomic_init(&amp;manager-&gt;curq, <span class="hljs-number">0</span>);<br>atomic_init(&amp;manager-&gt;exiting, <span class="hljs-literal">false</span>);<br>atomic_store_relaxed(&amp;manager-&gt;exclusive_req, <span class="hljs-literal">false</span>);<br>atomic_store_relaxed(&amp;manager-&gt;pause_req, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>接着开始启动manager管理下的task：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; workers; i++) &#123;<br>		INIT_LIST(manager-&gt;queues[i].ready_tasks);<br>		INIT_LIST(manager-&gt;queues[i].ready_priority_tasks);<br>		isc_mutex_init(&amp;manager-&gt;queues[i].lock);<br>		isc_condition_init(&amp;manager-&gt;queues[i].work_available);<br><br>		manager-&gt;queues[i].manager = manager;<br>		manager-&gt;queues[i].threadid = i;<br>		isc_thread_create(run, &amp;manager-&gt;queues[i],<br>				  &amp;manager-&gt;queues[i].thread);<br>		<span class="hljs-keyword">char</span> name[<span class="hljs-number">21</span>];<br>		<span class="hljs-built_in">snprintf</span>(name, <span class="hljs-keyword">sizeof</span>(name), <span class="hljs-string">&quot;isc-worker%04u&quot;</span>, i);<br>		isc_thread_setname(manager-&gt;queues[i].thread, name);<br>	&#125;<br></code></pre></td></tr></table></figure><p>其中工作线程的启动函数是run函数，参数为&amp;manager-&gt;queues[i]，有关run函数的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">isc_threadresult_t</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN32</span><br>	WINAPI<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* ifdef _WIN32 */</span></span><br>	run(<span class="hljs-keyword">void</span> *queuep) &#123;<br>	<span class="hljs-keyword">isc__taskqueue_t</span> *tq = queuep;<br>	<span class="hljs-keyword">isc__taskmgr_t</span> *manager = tq-&gt;manager;<br>	<span class="hljs-keyword">int</span> threadid = tq-&gt;threadid;<br>	isc_thread_setaffinity(threadid);<br>	XTHREADTRACE(<span class="hljs-string">&quot;starting&quot;</span>);<br>	dispatch(manager, threadid);<br>	XTHREADTRACE(<span class="hljs-string">&quot;exiting&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> OPENSSL_LEAKS</span><br>	ERR_remove_state(<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* ifdef OPENSSL_LEAKS */</span></span><br>	<span class="hljs-keyword">return</span> ((<span class="hljs-keyword">isc_threadresult_t</span>)<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>run函数根据传入的queue，获取工作线程的线程id，并通过manager调用dispatch()为该线程分配任务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch</span><span class="hljs-params">(<span class="hljs-keyword">isc__taskmgr_t</span> *manager, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid)</span> </span>&#123;<br><br>	......<br>	<br>	<span class="hljs-keyword">while</span> (!FINISHED(manager)) &#123;<br>		<br>		......<br><br>			<span class="hljs-keyword">do</span> &#123;<br>				<span class="hljs-keyword">if</span> (!EMPTY(task-&gt;events)) &#123;<br>					event = HEAD(task-&gt;events);<br>					DEQUEUE(task-&gt;events, event, ev_link);<br>					task-&gt;nevents--;<br><br>					<span class="hljs-comment">/*</span><br><span class="hljs-comment">					 * Execute the event action.</span><br><span class="hljs-comment">					 */</span><br>					XTRACE(<span class="hljs-string">&quot;execute action&quot;</span>);<br>					XTRACE(task-&gt;name);<br>					<span class="hljs-keyword">if</span> (event-&gt;ev_action != <span class="hljs-literal">NULL</span>) &#123;<br>						UNLOCK(&amp;task-&gt;lock);<br>						(event-&gt;ev_action)(<br>							(<span class="hljs-keyword">isc_task_t</span> *)task,<br>							event);<br>						LOCK(&amp;task-&gt;lock);<br>					&#125;<br>					XTRACE(<span class="hljs-string">&quot;execution complete&quot;</span>);<br>					dispatch_count++;<br>				&#125;<br><br>				<span class="hljs-keyword">if</span> (isc_refcount_current(&amp;task-&gt;references) ==<br>					    <span class="hljs-number">0</span> &amp;&amp;<br>				    EMPTY(task-&gt;events) &amp;&amp;<br>				    !TASK_SHUTTINGDOWN(task))<br>				&#123;<br>					<span class="hljs-keyword">bool</span> was_idle;<br><br>					was_idle = task_shutdown(task);<br>					INSIST(!was_idle);<br>				&#125;<br><br>				<span class="hljs-keyword">if</span> (EMPTY(task-&gt;events)) &#123;<br>					XTRACE(<span class="hljs-string">&quot;empty&quot;</span>);<br>					<span class="hljs-keyword">if</span> (isc_refcount_current(<br>						    &amp;task-&gt;references) == <span class="hljs-number">0</span> &amp;&amp;<br>					    TASK_SHUTTINGDOWN(task)) &#123;<br>						XTRACE(<span class="hljs-string">&quot;done&quot;</span>);<br>						finished = <span class="hljs-literal">true</span>;<br>						task-&gt;state = task_state_done;<br>					&#125; <span class="hljs-keyword">else</span> &#123;<br>						<span class="hljs-keyword">if</span> (task-&gt;state ==<br>						    task_state_running) &#123;<br>							task-&gt;state =<br>								task_state_idle;<br>						&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (task-&gt;state ==<br>							   task_state_pausing) &#123;<br>							task-&gt;state =<br>								task_state_paused;<br>						&#125;<br>					&#125;<br>					done = <span class="hljs-literal">true</span>;<br>				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (task-&gt;state == task_state_pausing) &#123;<br>					<span class="hljs-keyword">isc_event_t</span><br>					XTRACE(<span class="hljs-string">&quot;pausing&quot;</span>);<br>					task-&gt;state = task_state_paused;<br>					done = <span class="hljs-literal">true</span>;<br>				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dispatch_count &gt;= task-&gt;quantum) &#123;<br>					XTRACE(<span class="hljs-string">&quot;quantum&quot;</span>);<br>					task-&gt;state = task_state_ready;<br>					requeue = <span class="hljs-literal">true</span>;<br>					done = <span class="hljs-literal">true</span>;<br>				&#125;<br>			&#125; <span class="hljs-keyword">while</span> (!done);<br>			<br>			......<br>			<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建socket-manager"><a href="#创建socket-manager" class="headerlink" title="创建socket manager"></a>创建socket manager</h4><p>bind9中关于socket manager结构的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">isc__socketmgr</span> &#123;</span><br>	<span class="hljs-comment">/* Not locked. */</span><br>	<span class="hljs-keyword">isc_socketmgr_t</span> common;<br>	<span class="hljs-keyword">isc_mem_t</span> *mctx;<br>	<span class="hljs-keyword">isc_mutex_t</span> lock;<br>	<span class="hljs-keyword">isc_stats_t</span> *stats;<br>	<span class="hljs-keyword">int</span> nthreads;<br>	<span class="hljs-keyword">isc__socketthread_t</span> *threads;<br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> maxsocks;<br>	<span class="hljs-comment">/* Locked by manager lock. */</span><br>	ISC_LIST(<span class="hljs-keyword">isc__socket_t</span>) socklist;<br>	<span class="hljs-keyword">int</span> reserved; <span class="hljs-comment">/* unlocked */</span><br>	<span class="hljs-keyword">isc_condition_t</span> shutdown_ok;<br>	<span class="hljs-keyword">size_t</span> maxudp;<br>&#125;;<br></code></pre></td></tr></table></figure><p>bind9只会声明一个socket manager，该manager定义了一些基本限制比如maxsocks、maxudp等，然后这个manager会管理所有的socket thread。</p><p>在create_manager()函数中，调用了<code>isc_socketmgr_create2(named_g_mctx, &amp;named_g_socketmgr,maxsocks, named_g_cpus);</code>，该函数细节如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (maxsocks == <span class="hljs-number">0</span>) &#123;<br>		maxsocks = ISC_SOCKET_MAXSOCKETS;<br>	&#125;<br><br>	manager = isc_mem_get(mctx, <span class="hljs-keyword">sizeof</span>(*manager));<br><br>	<span class="hljs-comment">/* zero-clear so that necessary cleanup on failure will be easy */</span><br>	<span class="hljs-built_in">memset</span>(manager, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(*manager));<br>	manager-&gt;maxsocks = maxsocks;<br>	manager-&gt;reserved = <span class="hljs-number">0</span>;<br>	manager-&gt;maxudp = <span class="hljs-number">0</span>;<br>	manager-&gt;nthreads = nthreads;<br>	manager-&gt;stats = <span class="hljs-literal">NULL</span>;<br><br>	manager-&gt;common.magic = ISCAPI_SOCKETMGR_MAGIC;<br>	manager-&gt;common.impmagic = SOCKET_MANAGER_MAGIC;<br>	manager-&gt;mctx = <span class="hljs-literal">NULL</span>;<br>	ISC_LIST_INIT(manager-&gt;socklist);<br>	isc_mutex_init(&amp;manager-&gt;lock);<br>	isc_condition_init(&amp;manager-&gt;shutdown_ok);<br></code></pre></td></tr></table></figure><p>首先先定义了最大的socket连接数，宏<code>ISC_SOCKET_MAXSOCKETS</code>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ISC_SOCKET_MAXSOCKETS</span><br>	<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(USE_KQUEUE) || defined(USE_EPOLL) || defined(USE_DEVPOLL)</span><br>		<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> TUNE_LARGE</span><br>			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ISC_SOCKET_MAXSOCKETS 21000</span><br>		<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> <span class="hljs-comment">/* ifdef TUNE_LARGE */</span></span><br>			<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ISC_SOCKET_MAXSOCKETS 4096</span><br>		<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* TUNE_LARGE */</span></span><br>	<span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(USE_SELECT)</span><br>		<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ISC_SOCKET_MAXSOCKETS FD_SETSIZE</span><br>	<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* USE_KQUEUE... */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* ISC_SOCKET_MAXSOCKETS */</span></span><br></code></pre></td></tr></table></figure><p>接着对于每个被manager管理的socket线程，声明这些线程的基本信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">manager-&gt;threads = isc_mem_get(mctx, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">isc__socketthread_t</span>) * manager-&gt;nthreads);<br>isc_mem_attach(mctx, &amp;manager-&gt;mctx);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; manager-&gt;nthreads; i++) &#123;<br>  manager-&gt;threads[i].manager = manager;<br>  manager-&gt;threads[i].threadid = i;<br>  setup_thread(&amp;manager-&gt;threads[i]);<br>  isc_thread_create(netthread, &amp;manager-&gt;threads[i],<br>                    &amp;manager-&gt;threads[i].thread);<br>  <span class="hljs-keyword">char</span> tname[<span class="hljs-number">1024</span>];<br>  <span class="hljs-built_in">sprintf</span>(tname, <span class="hljs-string">&quot;isc-socket-%d&quot;</span>, i);<br>  isc_thread_setname(manager-&gt;threads[i].thread, tname);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><p>main函数中，setup函数会创建线程并对bind9做初始化，在setup函数结束之后会启动服务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Start things running and then wait for a shutdown request</span><br><span class="hljs-comment">	 * or reload.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">do</span> &#123;<br>		result = isc_app_run();<br><br>		<span class="hljs-keyword">if</span> (result == ISC_R_RELOAD) &#123;<br>			named_server_reloadwanted(named_g_server);<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != ISC_R_SUCCESS) &#123;<br>			UNEXPECTED_ERROR(__FILE__, __LINE__,<br>					 <span class="hljs-string">&quot;isc_app_run(): %s&quot;</span>,<br>					 isc_result_totext(result));<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * Force exit.</span><br><span class="hljs-comment">			 */</span><br>			result = ISC_R_SUCCESS;<br>		&#125;<br>	&#125; <span class="hljs-keyword">while</span> (result != ISC_R_SUCCESS);<br></code></pre></td></tr></table></figure><p>在循环中，首先调用isc_app_run()来启动服务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">isc_result_t</span></span><br><span class="hljs-function"><span class="hljs-title">isc_app_run</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>	<span class="hljs-keyword">isc_result_t</span> result;<br><br>	REQUIRE(atomic_compare_exchange_strong_acq_rel(&amp;is_running,<br>						       &amp;(<span class="hljs-keyword">bool</span>)&#123; <span class="hljs-literal">false</span> &#125;, <span class="hljs-literal">true</span>));<br>	result = isc_app_ctxrun(&amp;isc_g_appctx);<br>	atomic_store_release(&amp;is_running, <span class="hljs-literal">false</span>);<br><br>	<span class="hljs-keyword">return</span> (result);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，idc_g_appctx的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">isc_appctx</span> &#123;</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> magic;<br>	<span class="hljs-keyword">isc_mem_t</span> *mctx;<br>	<span class="hljs-keyword">isc_mutex_t</span> lock;<br>	<span class="hljs-keyword">isc_eventlist_t</span> on_run;<br>	<span class="hljs-keyword">atomic_bool</span> shutdown_requested;<br>	<span class="hljs-keyword">atomic_bool</span> running;<br>	<span class="hljs-keyword">atomic_bool</span> want_shutdown;<br>	<span class="hljs-keyword">atomic_bool</span> want_reload;<br>	<span class="hljs-keyword">atomic_bool</span> blocked;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WIN32</span><br>	HANDLE hEvents[NUM_EVENTS];<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span>  <span class="hljs-comment">/* WIN32 */</span></span><br>	<span class="hljs-keyword">isc_mutex_t</span> readylock;<br>	<span class="hljs-keyword">isc_condition_t</span> ready;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* WIN32 */</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>isc_app_run()实际上是调用idc_app_ctxrun()：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">isc_event_t</span> *event, *next_event;<br><span class="hljs-keyword">isc_task_t</span> *task;<br>REQUIRE(VALID_APPCTX(ctx));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WIN32</span><br>REQUIRE(main_thread == GetCurrentThread());<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* ifdef WIN32 */</span></span><br><span class="hljs-keyword">if</span> (atomic_compare_exchange_strong_acq_rel(&amp;ctx-&gt;running, &amp;(<span class="hljs-keyword">bool</span>)&#123; <span class="hljs-literal">false</span> &#125;, <span class="hljs-literal">true</span>))<br>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Post any on-run events (in FIFO order).</span><br><span class="hljs-comment">	 */</span><br>  LOCK(&amp;ctx-&gt;lock);<br>  <span class="hljs-keyword">for</span> (event = ISC_LIST_HEAD(ctx-&gt;on_run); event != <span class="hljs-literal">NULL</span>; event = next_event) &#123;<br>    next_event = ISC_LIST_NEXT(event, ev_link);<br>    ISC_LIST_UNLINK(ctx-&gt;on_run, event, ev_link);<br>    task = event-&gt;ev_sender;<br>    event-&gt;ev_sender = <span class="hljs-literal">NULL</span>;<br>    isc_task_sendanddetach(&amp;task, &amp;event);<br>  &#125;<br>  UNLOCK(&amp;ctx-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于每个event，都会被挂在一个专门用于存储event的链表上并在ctx_run函数中被加载到task上。isc_task_sendanddetach()本质上是调用isc_task_sendtoanddetach()，该函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">isc_task_sendtoanddetach</span><span class="hljs-params">(<span class="hljs-keyword">isc_task_t</span> **taskp, <span class="hljs-keyword">isc_event_t</span> **eventp, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>	<span class="hljs-keyword">bool</span> idle1, idle2;<br>	<span class="hljs-keyword">isc__task_t</span> *task;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Send &#x27;*event&#x27; to &#x27;*taskp&#x27; and then detach &#x27;*taskp&#x27; from its</span><br><span class="hljs-comment">	 * task.</span><br><span class="hljs-comment">	 */</span><br>	REQUIRE(taskp != <span class="hljs-literal">NULL</span>);<br>	task = (<span class="hljs-keyword">isc__task_t</span> *)*taskp;<br>	REQUIRE(VALID_TASK(task));<br>	XTRACE(<span class="hljs-string">&quot;isc_task_sendanddetach&quot;</span>);<br>	LOCK(&amp;task-&gt;lock);<br>	<span class="hljs-keyword">if</span> (task-&gt;bound) &#123;<br>		c = task-&gt;threadid;<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span>) &#123;<br>		c = atomic_fetch_add_explicit(&amp;task-&gt;manager-&gt;curq, <span class="hljs-number">1</span>,<br>					      memory_order_relaxed);<br>	&#125;<br>	c %= task-&gt;manager-&gt;workers;<br>	idle1 = task_send(task, eventp, c);<br>	idle2 = task_detach(task);<br>	UNLOCK(&amp;task-&gt;lock);<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * If idle1, then idle2 shouldn&#x27;t be true as well since we&#x27;re holding</span><br><span class="hljs-comment">	 * the task lock, and thus the task cannot switch from ready back to</span><br><span class="hljs-comment">	 * idle.</span><br><span class="hljs-comment">	 */</span><br>	INSIST(!(idle1 &amp;&amp; idle2));<br>	<span class="hljs-keyword">if</span> (idle1 || idle2) &#123;<br>		task_ready(task);<br>	&#125;<br>	*taskp = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>主进程创建的task作为第一个参数传入isc_task_sendtoanddetach()中。</p><p>调用task_send()将event挂载到对应的工作线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span></span><br><span class="hljs-function"><span class="hljs-title">task_send</span><span class="hljs-params">(<span class="hljs-keyword">isc__task_t</span> *task, <span class="hljs-keyword">isc_event_t</span> **eventp, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>	<span class="hljs-keyword">bool</span> was_idle = <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">isc_event_t</span> *event;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Caller must be holding the task lock.</span><br><span class="hljs-comment">	 */</span><br>	REQUIRE(eventp != <span class="hljs-literal">NULL</span>);<br>	event = *eventp;<br>	*eventp = <span class="hljs-literal">NULL</span>;<br>	REQUIRE(event != <span class="hljs-literal">NULL</span>);<br>	REQUIRE(event-&gt;ev_type &gt; <span class="hljs-number">0</span>);<br>	REQUIRE(task-&gt;state != task_state_done);<br>	REQUIRE(!ISC_LINK_LINKED(event, ev_ratelink));<br><br>	XTRACE(<span class="hljs-string">&quot;task_send&quot;</span>);<br><br>	<span class="hljs-keyword">if</span> (task-&gt;state == task_state_idle) &#123;<br>		was_idle = <span class="hljs-literal">true</span>;<br>		task-&gt;threadid = c;<br>		INSIST(EMPTY(task-&gt;events));<br>		task-&gt;state = task_state_ready;<br>	&#125;<br>	INSIST(task-&gt;state == task_state_ready ||<br>	       task-&gt;state == task_state_running ||<br>	       task-&gt;state == task_state_paused ||<br>	       task-&gt;state == task_state_pausing);<br>	ENQUEUE(task-&gt;events, event, ev_link);<br>	task-&gt;nevents++;<br>	<span class="hljs-keyword">return</span> (was_idle);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于当前task，如果处于空闲状态，则设置处理该task的线程id并且将task的状态设置成ready，最后将event放入队列并设置task的nevents数量++。</p><p>调用task_detach()来将task从queue上分离：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span></span><br><span class="hljs-function"><span class="hljs-title">task_detach</span><span class="hljs-params">(<span class="hljs-keyword">isc__task_t</span> *task)</span> </span>&#123;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Caller must be holding the task lock.</span><br><span class="hljs-comment">	 */</span><br>	XTRACE(<span class="hljs-string">&quot;detach&quot;</span>);<br>	<span class="hljs-keyword">if</span> (isc_refcount_decrement(&amp;task-&gt;references) == <span class="hljs-number">1</span> &amp;&amp;<br>	    task-&gt;state == task_state_idle)<br>	&#123;<br>		INSIST(EMPTY(task-&gt;events));<br>		<span class="hljs-comment">/*</span><br><span class="hljs-comment">		 * There are no references to this task, and no</span><br><span class="hljs-comment">		 * pending events.  We could try to optimize and</span><br><span class="hljs-comment">		 * either initiate shutdown or clean up the task,</span><br><span class="hljs-comment">		 * depending on its state, but it&#x27;s easier to just</span><br><span class="hljs-comment">		 * make the task ready and allow run() or the event</span><br><span class="hljs-comment">		 * loop to deal with shutting down and termination.</span><br><span class="hljs-comment">		 */</span><br>		task-&gt;state = task_state_ready;<br>		<span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>);<br>	&#125;<br>	<span class="hljs-keyword">return</span> (<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在处理完event挂载之后，isc_app_run()会：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (!atomic_load_acquire(&amp;ctx-&gt;want_shutdown)) <br>	&#123;<br>		<span class="hljs-keyword">if</span> (isc_bind9) &#123;<br>			<span class="hljs-keyword">sigset_t</span> sset;<br>			<span class="hljs-keyword">int</span> sig;<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * BIND9 internal; single context:</span><br><span class="hljs-comment">			 * Wait for SIGHUP, SIGINT, or SIGTERM.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-keyword">if</span> (sigemptyset(&amp;sset) != <span class="hljs-number">0</span> || sigaddset(&amp;sset, SIGHUP) != <span class="hljs-number">0</span> || sigaddset(&amp;sset, SIGINT) != <span class="hljs-number">0</span> || sigaddset(&amp;sset, SIGTERM) != <span class="hljs-number">0</span>)<br>			&#123;<br>				<span class="hljs-keyword">char</span> strbuf[ISC_STRERRORSIZE];<br>				strerror_r(errno, strbuf, <span class="hljs-keyword">sizeof</span>(strbuf));<br>				isc_error_fatal(__FILE__, __LINE__,<br>						<span class="hljs-string">&quot;isc_app_run() sigsetops: %s&quot;</span>,<br>						strbuf);<br>			&#125;<br><br>			<span class="hljs-keyword">if</span> (sigwait(&amp;sset, &amp;sig) == <span class="hljs-number">0</span>) &#123;<br>				<span class="hljs-keyword">switch</span> (sig) &#123;<br>				<span class="hljs-keyword">case</span> SIGINT:<br>				<span class="hljs-keyword">case</span> SIGTERM:<br>					atomic_store_release(<br>						&amp;ctx-&gt;want_shutdown, <span class="hljs-literal">true</span>);<br>					<span class="hljs-keyword">break</span>;<br>				<span class="hljs-keyword">case</span> SIGHUP:<br>					atomic_store_release(&amp;ctx-&gt;want_reload, <span class="hljs-literal">true</span>);<br>					<span class="hljs-keyword">break</span>;<br>				<span class="hljs-keyword">default</span>:<br>					INSIST(<span class="hljs-number">0</span>);<br>					ISC_UNREACHABLE();<br>				&#125;<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">/*</span><br><span class="hljs-comment">			 * External, or BIND9 using multiple contexts:</span><br><span class="hljs-comment">			 * wait until woken up.</span><br><span class="hljs-comment">			 */</span><br>			<span class="hljs-keyword">if</span> (atomic_load_acquire(&amp;ctx-&gt;want_shutdown)) &#123;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (!atomic_load_acquire(&amp;ctx-&gt;want_reload)) &#123;<br>				LOCK(&amp;ctx-&gt;readylock);<br>				WAIT(&amp;ctx-&gt;ready, &amp;ctx-&gt;readylock);<br>				UNLOCK(&amp;ctx-&gt;readylock);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (atomic_compare_exchange_strong_acq_rel(&amp;ctx-&gt;want_reload, &amp;(<span class="hljs-keyword">bool</span>)&#123; <span class="hljs-literal">true</span> &#125;, <span class="hljs-literal">false</span>))<br>		&#123;<br>			<span class="hljs-keyword">return</span> (ISC_R_RELOAD);<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (atomic_load_acquire(&amp;ctx-&gt;want_shutdown) &amp;&amp; atomic_load_acquire(&amp;ctx-&gt;blocked))<br>		&#123;<br>			<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> (ISC_R_SUCCESS);<br></code></pre></td></tr></table></figure><h2 id="Unbound基本逻辑"><a href="#Unbound基本逻辑" class="headerlink" title="Unbound基本逻辑"></a>Unbound基本逻辑</h2><h3 id="worker的创建"><a href="#worker的创建" class="headerlink" title="worker的创建"></a>worker的创建</h3><p>unbound在初始化时先创建一个daemon结构，该结构用于管理所有的worker线程。daemon先创建所有线程的线程结构，然后启动所有线程。</p><h3 id="分配port策略"><a href="#分配port策略" class="headerlink" title="分配port策略"></a>分配port策略</h3><p>在初始化线程结构的时候，unbound首先会声明一个用于存放端口号1~65535的数组。利用daemon结构中的随机生成器对端口进行随机排序，将排序后的端口分配给各个线程。</p><h3 id="rand随机数"><a href="#rand随机数" class="headerlink" title="rand随机数"></a>rand随机数</h3><p>使用yarrow算法生成随机生成器。</p><h3 id="端口随机"><a href="#端口随机" class="headerlink" title="端口随机"></a>端口随机</h3><p>利用yarrow生成的随机生成器将1～65535个端口全部随机排序，之后依据每个线程使用的端口数量n，依次将n个端口分配给每个线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">shufport = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">65536</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;daemon-&gt;num; i++) &#123;<br>  <span class="hljs-keyword">if</span>(!(daemon-&gt;workers[i] = worker_create(daemon, i,<br>  shufport+numport*i/daemon-&gt;num, <br>  numport*(i+<span class="hljs-number">1</span>)/daemon-&gt;num - numport*i/daemon-&gt;num)))<br>  <span class="hljs-comment">/* the above is not ports/numthr, due to rounding */</span><br>  fatal_exit(<span class="hljs-string">&quot;could not create worker&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用port策略"><a href="#使用port策略" class="headerlink" title="使用port策略"></a>使用port策略</h3><p>unbound向上发送请求的接口结构体为<code>port_if</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Outgoing interface. Ports available and currently used are tracked</span><br><span class="hljs-comment"> * per interface</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">port_if</span> &#123;</span><br>	<span class="hljs-comment">/** address ready to allocate new socket (except port no). */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">addr</span>;</span><br>	<span class="hljs-comment">/** length of addr field */</span><br>	<span class="hljs-keyword">socklen_t</span> addrlen;<br>	<span class="hljs-comment">/** prefix length of network address (in bits), for randomisation.</span><br><span class="hljs-comment">	 * if 0, no randomisation. */</span><br>	<span class="hljs-keyword">int</span> pfxlen;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DISABLE_EXPLICIT_PORT_RANDOMISATION</span><br>	<span class="hljs-comment">/** the available ports array. These are unused.</span><br><span class="hljs-comment">	 * Only the first total-inuse part is filled. */</span><br>	<span class="hljs-keyword">int</span>* avail_ports;<br>	<span class="hljs-comment">/** the total number of available ports (size of the array) */</span><br>	<span class="hljs-keyword">int</span> avail_total;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>	<span class="hljs-comment">/** array of the commpoints currently in use. </span><br><span class="hljs-comment">	 * allocated for max number of fds, first part in use. */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">port_comm</span>** <span class="hljs-title">out</span>;</span><br>	<span class="hljs-comment">/** max number of fds, size of out array */</span><br>	<span class="hljs-keyword">int</span> maxout;<br>	<span class="hljs-comment">/** number of commpoints (and thus also ports) in use */</span><br>	<span class="hljs-keyword">int</span> inuse;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>select_ifport()</code>函数实现了unbound随机选取源端口的功能。</p><h3 id="id的分配策略"><a href="#id的分配策略" class="headerlink" title="id的分配策略"></a>id的分配策略</h3><p>对于每条pending的请求，unbound都会为其随机一个transaction id。将pending的请求节点加入存储pending请求的红黑树中，如果出现节点重复的情况，则会重新随机一个transaction id。如果重新随机1000次，节点仍然与红黑树中的其他某个节点相同，unbound就会drop这个请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** Select random ID */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">select_id</span><span class="hljs-params">(struct outside_network* outnet, struct pending* pend,</span></span><br><span class="hljs-params"><span class="hljs-function">	sldns_buffer* packet)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> id_tries = <span class="hljs-number">0</span>;<br>	pend-&gt;id = ((<span class="hljs-keyword">unsigned</span>)ub_random(outnet-&gt;rnd)&gt;&gt;<span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xffff</span>;<br>	LDNS_ID_SET(sldns_buffer_begin(packet), pend-&gt;id);<br>	<span class="hljs-comment">/* insert in tree */</span><br>	pend-&gt;node.key = pend;<br>	<span class="hljs-keyword">while</span>(!rbtree_insert(outnet-&gt;pending, &amp;pend-&gt;node)) &#123;<br>		<span class="hljs-comment">/* change ID to avoid collision */</span><br>		pend-&gt;id = ((<span class="hljs-keyword">unsigned</span>)ub_random(outnet-&gt;rnd)&gt;&gt;<span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xffff</span>;<br>		LDNS_ID_SET(sldns_buffer_begin(packet), pend-&gt;id);<br>		id_tries++;<br>		<span class="hljs-keyword">if</span>(id_tries == MAX_ID_RETRY) &#123;<br>			pend-&gt;id=<span class="hljs-number">99999</span>; <span class="hljs-comment">/* non existant ID */</span><br>			log_err(<span class="hljs-string">&quot;failed to generate unique ID, drop msg&quot;</span>);<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br>	verbose(VERB_ALGO, <span class="hljs-string">&quot;inserted new pending reply id=%4.4x&quot;</span>, pend-&gt;id);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而根据pending结构体中的提示，红黑树的key是<id ,addr>：</id></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A query that has an answer pending for it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pending</span> &#123;</span><br>	<span class="hljs-comment">/** redblacktree entry, key is the pending struct(id, addr). */</span><br>	rbnode_type node;<br>	<span class="hljs-comment">/** the ID for the query. int so that a value out of range can</span><br><span class="hljs-comment">	 * be used to signify a pending that is for certain not present in</span><br><span class="hljs-comment">	 * the rbtree. (and for which deletion is safe). */</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> id;<br>	<span class="hljs-comment">/** remote address. */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">addr</span>;</span><br>  .<br>  .<br>  .<br>&#125;<br></code></pre></td></tr></table></figure><p>addr的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span>	<span class="hljs-title">ss_sa</span>;</span><br>	<span class="hljs-keyword">char</span>		__ss_pad2[_SS_PADSIZE];<br>&#125;;<br></code></pre></td></tr></table></figure><p>本质上该红黑树的key可以抽象成<id ,dst_ip,port>。</id></p><h3 id="请求如何被worker获取"><a href="#请求如何被worker获取" class="headerlink" title="请求如何被worker获取"></a>请求如何被worker获取</h3><p>unbound在创建每个worker的结构之后，会先初始化其他线程，最后初始化主线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Now create the threads and init the workers.</span><br><span class="hljs-comment">*  By the way, this is thread #0 (the main thread).</span><br><span class="hljs-comment">*/</span><br>daemon_start_others(daemon);<br><span class="hljs-comment">/* Special handling for the main thread. This is the thread</span><br><span class="hljs-comment">*  that handles signals and remote control.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !(defined(HAVE_EV_LOOP) || defined(HAVE_EV_DEFAULT_LOOP))</span><br>	<span class="hljs-comment">/* libevent has the last inited base get signals (or any base) */</span><br>	<span class="hljs-keyword">if</span>(!worker_init(daemon-&gt;workers[<span class="hljs-number">0</span>], daemon-&gt;cfg, daemon-&gt;ports[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>))<br>		fatal_exit(<span class="hljs-string">&quot;Could not initialize main thread&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>signal_handling_playback(daemon-&gt;workers[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p>每个线程初始化时，都会初始化本线程的监听client请求的接口和向上发送query的接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">worker-&gt;front = listen_create(worker-&gt;base, ports,<br>		cfg-&gt;msg_buffer_size, (<span class="hljs-keyword">int</span>)cfg-&gt;incoming_num_tcp,<br>		cfg-&gt;do_tcp_keepalive<br>			? cfg-&gt;tcp_keepalive_timeout<br>			: cfg-&gt;tcp_idle_timeout,<br>		cfg-&gt;harden_large_queries, cfg-&gt;http_max_streams,<br>		cfg-&gt;http_endpoint, cfg-&gt;http_notls_downstream,<br>		worker-&gt;daemon-&gt;tcl, worker-&gt;daemon-&gt;listen_sslctx,<br>		dtenv, worker_handle_request, worker);<br>worker-&gt;back = outside_network_create(worker-&gt;base,<br>		cfg-&gt;msg_buffer_size, (<span class="hljs-keyword">size_t</span>)cfg-&gt;outgoing_num_ports, <br>		cfg-&gt;out_ifs, cfg-&gt;num_out_ifs, cfg-&gt;do_ip4, cfg-&gt;do_ip6, <br>		cfg-&gt;do_tcp?cfg-&gt;outgoing_num_tcp:<span class="hljs-number">0</span>, cfg-&gt;ip_dscp,<br>		worker-&gt;daemon-&gt;env-&gt;infra_cache, worker-&gt;rndstate,<br>		cfg-&gt;use_caps_bits_for_id, worker-&gt;ports, worker-&gt;numports,<br>		cfg-&gt;unwanted_threshold, cfg-&gt;outgoing_tcp_mss,<br>		&amp;worker_alloc_cleanup, worker,<br>		cfg-&gt;do_udp || cfg-&gt;udp_upstream_without_downstream,<br>		worker-&gt;daemon-&gt;connect_sslctx, cfg-&gt;delay_close,<br>		cfg-&gt;tls_use_sni, dtenv, cfg-&gt;udp_connect);<br></code></pre></td></tr></table></figure><p>front的数据结构为<code>listen_port</code>，每个线程拥有一个udp buffer缓冲区以及一个listen_list事件队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Listening for queries structure.</span><br><span class="hljs-comment"> * Contains list of query-listen sockets.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listen_dnsport</span> &#123;</span><br>	<span class="hljs-comment">/** Base for select calls */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">comm_base</span>* <span class="hljs-title">base</span>;</span><br>	<span class="hljs-comment">/** buffer shared by UDP connections, since there is only one</span><br><span class="hljs-comment">	    datagram at any time. */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sldns_buffer</span>* <span class="hljs-title">udp_buff</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> USE_DNSCRYPT</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sldns_buffer</span>* <span class="hljs-title">dnscrypt_udp_buff</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>	<span class="hljs-comment">/** list of comm points used to get incoming events */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listen_list</span>* <span class="hljs-title">cps</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在<code>listen_create()</code>函数中创建接受udp请求的event节点并将其加入到list中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(ports-&gt;ftype == listen_type_udp || ports-&gt;ftype == listen_type_udp_dnscrypt)<br>	cp = comm_point_create_udp(base, ports-&gt;fd, front-&gt;udp_buff, cb, cb_arg);<br><span class="hljs-keyword">if</span>(!listen_cp_insert(cp, front)) &#123;<br>  log_err(<span class="hljs-string">&quot;malloc failed&quot;</span>);<br>  comm_point_delete(cp);<br>  listen_delete(front);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的callback是<code>worker_handle_request(worker)</code>，用来获取client的请求。由此可见unbound与bind9不同，unbound并没有一个全局的队列用于存储client发送的请求。unbound的每个worker线程都有自己的event list和udp buffer，所有worker以抢占式的方式来获取client的请求，然后再向上请求并接受NS返回的response。</p><h3 id="ip、port、id三者的映射关系"><a href="#ip、port、id三者的映射关系" class="headerlink" title="ip、port、id三者的映射关系"></a>ip、port、id三者的映射关系</h3><p>unbound实现了向NS发送请求和接收NS响应的接口：<code>outside_network</code>。unbound在<code>outside_network_create()</code>函数中unbound为每个port创建一个<code>port_comm</code>结构。<code>port_comm</code>用于管理从该端口向上发送的请求以及接收到的NS的响应。</p><p>比较重要的几个结构体：</p><ul><li><code>outside_network</code>：将请求发送到上游NS、从上游接受请求</li><li><code>port_comm</code>：负责该端口对外的socket通信</li><li><code>comm_point</code>：保存了unbound对外通信的一些基础信息</li><li><code>comm_reply</code>：<code>comm_point</code>向外通信后收到的回复消息</li></ul><p>unbound在接收NS发回的response时调用的callback为<code>outnet_udp_cb()</code>。该函数获取response的addr以及transaction id，组合成key进入红黑树查询。如果查询没有命中，则将response丢弃掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> </span><br><span class="hljs-function"><span class="hljs-title">pending_cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* key1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* key2)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pending</span> *<span class="hljs-title">p1</span> =</span> (struct pending*)key1;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pending</span> *<span class="hljs-title">p2</span> =</span> (struct pending*)key2;<br>	<span class="hljs-keyword">if</span>(p1-&gt;id &lt; p2-&gt;id)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">if</span>(p1-&gt;id &gt; p2-&gt;id)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	log_assert(p1-&gt;id == p2-&gt;id);<br>	<span class="hljs-keyword">return</span> sockaddr_cmp(&amp;p1-&gt;addr, p1-&gt;addrlen, &amp;p2-&gt;addr, p2-&gt;addrlen);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sockaddr_cmp</span><span class="hljs-params">(struct sockaddr_storage* addr1, <span class="hljs-keyword">socklen_t</span> len1, </span></span><br><span class="hljs-params"><span class="hljs-function">	struct sockaddr_storage* addr2, <span class="hljs-keyword">socklen_t</span> len2)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span>* <span class="hljs-title">p1_in</span> =</span> (struct sockaddr_in*)addr1;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span>* <span class="hljs-title">p2_in</span> =</span> (struct sockaddr_in*)addr2;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span>* <span class="hljs-title">p1_in6</span> =</span> (struct sockaddr_in6*)addr1;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span>* <span class="hljs-title">p2_in6</span> =</span> (struct sockaddr_in6*)addr2;<br>	<span class="hljs-keyword">if</span>(len1 &lt; len2)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">if</span>(len1 &gt; len2)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	log_assert(len1 == len2);<br>	<span class="hljs-keyword">if</span>( p1_in-&gt;sin_family &lt; p2_in-&gt;sin_family)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">if</span>( p1_in-&gt;sin_family &gt; p2_in-&gt;sin_family)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	log_assert( p1_in-&gt;sin_family == p2_in-&gt;sin_family );<br>	<span class="hljs-comment">/* compare ip4 */</span><br>	<span class="hljs-keyword">if</span>( p1_in-&gt;sin_family == AF_INET ) &#123;<br>		<span class="hljs-comment">/* just order it, ntohs not required */</span><br>		<span class="hljs-keyword">if</span>(p1_in-&gt;sin_port &lt; p2_in-&gt;sin_port)<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>		<span class="hljs-keyword">if</span>(p1_in-&gt;sin_port &gt; p2_in-&gt;sin_port)<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		log_assert(p1_in-&gt;sin_port == p2_in-&gt;sin_port);<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">memcmp</span>(&amp;p1_in-&gt;sin_addr, &amp;p2_in-&gt;sin_addr, INET_SIZE);<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1_in6-&gt;sin6_family == AF_INET6) &#123;<br>		<span class="hljs-comment">/* just order it, ntohs not required */</span><br>		<span class="hljs-keyword">if</span>(p1_in6-&gt;sin6_port &lt; p2_in6-&gt;sin6_port)<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>		<span class="hljs-keyword">if</span>(p1_in6-&gt;sin6_port &gt; p2_in6-&gt;sin6_port)<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		log_assert(p1_in6-&gt;sin6_port == p2_in6-&gt;sin6_port);<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">memcmp</span>(&amp;p1_in6-&gt;sin6_addr, &amp;p2_in6-&gt;sin6_addr, <br>			INET6_SIZE);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">/* eek unknown type, perform this comparison for sanity. */</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">memcmp</span>(addr1, addr2, len1);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="server-failure"><a href="#server-failure" class="headerlink" title="server failure"></a>server failure</h3><p>unbound出于节省资源的目的，当访问一个域名没有响应时，unbound会通过延长time out来对NS进行探测。time out会从一个很小的值慢慢增长(…6，12,24,48,96)。当本轮的time out达到96秒并且client再次请求该zone下的子域名时，unbound会强制离开返回Server failure给client。以上信息会被记录在infra-cache的结构中，ttl为900s。</p><p>默认情况下，infra_cache最多缓存10000条条目。经过测试，实际环境下infra_cache缓存的条目在9300~9700之间，并且新进来的条目会覆盖之前的条目。client请求被覆盖的zone下的子域名时，time out重新计时。</p><p>具体可以参考unbound的<a target="_blank" rel="noopener" href="https://nlnetlabs.nl/documentation/unbound/info-timeout/">document</a></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/DNS/">DNS</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2021/02/02/fuzz/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">fuzz记录</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2021/01/11/joern%E4%BD%BF%E7%94%A8/"><span class="hidden-mobile">joern使用</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/boot.js"></script></body></html>