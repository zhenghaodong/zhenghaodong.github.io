<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Paper reading</title>
    <link href="/2021/07/01/2021-07-01-Paper-reading/"/>
    <url>/2021/07/01/2021-07-01-Paper-reading/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这大半年发生了很多事情，放弃了一些事与人，又得到了新的机会可以和旧事重逢，日子就这样不知不觉、迷迷茫茫地过去了。开个坑为自己每周的学习做一个阶段性地总结，希望每周的总结可以给我带来充实感与好心情。</p><p>错的来来走走，对的终会停留。</p></blockquote><h2 id="2021-06-26～2021-06-30"><a href="#2021-06-26～2021-06-30" class="headerlink" title="2021-06-26～2021-06-30"></a>2021-06-26～2021-06-30</h2><blockquote><p>主要工作：整理AEG相关的论文资料，阅读部分论文</p></blockquote><ul><li>阅读《软件漏洞自动利用研究进展》(软件所苏老师写的aeg相关研究成果的综述)</li><li>阅读<a href="https://www.inforsec.org/wp/wp-content/uploads/2019/01/Session1%E7%8E%8B%E7%90%B0Revery-%E8%BF%88%E5%90%91%E8%87%AA%E5%8A%A8%E5%8C%96%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%80%E5%B0%8F%E6%AD%A5-infosec.pdf">Revery-迈向自动化攻击的一小步</a></li><li>阅读《Automatic Patch-Based Exploit Generation is Possible: Techniques and Implications》<ul><li>Dawn Song等于08年提出的针对补丁的自动化漏洞生成方法，算是aeg的一项前置工作</li><li>里面有很多细节，reference中也有很多值得精读的资料，这个还有待完成</li><li>关于约束求解，之前仅仅是打ctf时接触过，需要详细学习一下(SAT、SMT这些)</li></ul></li><li>《Automatic Generation of Control Flow Hijacking Exploits for Software Vulnerabilities》读了个开头。。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Paper reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>符号执行记录</title>
    <link href="/2021/03/02/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    <url>/2021/03/02/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="符号执行记录"><a href="#符号执行记录" class="headerlink" title="符号执行记录"></a>符号执行记录</h1><blockquote><p>类似于前段时间的<a href="https://zhenghaodong.github.io/2021/02/02/fuzz/">fuzz记录</a>，这篇文章主要是符号执行的学习记录。</p></blockquote><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul><li>综述<ul><li>传统符号执行</li><li>现代符号执行</li></ul></li><li>流行的符号执行引擎</li><li>其他方向<ul><li>分割逻辑</li><li>不变量</li><li>函数摘要</li><li>程序分析和优化</li><li>符号计算</li></ul></li></ul><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><blockquote><p>综述可以参考<a href="https://unpaywall.org/10.1145%2F3182657">A Survey of Symbolic Execution Techniques</a></p></blockquote><h3 id="传统符号执行"><a href="#传统符号执行" class="headerlink" title="传统符号执行"></a>传统符号执行</h3><p>考虑一个基本的例子：给定一段代码，确定哪些输入会使函数的到预期的输出。此时想要通过常规的具体执行的操作来遍历所有可能是不现实的，而且也很难覆盖到所有的情况。符号执行将每一个不能确定的元素视为一个符号å；代码中的分支条件视为π，这些条件就构成了一个约束；而下一条要评估的语句视作stmt，构成符号执行树上的一个节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foobar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>,y = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(a != <span class="hljs-number">0</span>)&#123;<br>y = x + <span class="hljs-number">3</span>;<br><span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br>x = <span class="hljs-number">2</span> * (a + b);<br>&#125;<br>&#125;<br>assert(x=y!=<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的符号执行图如下：</p><p><img src="https://i.loli.net/2021/07/01/bHcmJ1fKO8ZdgF2.png" alt="bHcmJ1fKO8ZdgF2"></p><p>一些术语：</p><ul><li>执行路径：一个true和false的序列seq={p0,p1,…,pn}。其中，如果是一个条件语句，那么pi=ture则表示这条条件语句取true，否则取false；</li><li>执行树：一个程序的所有执行路径则可表征成一棵执行树；</li><li>符号状态：符号执行维护一个符号状态e，它将变量映射到符号表达式；</li><li>符号路径约束：符号路径约束PC，它是符号表达式上无量词的一阶公式。</li></ul><p>传统缺点：</p><ul><li>对外部库调用的彻底探索可能导致状态的指数爆炸，从而妨碍分析到达感兴趣的代码部分;</li><li>对外部第三方组件的调用可能无法由执行器跟踪;</li><li>符号引擎在分析过程中不断调用SMT求解器。在约束求解中花费的时间是引擎的主要性能障碍之一，程序可能会产生约束，即使是强大的求解器也不能很好地处理。</li></ul><h3 id="现代符号执行"><a href="#现代符号执行" class="headerlink" title="现代符号执行"></a>现代符号执行</h3><h4 id="混合执行"><a href="#混合执行" class="headerlink" title="混合执行"></a>混合执行</h4><p>混合执行维护两个状态，一个状态为<code>精确状态</code>，另一个状态为<code>符号状态</code>。</p><p>以之前的代码举例，混合执行将生成一些随机的输入(比如x = 13, y = 9)并具体地执行程序</p>]]></content>
    
    
    <categories>
      
      <category>符号执行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fuzz记录</title>
    <link href="/2021/02/02/fuzz/"/>
    <url>/2021/02/02/fuzz/</url>
    
    <content type="html"><![CDATA[<h2 id="What’s-this"><a href="#What’s-this" class="headerlink" title="What’s this?"></a>What’s this?</h2><p>虽然在大三的时候接触过fuzz，但是从来没有系统地学习、整理过fuzz的相关知识。这篇文章算是记录一下自己学习fuzz的历程吧。</p><p>主要分为以下几个模块：</p><ul><li>fuzz介绍<ul><li>fuzz是什么</li><li>fuzz的一些术语</li><li>分类</li><li>fuzz的流程</li><li>分类详细介绍</li></ul></li><li>流行的fuzzer<ul><li>AFL</li></ul></li><li>前沿研究动态</li><li>一个fuzzer的实现</li></ul><h2 id="fuzz介绍"><a href="#fuzz介绍" class="headerlink" title="fuzz介绍"></a>fuzz介绍</h2><blockquote><p>有两篇不错的fuzz综述：《Fuzzing: a survey》和《Fuzzing: Art, Science, and Engineering》</p></blockquote><h3 id="fuzz是什么"><a href="#fuzz是什么" class="headerlink" title="fuzz是什么"></a>fuzz是什么</h3><p>Fuzz的中文名称为模糊测试，是一种基于黑盒或灰盒的模糊测试技术，通过自动化生成大量的随机测试用例来发现产品或协议的未知漏洞。相比于其他漏洞检测方法，fuzz的准确率更高，且具有更好的扩展性，见<code>《Fuzzing a survey》</code>中的table1:</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/76.png" alt=""></p><h3 id="fuzz的一些术语"><a href="#fuzz的一些术语" class="headerlink" title="fuzz的一些术语"></a>fuzz的一些术语</h3><p><code>Fuzzing: Art, Science, and Engineering》</code>中整理出的的一些术语：</p><ul><li>PUT：测试的程序</li><li>Fuzzing test：测试PUT是否违反了安全策略</li><li>Fuzz Campaign: 在特定安全策略下的一轮fuzz，目的是发现违反安全策略的bug</li><li>Bug Oracle：检测程序执行是否违反安全策略的一种机制</li><li>Fuzz Configuration：Fuzz算法的参数值</li><li>Fuzz algorithm：模糊算法，依赖于输入外的一些参数且有通用模型</li><li>seed：输入，对于不同的测试对象，输入的种类不同。可能是文件、流量包或一系列UI事件或修改生成的测试用例</li><li>seed pool：fuzzer维护的种子集合，不断扩展</li></ul><h3 id="fuzz分类"><a href="#fuzz分类" class="headerlink" title="fuzz分类"></a>fuzz分类</h3><p>fuzzer可以根据生成器策略分为基于生成规则的fuzzer和基于变异的fuzzer。基于生成规则的fuzzer需要目标对象输入的相关知识内容，而基于变异的fuzzer需要一个初始的输入数据集合。二者的对比如<code>《Fuzzing a survey》</code>中的table2所示：</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/77.png" alt=""></p><p>如果从探索策略的角度来看，fuzzer可以分为定向fuzzing和覆盖导向fuzzing。定向fuzzing的目的是生成覆盖目标代码和目标路径的测试用例，而基于覆盖的fuzzing尽可能生成覆盖更多程序代码的测试用例。</p><p>fuzzer还可以分为智能fuzzer和非智能fuzzer。智能fuzzer有类似于神经网络反向传播的机制，基于比那一段fuzzer会结合反馈信息来决定哪部分测试用例需要变异以及如何变异。</p><p><code>Fuzzing: Art, Science, and Engineering》</code>中的Fig 1从fuzz目标对象的角度整理了01年到18年的流行fuzzer：</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/79.png" alt=""></p><p>而Table 1介绍了fuzzer使用的核心技术：</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/80.png" alt=""></p><h3 id="fuzz的流程"><a href="#fuzz的流程" class="headerlink" title="fuzz的流程"></a>fuzz的流程</h3><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>一些fuzzer在第一次执行fuzz前会初始化fuzz configurations。预处理一般分为以下几个步骤：</p><ul><li>插桩</li><li>种子选择</li><li>种子修剪</li><li>准备驱动程序</li></ul><h5 id="插桩"><a href="#插桩" class="headerlink" title="插桩"></a>插桩</h5><p>插桩可以是动态插桩也可以是静态插桩，相比于动态插桩，静态插桩的时间更小。静态插桩通常是在编译过程中在源代码或中间代码上进行插桩。如果PUT依赖于库，那么必须对它们进行单独插桩。动态插桩虽然开销大于静态插桩，但是动态插桩的优势是可以插桩动态链接库。</p><h5 id="种子选择"><a href="#种子选择" class="headerlink" title="种子选择"></a>种子选择</h5><p>好的种子选择策略可以改进fuzzing的效率和效果。根据研究显示，种子的代码覆盖率增加1%就会使发现bug的百分比增加0.92%。fuzzer通常遵循以下原则来选取种子：</p><ul><li>覆盖更多代码的种子、有可能触发异常的种子具有更高的优先级</li><li>减少重复路径执行</li><li>最优化选择能够覆盖更深和更有可能出现异常的种子</li></ul><h5 id="种子修剪"><a href="#种子修剪" class="headerlink" title="种子修剪"></a>种子修剪</h5><p>较小的种子意味着内存消耗更小，吞吐量更高。一些fuzzer尝试减小种子的尺寸来提升fuzzer的效率。</p><h5 id="准备驱动程序"><a href="#准备驱动程序" class="headerlink" title="准备驱动程序"></a>准备驱动程序</h5><p>当应用程序难以直接fuzz时，通常会为其准备一个模糊驱动程序。比如当fuzz库时，需要准备一个调用库函数的驱动程序。</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>在fuzz中，调度意味着为下一个模糊运行选择模糊配置，不同的fuzzer拥有不同的调度算法。在黑盒设置中，调度算法可以使用的唯一信息是配置的模糊结果，而灰盒设置中，调度算法可以选择使用关于每种配置的更丰富的信息集。有关调度，之后会结合fuzzer进行分析。</p><h3 id="输入生成"><a href="#输入生成" class="headerlink" title="输入生成"></a>输入生成</h3><p>由于测试用例的内容决定了是否出发漏洞，因此输入生成技术是模糊测试中最有影响力的设计决策之一。正如前面介绍的，fuzzer可以分为基于生成的fuzzer和基于变异的fuzzer。</p><h4 id="基于生成的fuzzer"><a href="#基于生成的fuzzer" class="headerlink" title="基于生成的fuzzer"></a>基于生成的fuzzer</h4><p>基于生成的fuzzer是基于给定模型生成测试用例，该模型描述了测试程序可以接受的输入或执行，比如精确表征输入格式的语法或不太精确的约束。</p><p>Peach、Spike等fuzzer可以使用用户配置的预定义的模型。其他基于生成的fuzzer针对特定的语言或语法，并且该语言的模型内置于fuzzer本身。</p><p>推断模型而不是依赖于预定义的逻辑或用户提供的模型，但是只有一小部分fuzzer采用腿短模型这种技术。推断模型可以分为：<code>Preprocess</code>和<code>ConfUpdate</code>。</p><p><code>Preprocess</code>：一些fuzzer将模型推断为模糊测试前的第一步。</p><p><code>ConfUpdate</code>：在每个模糊迭代中，fuzzer都更新模型。</p><h4 id="基于变异的fuzzer"><a href="#基于变异的fuzzer" class="headerlink" title="基于变异的fuzzer"></a>基于变异的fuzzer</h4><p>比特翻转是许多基于变异的fuzzer常使用的技术。除了比特翻转之外，诸如AFL和Hongfuzz等fuzzer，它们将所选字节序列视作整数并对该值进行简单算术。此举称为算数变异。例如AFL，AFL从种子中选择一个4字节的值，将该值视作整数i。然后用i+r或i-r替换种子中的值(r是随机生成的小整数)。</p><p>除此之外，一些fuzzer还使用基于块的变异以及基于字典的变异两种方法。在基于块的变异中，块石种子的字节序列。fuzzer首先将随机生成的块插入种子的随机位置，接着从种子中删除随机选择的块，随后fuzzer用随机值替换随机选择的块冰随机置换一系列块的顺序。最后fuzzer通过附加随机区来调整种子的大小并从种子中取一个随机块来插入/替换另一个种子的随机块。</p><h4 id="白盒fuzzer"><a href="#白盒fuzzer" class="headerlink" title="白盒fuzzer"></a>白盒fuzzer</h4><p>白盒fuzzer也可以分为基于生成的fuzzer和基于变异的fuzzer。传统的符号执行在基于变异的fuzzer中不需要任何模型，但一些符号执行器需要利用输入模型，如输入语法指导符号执行。</p><p>一些fuzzer利用静态/动态程序分析技术来增强fuzz的有效性，比如获取有关测试程序的有用信息的高代价程序分析以及在先前分析指导下生成测试用例。</p><h3 id="输入评估"><a href="#输入评估" class="headerlink" title="输入评估"></a>输入评估</h3><p>输入评估可以分为执行优化和分类两大部分。</p><p>生成输入数据后，fuzzer执行输入并对输入进行处理。而每个fuzzer都需要处理的一个问题就是fuzz的效率。例如AFL提供了fork-server功能，它允许每个新的模糊迭代从已经初始化的进程中fork。</p><p>分类是分析和报告导致违反策略的测试用例的过程。分类可以分为三个步骤：重复数据删除，优先级排序和测试用例最小化。重复数据删除是从输出集中修剪与其它测试样例触发相同的错误的测试样例的过程，理想情况下，重复数据删除会返回一组测试用例，其中每个测试用例都会触发一个独特的错误。目前在实践中使用了两种主要的重复数据删除实现：<code>堆栈回溯哈希</code>和<code>基于覆盖的重复数据删除</code>。优先级是根据严重性和唯一性对违反测试用例进行排名或分组的过程。传统上使用模糊测试来发现内存漏洞，在这种情况下，优先级更好地称为确定崩溃的可利用性。而分类的另一个重要部分是测试用例最小化。测试用例最小化是识别触发违规所必需的违规测试用例部分的过程，并且可选地产生比原始测试用例更小且更简单但仍然导致违规的测试用例。</p><h3 id="配置更新"><a href="#配置更新" class="headerlink" title="配置更新"></a>配置更新</h3><h4 id="进化种子库更新"><a href="#进化种子库更新" class="headerlink" title="进化种子库更新"></a>进化种子库更新</h4><p>进化算法是一种启发式的算法，其最重要的一步就是维持一个种子库，将新配置添加到配置集中。大多数fuzzer通常使用节点或分支覆盖作为适应度函数：如果测试用例发现新节点或分支，则将其添加到种子池中。 AFL 进一步考虑了分支机构被采取的次数。Angora通过考虑每个分支的调用上下文来改进AFL的适应性标准。 Steelix 检查哪个输入偏移影响测试程序的比较指令的过程以及进化种子池的代码覆盖率。</p><h4 id="维护Minset"><a href="#维护Minset" class="headerlink" title="维护Minset"></a>维护Minset</h4><p>由于能够创建新的模糊测试配置，因此还存在创建过多配置的风险。用于降低此风险的常见策略是维护最小化或最小化测试用例集，以最大化覆盖度量。一些fuzzer使用维护专用于配置更新的minset的变体。AFL使用剔除程序将minset配置标记为有利，而不是完全删除不在minset中的配置。通过调度函数，有利的模糊测试配置被选择用于模糊测试的可能性显著提高。</p><h3 id="fuzz中的关键问题"><a href="#fuzz中的关键问题" class="headerlink" title="fuzz中的关键问题"></a>fuzz中的关键问题</h3><ul><li>如何变异种子输入</li><li>如何提高代码覆盖率</li><li>输入的测试数据如何通过测试程序的验证</li></ul><h3 id="定向fuzz与覆盖导向fuzz"><a href="#定向fuzz与覆盖导向fuzz" class="headerlink" title="定向fuzz与覆盖导向fuzz"></a>定向fuzz与覆盖导向fuzz</h3><p>接着上文分类来看，按照探索策略，fuzz可以分为定向fuzz(directed fuzz)和覆盖导向fuzz(coverage-based fuzz)。大多数的灰盒模糊测试都是基于覆盖导向的，这种设计的目的是在有限的时间预算内覆盖尽可能多的程序路径。但是将不同的代码视为相同的是不合适的，有些代码的bug可能性会更大，通过盲目地扩展代码覆盖范围来测试软件效率较低，因此才会有定向模糊测试。定向模糊测试会将大部分时间花在<strong>特定目标位置</strong>（容易出bug的地方）。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>种子选择策略不同：覆盖导向fuzz的目的是最大化路径覆盖，因此它会优先选择触发新路径的种子。定向fuzz的目的是到达代码中的特定位置，因此它会优先选择更接近目标的种子。选择策略不同导致定向fuzz评估种子的指标产生很大变化，包括距离、覆盖、路径和概率。</li><li>目标设置不同：定向fuzz会对程序进行目标设置，从而使整个fuzz流程更具备方向性。</li><li>fuzz阶段不同：定向fuzz有两个阶段，第一个阶段的目的是使得fuzzing可以获得更多的信息，可能有更多的突变的种子；第二个阶段的目的只是让种子接近目标。</li></ul><h4 id="定向fuzz-DGF"><a href="#定向fuzz-DGF" class="headerlink" title="定向fuzz(DGF)"></a>定向fuzz(DGF)</h4><blockquote><p>有篇关于定向灰盒fuzz的综述文章：《SoK: The Progress, Challenges, and Perspectives of Directed Greybox Fuzzing》。</p></blockquote><p>这篇文章调研了18-20年间的28个定向型fuzzer，并根据相应的指标对这些工作使用核心技术的进行分析。</p><p>总体来说，定向型fuzzer主要有以下核心技术：</p><ul><li>目标标记</li><li>输入优化</li><li>种子选择策略</li><li>能量调度</li><li>突变策略优化</li><li>数据流分析</li></ul><h5 id="目标标记"><a href="#目标标记" class="headerlink" title="目标标记"></a>目标标记</h5><p>起初的目标标记是基于手动标记来实现的，之后出现了使用目标序列来引导的fuzzer。</p><h5 id="输入优化"><a href="#输入优化" class="headerlink" title="输入优化"></a>输入优化</h5><p>标记完目标后，定向fuzzer需要生成种子输入来调用模糊过程，而良好的种子输入可以使模糊过程更接近目标位置，提高后期突变过程的性能。</p><h5 id="种子选择策略"><a href="#种子选择策略" class="headerlink" title="种子选择策略"></a>种子选择策略</h5><p>DGF的关键是优先选取某些指标下表现更好的种子，而常见的指标如下：距离、相似度、概率。</p><ul><li>距离：基于距离指标，优先选择距离近的种子。AFLGO是第一个距离指标的，在编译过程中AFLGO会记录源码并通过输入的测试程序的调用图以及控制流图的边数来计算到目标基本块的距离。基于距离的方法的缺点在于它只关注最短的距离，当有多个路径到达相同目标时，较长的选项可能被忽略，导致误差。</li><li>相似度：相似度表示某些目标的相似度(如目标序列)。Hawkeye利用静态分析技术，结合基本块跟踪距离和覆盖函数相似度进行种子排序和功率调度。UAFL使用操作序列覆盖作为反馈来指导测试用例生成。</li><li>概率：根据种子达到目标的可能性来确定种子的优先级。V-FUZZ和SUZZER基于深度学习模型来预测脆弱概率，并给脆弱函数中的每个基本块一个评分，对于每个输入，计算所有分数的总和，依据总和来决定优先级。</li></ul><h5 id="能量调度"><a href="#能量调度" class="headerlink" title="能量调度"></a>能量调度</h5><p>大多数定向fuzzer在能量调度阶段都适用模拟退火算法。AFLGO使用该算法将能量调度给距离更近的种子并减少传递到距离远的种子的能量。</p><h5 id="突变策略优化"><a href="#突变策略优化" class="headerlink" title="突变策略优化"></a>突变策略优化</h5><p>一些fuzzer通过对突变策略进行优化从而辅助定向fuzzing。Hawkeye通过自适应突变策略进行分类。粗粒度的突变器用于在突变期间更改大量字节，细粒度突变器只会修改几个字节。当种子可以到达目标函数时，Hawkeye只提供较少的发送粗粒度突变的机会，当种子到达目标，进行细粒度突变的时间就会增加。其他fuzzer也有类似的策略：V-FUZZ将突变策略分为轻微突变和严重突变，并通过阈值来动态调整突变策略。</p><h5 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h5><p>通过数据流分析(如污点分析)可以反应突变对生成的输入的影响，从而优化突变策略和输入生成。UAFL采用信息流分析来是吧条件语句中的输入与程序变量之间的关系，并对这些信息流强度高的输入字节赋予更高的突变可能性。然而数据流分析通常会增加运行时开销。</p><h2 id="流行的fuzzer"><a href="#流行的fuzzer" class="headerlink" title="流行的fuzzer"></a>流行的fuzzer</h2><h3 id="AFL"><a href="#AFL" class="headerlink" title="AFL"></a>AFL</h3><blockquote><p>官方编写了<a href="https://lcamtuf.coredump.cx/afl/technical_details.txt">《AFL白皮书》</a>对AFL的策略进行了整体上的介绍。</p></blockquote><h4 id="AFL简介"><a href="#AFL简介" class="headerlink" title="AFL简介"></a>AFL简介</h4><h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><p>首先，AFL是一个基于覆盖引导的fuzzer，它的工作流程如下：</p><ul><li>编译时插桩，记录代码覆盖率</li><li>选择一些输入文件作为初始的PUT加入输入队列</li><li>依据策略对输入数据进行突变</li><li>如果经过变异的输入更新了覆盖范围，则将其保留在队列中</li><li>重复以上过程，记录触发crash的输入</li></ul><h5 id="fuzz准备工作"><a href="#fuzz准备工作" class="headerlink" title="fuzz准备工作"></a>fuzz准备工作</h5><h6 id="被测试程序构建"><a href="#被测试程序构建" class="headerlink" title="被测试程序构建"></a>被测试程序构建</h6><p>使用AFL，首先要使用afl-gcc/afl-clang等工具来编译目标，afl会在编译的时候以每个基本块为单位,进行代码插桩。</p><h6 id="语料库构建"><a href="#语料库构建" class="headerlink" title="语料库构建"></a>语料库构建</h6><p>高质量的语料库可以提高fuzzing效率，而构建语料库时一般都会涉及到三个问题：</p><ul><li>如何选择输入文件</li><li>从哪里寻找输入文件</li><li>如何精简找到的文件</li></ul><p>构建方法：对于输入文件的选择，可以从项目提供的测试用例或者一些开源的语料库中选取，尽量选择小体积的输入文件。</p><p>一些开源的语料库：</p><p><a href="https://gitlab.anu.edu.au/lunar/moonshine">moonshine</a></p><p><a href="https://github.com/MozillaSecurity/fuzzdata">fuzzdata</a></p><p><a href="https://samples.libav.org/">libav samples</a></p><p><a href="http://lcamtuf.coredump.cx/afl/demo/">afl generated image test sets</a></p><p>不过开源语料库包含大量的文件，使用时需要对其进行修剪，做语料库蒸馏。AFL提供了两个工具来帮助我们完成这部工作——<code>afl-cmin</code>和<code>afl-tmin</code>。这两个工具的逻辑是有去区别的，<code>afl-cmin</code>的工作逻辑是寻找与语料库全集具有相同覆盖范围的最小子集，而<code>afl-tmin</code>的工作逻辑是缩减输入文件的体积。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h4 id="使用AFL-进行fuzz"><a href="#使用AFL-进行fuzz" class="headerlink" title="使用AFL 进行fuzz"></a>使用AFL 进行fuzz</h4>]]></content>
    
    
    <categories>
      
      <category>fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于DNS软件栈的一些思考</title>
    <link href="/2021/01/19/dns%E8%BD%AF%E4%BB%B6%E6%A0%88/"/>
    <url>/2021/01/19/dns%E8%BD%AF%E4%BB%B6%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>阅读了流行的dns软件栈的源码，从安全角度理解这些软件栈的设计思路并尝试在其中挖掘一些逻辑上的漏洞。</p><p>长期更新～</p></blockquote><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><h2 id="bind9逻辑"><a href="#bind9逻辑" class="headerlink" title="bind9逻辑"></a>bind9逻辑</h2><h3 id="工作模式总览"><a href="#工作模式总览" class="headerlink" title="工作模式总览"></a>工作模式总览</h3><p>在bind9初始化时，创建cpu个数个线程与管理这些线程的manager。每个线程运行时调用run函数对manager中的task进行操作。每个线程会从ready_task中选择一个task循环的执行task中的event的回调，在循环task时，如果发现task中的事件为空或者执行的事件的数目超过一定的数值以后，就跳出task的循环；如果一个task中没有事件了那就释放 task的内存，然后会有俩个条件变量的处理，最后如果task还要事件未处理完的话就再次放入到ready_task队列中。</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><blockquote><p>create_managers()</p></blockquote><h4 id="创建任务-manager"><a href="#创建任务-manager" class="headerlink" title="创建任务 manager"></a>创建任务 manager</h4><p>bind9中关于task manager结构的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">isc__taskmgr</span> &#123;</span><br><span class="hljs-comment">/* Not locked. */</span><br><span class="hljs-keyword">isc_taskmgr_t</span> common;<br><span class="hljs-keyword">isc_mem_t</span> *mctx;<br><span class="hljs-keyword">isc_mutex_t</span> lock;<br><span class="hljs-keyword">isc_mutex_t</span> halt_lock;<br><span class="hljs-keyword">isc_condition_t</span> halt_cond;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> workers;<br><span class="hljs-keyword">atomic_uint_fast32_t</span> tasks_running;<br><span class="hljs-keyword">atomic_uint_fast32_t</span> tasks_ready;<br><span class="hljs-keyword">atomic_uint_fast32_t</span> curq;<br><span class="hljs-keyword">atomic_uint_fast32_t</span> tasks_count;<br><span class="hljs-keyword">isc__taskqueue_t</span> *queues;<br><span class="hljs-keyword">isc_nm_t</span> *nm;<br><span class="hljs-comment">/* Locked by task manager lock. */</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> default_quantum;<br>LIST(<span class="hljs-keyword">isc__task_t</span>) tasks;<br><span class="hljs-keyword">atomic_uint_fast32_t</span> mode;<br><span class="hljs-keyword">atomic_bool</span> pause_req;<br><span class="hljs-keyword">atomic_bool</span> exclusive_req;<br><span class="hljs-keyword">atomic_bool</span> exiting;<br><span class="hljs-comment">/* Locked by halt_lock */</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> halted;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Multiple threads can read/write &#x27;excl&#x27; at the same time, so we need</span><br><span class="hljs-comment"> * to protect the access.  We can&#x27;t use &#x27;lock&#x27; since isc_task_detach()</span><br><span class="hljs-comment"> * will try to acquire it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">isc_mutex_t</span> excl_lock;<br><span class="hljs-keyword">isc__task_t</span> *excl;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到每个manager会管理多个任务线程并维护每个任务线程的queue。每个线程都有一个queue，queue上存放对应线程需要处理的task，每个线程的threadid都在queue上注册，而queue本身又是manager结构体中的一个变量，因此每个线程相当于在manager中申请了一个位置。</p><p>有关queue的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">isc__taskqueue</span> &#123;</span><br><span class="hljs-comment">/* Everything locked by lock */</span><br><span class="hljs-keyword">isc_mutex_t</span> lock;<br><span class="hljs-keyword">isc__tasklist_t</span> ready_tasks;<br><span class="hljs-keyword">isc__tasklist_t</span> ready_priority_tasks;<br><span class="hljs-keyword">isc_condition_t</span> work_available;<br><span class="hljs-keyword">isc_thread_t</span> thread;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid;<br><span class="hljs-keyword">isc__taskmgr_t</span> *manager;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有关task的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">isc__task</span> &#123;</span><br><span class="hljs-comment">/* Not locked. */</span><br><span class="hljs-keyword">isc_task_t</span> common;<br><span class="hljs-keyword">isc__taskmgr_t</span> *manager;<br><span class="hljs-keyword">isc_mutex_t</span> lock;<br><span class="hljs-comment">/* Locked by task lock. */</span><br><span class="hljs-keyword">task_state_t</span> state;<br><span class="hljs-keyword">int</span> pause_cnt;<br><span class="hljs-keyword">isc_refcount_t</span> references;<br><span class="hljs-keyword">isc_eventlist_t</span> events;<br><span class="hljs-keyword">isc_eventlist_t</span> on_shutdown;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nevents;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> quantum;<br><span class="hljs-keyword">isc_stdtime_t</span> now;<br><span class="hljs-keyword">isc_time_t</span> tnow;<br><span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];<br><span class="hljs-keyword">void</span> *tag;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid;<br><span class="hljs-keyword">bool</span> bound;<br><span class="hljs-comment">/* Protected by atomics */</span><br><span class="hljs-keyword">atomic_uint_fast32_t</span> flags;<br><span class="hljs-comment">/* Locked by task manager lock. */</span><br>LINK(<span class="hljs-keyword">isc__task_t</span>) link;<br>LINK(<span class="hljs-keyword">isc__task_t</span>) ready_link;<br>LINK(<span class="hljs-keyword">isc__task_t</span>) ready_priority_link;<br>&#125;;<br></code></pre></td></tr></table></figure><p>create_manager()函数通过调用isc_create_taskmgr()函数来创建task manager，函数一开始会出实话manager中的一些信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">manager = isc_mem_get(mctx, <span class="hljs-keyword">sizeof</span>(*manager));<br>*manager = (<span class="hljs-keyword">isc__taskmgr_t</span>)&#123; .common.impmagic = TASK_MANAGER_MAGIC,<br>                            .common.magic = ISCAPI_TASKMGR_MAGIC &#125;;<br>atomic_store(&amp;manager-&gt;mode, isc_taskmgrmode_normal);<br>isc_mutex_init(&amp;manager-&gt;lock);<br>isc_mutex_init(&amp;manager-&gt;excl_lock);<br>isc_mutex_init(&amp;manager-&gt;halt_lock);<br>isc_condition_init(&amp;manager-&gt;halt_cond);<br>manager-&gt;workers = workers;<br><span class="hljs-keyword">if</span> (default_quantum == <span class="hljs-number">0</span>) &#123;<br>  default_quantum = DEFAULT_DEFAULT_QUANTUM;<br>&#125;<br>manager-&gt;default_quantum = default_quantum;<br><span class="hljs-keyword">if</span> (nm != <span class="hljs-literal">NULL</span>) &#123;<br>  isc_nm_attach(nm, &amp;manager-&gt;nm);<br>&#125;<br>INIT_LIST(manager-&gt;tasks);<br>atomic_store(&amp;manager-&gt;tasks_count, <span class="hljs-number">0</span>);<br><span class="hljs-comment">//设置queue大小，大小为工作线程数*taskqueue结构体大小</span><br>manager-&gt;queues = isc_mem_get(mctx, workers * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">isc__taskqueue_t</span>));<br>RUNTIME_CHECK(manager-&gt;queues != <span class="hljs-literal">NULL</span>);<br>atomic_init(&amp;manager-&gt;tasks_running, <span class="hljs-number">0</span>);<br>atomic_init(&amp;manager-&gt;tasks_ready, <span class="hljs-number">0</span>);<br>atomic_init(&amp;manager-&gt;curq, <span class="hljs-number">0</span>);<br>atomic_init(&amp;manager-&gt;exiting, <span class="hljs-literal">false</span>);<br>atomic_store_relaxed(&amp;manager-&gt;exclusive_req, <span class="hljs-literal">false</span>);<br>atomic_store_relaxed(&amp;manager-&gt;pause_req, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>接着开始启动manager管理下的task：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; workers; i++) &#123;<br>INIT_LIST(manager-&gt;queues[i].ready_tasks);<br>INIT_LIST(manager-&gt;queues[i].ready_priority_tasks);<br>isc_mutex_init(&amp;manager-&gt;queues[i].lock);<br>isc_condition_init(&amp;manager-&gt;queues[i].work_available);<br><br>manager-&gt;queues[i].manager = manager;<br>manager-&gt;queues[i].threadid = i;<br>isc_thread_create(run, &amp;manager-&gt;queues[i],<br>  &amp;manager-&gt;queues[i].thread);<br><span class="hljs-keyword">char</span> name[<span class="hljs-number">21</span>];<br><span class="hljs-built_in">snprintf</span>(name, <span class="hljs-keyword">sizeof</span>(name), <span class="hljs-string">&quot;isc-worker%04u&quot;</span>, i);<br>isc_thread_setname(manager-&gt;queues[i].thread, name);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中工作线程的启动函数是run函数，参数为&amp;manager-&gt;queues[i]，有关run函数的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">isc_threadresult_t</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN32</span><br>WINAPI<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* ifdef _WIN32 */</span></span><br>run(<span class="hljs-keyword">void</span> *queuep) &#123;<br><span class="hljs-keyword">isc__taskqueue_t</span> *tq = queuep;<br><span class="hljs-keyword">isc__taskmgr_t</span> *manager = tq-&gt;manager;<br><span class="hljs-keyword">int</span> threadid = tq-&gt;threadid;<br>isc_thread_setaffinity(threadid);<br>XTHREADTRACE(<span class="hljs-string">&quot;starting&quot;</span>);<br>dispatch(manager, threadid);<br>XTHREADTRACE(<span class="hljs-string">&quot;exiting&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> OPENSSL_LEAKS</span><br>ERR_remove_state(<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* ifdef OPENSSL_LEAKS */</span></span><br><span class="hljs-keyword">return</span> ((<span class="hljs-keyword">isc_threadresult_t</span>)<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>run函数根据传入的queue，获取工作线程的线程id，并通过manager调用dispatch()为该线程分配任务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">dispatch</span><span class="hljs-params">(<span class="hljs-keyword">isc__taskmgr_t</span> *manager, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid)</span> </span>&#123;<br><br>......<br><br><span class="hljs-keyword">while</span> (!FINISHED(manager)) &#123;<br><br>......<br><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (!EMPTY(task-&gt;events)) &#123;<br>event = HEAD(task-&gt;events);<br>DEQUEUE(task-&gt;events, event, ev_link);<br>task-&gt;nevents--;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Execute the event action.</span><br><span class="hljs-comment"> */</span><br>XTRACE(<span class="hljs-string">&quot;execute action&quot;</span>);<br>XTRACE(task-&gt;name);<br><span class="hljs-keyword">if</span> (event-&gt;ev_action != <span class="hljs-literal">NULL</span>) &#123;<br>UNLOCK(&amp;task-&gt;lock);<br>(event-&gt;ev_action)(<br>(<span class="hljs-keyword">isc_task_t</span> *)task,<br>event);<br>LOCK(&amp;task-&gt;lock);<br>&#125;<br>XTRACE(<span class="hljs-string">&quot;execution complete&quot;</span>);<br>dispatch_count++;<br>&#125;<br><br><span class="hljs-keyword">if</span> (isc_refcount_current(&amp;task-&gt;references) ==<br>    <span class="hljs-number">0</span> &amp;&amp;<br>    EMPTY(task-&gt;events) &amp;&amp;<br>    !TASK_SHUTTINGDOWN(task))<br>&#123;<br><span class="hljs-keyword">bool</span> was_idle;<br><br>was_idle = task_shutdown(task);<br>INSIST(!was_idle);<br>&#125;<br><br><span class="hljs-keyword">if</span> (EMPTY(task-&gt;events)) &#123;<br>XTRACE(<span class="hljs-string">&quot;empty&quot;</span>);<br><span class="hljs-keyword">if</span> (isc_refcount_current(<br>    &amp;task-&gt;references) == <span class="hljs-number">0</span> &amp;&amp;<br>    TASK_SHUTTINGDOWN(task)) &#123;<br>XTRACE(<span class="hljs-string">&quot;done&quot;</span>);<br>finished = <span class="hljs-literal">true</span>;<br>task-&gt;state = task_state_done;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (task-&gt;state ==<br>    task_state_running) &#123;<br>task-&gt;state =<br>task_state_idle;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (task-&gt;state ==<br>   task_state_pausing) &#123;<br>task-&gt;state =<br>task_state_paused;<br>&#125;<br>&#125;<br>done = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (task-&gt;state == task_state_pausing) &#123;<br><span class="hljs-keyword">isc_event_t</span><br>XTRACE(<span class="hljs-string">&quot;pausing&quot;</span>);<br>task-&gt;state = task_state_paused;<br>done = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dispatch_count &gt;= task-&gt;quantum) &#123;<br>XTRACE(<span class="hljs-string">&quot;quantum&quot;</span>);<br>task-&gt;state = task_state_ready;<br>requeue = <span class="hljs-literal">true</span>;<br>done = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (!done);<br><br>......<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建socket-manager"><a href="#创建socket-manager" class="headerlink" title="创建socket manager"></a>创建socket manager</h4><p>bind9中关于socket manager结构的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">isc__socketmgr</span> &#123;</span><br><span class="hljs-comment">/* Not locked. */</span><br><span class="hljs-keyword">isc_socketmgr_t</span> common;<br><span class="hljs-keyword">isc_mem_t</span> *mctx;<br><span class="hljs-keyword">isc_mutex_t</span> lock;<br><span class="hljs-keyword">isc_stats_t</span> *stats;<br><span class="hljs-keyword">int</span> nthreads;<br><span class="hljs-keyword">isc__socketthread_t</span> *threads;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> maxsocks;<br><span class="hljs-comment">/* Locked by manager lock. */</span><br>ISC_LIST(<span class="hljs-keyword">isc__socket_t</span>) socklist;<br><span class="hljs-keyword">int</span> reserved; <span class="hljs-comment">/* unlocked */</span><br><span class="hljs-keyword">isc_condition_t</span> shutdown_ok;<br><span class="hljs-keyword">size_t</span> maxudp;<br>&#125;;<br></code></pre></td></tr></table></figure><p>bind9只会声明一个socket manager，该manager定义了一些基本限制比如maxsocks、maxudp等，然后这个manager会管理所有的socket thread。</p><p>在create_manager()函数中，调用了<code>isc_socketmgr_create2(named_g_mctx, &amp;named_g_socketmgr,maxsocks, named_g_cpus);</code>，该函数细节如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (maxsocks == <span class="hljs-number">0</span>) &#123;<br>maxsocks = ISC_SOCKET_MAXSOCKETS;<br>&#125;<br><br>manager = isc_mem_get(mctx, <span class="hljs-keyword">sizeof</span>(*manager));<br><br><span class="hljs-comment">/* zero-clear so that necessary cleanup on failure will be easy */</span><br><span class="hljs-built_in">memset</span>(manager, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(*manager));<br>manager-&gt;maxsocks = maxsocks;<br>manager-&gt;reserved = <span class="hljs-number">0</span>;<br>manager-&gt;maxudp = <span class="hljs-number">0</span>;<br>manager-&gt;nthreads = nthreads;<br>manager-&gt;stats = <span class="hljs-literal">NULL</span>;<br><br>manager-&gt;common.magic = ISCAPI_SOCKETMGR_MAGIC;<br>manager-&gt;common.impmagic = SOCKET_MANAGER_MAGIC;<br>manager-&gt;mctx = <span class="hljs-literal">NULL</span>;<br>ISC_LIST_INIT(manager-&gt;socklist);<br>isc_mutex_init(&amp;manager-&gt;lock);<br>isc_condition_init(&amp;manager-&gt;shutdown_ok);<br></code></pre></td></tr></table></figure><p>首先先定义了最大的socket连接数，宏<code>ISC_SOCKET_MAXSOCKETS</code>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ISC_SOCKET_MAXSOCKETS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(USE_KQUEUE) || defined(USE_EPOLL) || defined(USE_DEVPOLL)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> TUNE_LARGE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ISC_SOCKET_MAXSOCKETS 21000</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> <span class="hljs-comment">/* ifdef TUNE_LARGE */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ISC_SOCKET_MAXSOCKETS 4096</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* TUNE_LARGE */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(USE_SELECT)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ISC_SOCKET_MAXSOCKETS FD_SETSIZE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* USE_KQUEUE... */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* ISC_SOCKET_MAXSOCKETS */</span></span><br></code></pre></td></tr></table></figure><p>接着对于每个被manager管理的socket线程，声明这些线程的基本信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">manager-&gt;threads = isc_mem_get(mctx, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">isc__socketthread_t</span>) * manager-&gt;nthreads);<br>isc_mem_attach(mctx, &amp;manager-&gt;mctx);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; manager-&gt;nthreads; i++) &#123;<br>  manager-&gt;threads[i].manager = manager;<br>  manager-&gt;threads[i].threadid = i;<br>  setup_thread(&amp;manager-&gt;threads[i]);<br>  isc_thread_create(netthread, &amp;manager-&gt;threads[i],<br>                    &amp;manager-&gt;threads[i].thread);<br>  <span class="hljs-keyword">char</span> tname[<span class="hljs-number">1024</span>];<br>  <span class="hljs-built_in">sprintf</span>(tname, <span class="hljs-string">&quot;isc-socket-%d&quot;</span>, i);<br>  isc_thread_setname(manager-&gt;threads[i].thread, tname);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><p>main函数中，setup函数会创建线程并对bind9做初始化，在setup函数结束之后会启动服务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Start things running and then wait for a shutdown request</span><br><span class="hljs-comment"> * or reload.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">do</span> &#123;<br>result = isc_app_run();<br><br><span class="hljs-keyword">if</span> (result == ISC_R_RELOAD) &#123;<br>named_server_reloadwanted(named_g_server);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result != ISC_R_SUCCESS) &#123;<br>UNEXPECTED_ERROR(__FILE__, __LINE__,<br> <span class="hljs-string">&quot;isc_app_run(): %s&quot;</span>,<br> isc_result_totext(result));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Force exit.</span><br><span class="hljs-comment"> */</span><br>result = ISC_R_SUCCESS;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (result != ISC_R_SUCCESS);<br></code></pre></td></tr></table></figure><p>在循环中，首先调用isc_app_run()来启动服务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">isc_result_t</span></span><br><span class="hljs-function"><span class="hljs-title">isc_app_run</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">isc_result_t</span> result;<br><br>REQUIRE(atomic_compare_exchange_strong_acq_rel(&amp;is_running,<br>       &amp;(<span class="hljs-keyword">bool</span>)&#123; <span class="hljs-literal">false</span> &#125;, <span class="hljs-literal">true</span>));<br>result = isc_app_ctxrun(&amp;isc_g_appctx);<br>atomic_store_release(&amp;is_running, <span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">return</span> (result);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，idc_g_appctx的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">isc_appctx</span> &#123;</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> magic;<br><span class="hljs-keyword">isc_mem_t</span> *mctx;<br><span class="hljs-keyword">isc_mutex_t</span> lock;<br><span class="hljs-keyword">isc_eventlist_t</span> on_run;<br><span class="hljs-keyword">atomic_bool</span> shutdown_requested;<br><span class="hljs-keyword">atomic_bool</span> running;<br><span class="hljs-keyword">atomic_bool</span> want_shutdown;<br><span class="hljs-keyword">atomic_bool</span> want_reload;<br><span class="hljs-keyword">atomic_bool</span> blocked;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WIN32</span><br>HANDLE hEvents[NUM_EVENTS];<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span>  <span class="hljs-comment">/* WIN32 */</span></span><br><span class="hljs-keyword">isc_mutex_t</span> readylock;<br><span class="hljs-keyword">isc_condition_t</span> ready;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* WIN32 */</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>isc_app_run()实际上是调用idc_app_ctxrun()：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">isc_event_t</span> *event, *next_event;<br><span class="hljs-keyword">isc_task_t</span> *task;<br>REQUIRE(VALID_APPCTX(ctx));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WIN32</span><br>REQUIRE(main_thread == GetCurrentThread());<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* ifdef WIN32 */</span></span><br><span class="hljs-keyword">if</span> (atomic_compare_exchange_strong_acq_rel(&amp;ctx-&gt;running, &amp;(<span class="hljs-keyword">bool</span>)&#123; <span class="hljs-literal">false</span> &#125;, <span class="hljs-literal">true</span>))<br>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Post any on-run events (in FIFO order).</span><br><span class="hljs-comment"> */</span><br>  LOCK(&amp;ctx-&gt;lock);<br>  <span class="hljs-keyword">for</span> (event = ISC_LIST_HEAD(ctx-&gt;on_run); event != <span class="hljs-literal">NULL</span>; event = next_event) &#123;<br>    next_event = ISC_LIST_NEXT(event, ev_link);<br>    ISC_LIST_UNLINK(ctx-&gt;on_run, event, ev_link);<br>    task = event-&gt;ev_sender;<br>    event-&gt;ev_sender = <span class="hljs-literal">NULL</span>;<br>    isc_task_sendanddetach(&amp;task, &amp;event);<br>  &#125;<br>  UNLOCK(&amp;ctx-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于每个event，都会被挂在一个专门用于存储event的链表上并在ctx_run函数中被加载到task上。isc_task_sendanddetach()本质上是调用isc_task_sendtoanddetach()，该函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">isc_task_sendtoanddetach</span><span class="hljs-params">(<span class="hljs-keyword">isc_task_t</span> **taskp, <span class="hljs-keyword">isc_event_t</span> **eventp, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br><span class="hljs-keyword">bool</span> idle1, idle2;<br><span class="hljs-keyword">isc__task_t</span> *task;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Send &#x27;*event&#x27; to &#x27;*taskp&#x27; and then detach &#x27;*taskp&#x27; from its</span><br><span class="hljs-comment"> * task.</span><br><span class="hljs-comment"> */</span><br>REQUIRE(taskp != <span class="hljs-literal">NULL</span>);<br>task = (<span class="hljs-keyword">isc__task_t</span> *)*taskp;<br>REQUIRE(VALID_TASK(task));<br>XTRACE(<span class="hljs-string">&quot;isc_task_sendanddetach&quot;</span>);<br>LOCK(&amp;task-&gt;lock);<br><span class="hljs-keyword">if</span> (task-&gt;bound) &#123;<br>c = task-&gt;threadid;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span>) &#123;<br>c = atomic_fetch_add_explicit(&amp;task-&gt;manager-&gt;curq, <span class="hljs-number">1</span>,<br>      memory_order_relaxed);<br>&#125;<br>c %= task-&gt;manager-&gt;workers;<br>idle1 = task_send(task, eventp, c);<br>idle2 = task_detach(task);<br>UNLOCK(&amp;task-&gt;lock);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If idle1, then idle2 shouldn&#x27;t be true as well since we&#x27;re holding</span><br><span class="hljs-comment"> * the task lock, and thus the task cannot switch from ready back to</span><br><span class="hljs-comment"> * idle.</span><br><span class="hljs-comment"> */</span><br>INSIST(!(idle1 &amp;&amp; idle2));<br><span class="hljs-keyword">if</span> (idle1 || idle2) &#123;<br>task_ready(task);<br>&#125;<br>*taskp = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>主进程创建的task作为第一个参数传入isc_task_sendtoanddetach()中。</p><p>调用task_send()将event挂载到对应的工作线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span></span><br><span class="hljs-function"><span class="hljs-title">task_send</span><span class="hljs-params">(<span class="hljs-keyword">isc__task_t</span> *task, <span class="hljs-keyword">isc_event_t</span> **eventp, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br><span class="hljs-keyword">bool</span> was_idle = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">isc_event_t</span> *event;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Caller must be holding the task lock.</span><br><span class="hljs-comment"> */</span><br>REQUIRE(eventp != <span class="hljs-literal">NULL</span>);<br>event = *eventp;<br>*eventp = <span class="hljs-literal">NULL</span>;<br>REQUIRE(event != <span class="hljs-literal">NULL</span>);<br>REQUIRE(event-&gt;ev_type &gt; <span class="hljs-number">0</span>);<br>REQUIRE(task-&gt;state != task_state_done);<br>REQUIRE(!ISC_LINK_LINKED(event, ev_ratelink));<br><br>XTRACE(<span class="hljs-string">&quot;task_send&quot;</span>);<br><br><span class="hljs-keyword">if</span> (task-&gt;state == task_state_idle) &#123;<br>was_idle = <span class="hljs-literal">true</span>;<br>task-&gt;threadid = c;<br>INSIST(EMPTY(task-&gt;events));<br>task-&gt;state = task_state_ready;<br>&#125;<br>INSIST(task-&gt;state == task_state_ready ||<br>       task-&gt;state == task_state_running ||<br>       task-&gt;state == task_state_paused ||<br>       task-&gt;state == task_state_pausing);<br>ENQUEUE(task-&gt;events, event, ev_link);<br>task-&gt;nevents++;<br><span class="hljs-keyword">return</span> (was_idle);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于当前task，如果处于空闲状态，则设置处理该task的线程id并且将task的状态设置成ready，最后将event放入队列并设置task的nevents数量++。</p><p>调用task_detach()来将task从queue上分离：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span></span><br><span class="hljs-function"><span class="hljs-title">task_detach</span><span class="hljs-params">(<span class="hljs-keyword">isc__task_t</span> *task)</span> </span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Caller must be holding the task lock.</span><br><span class="hljs-comment"> */</span><br>XTRACE(<span class="hljs-string">&quot;detach&quot;</span>);<br><span class="hljs-keyword">if</span> (isc_refcount_decrement(&amp;task-&gt;references) == <span class="hljs-number">1</span> &amp;&amp;<br>    task-&gt;state == task_state_idle)<br>&#123;<br>INSIST(EMPTY(task-&gt;events));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * There are no references to this task, and no</span><br><span class="hljs-comment"> * pending events.  We could try to optimize and</span><br><span class="hljs-comment"> * either initiate shutdown or clean up the task,</span><br><span class="hljs-comment"> * depending on its state, but it&#x27;s easier to just</span><br><span class="hljs-comment"> * make the task ready and allow run() or the event</span><br><span class="hljs-comment"> * loop to deal with shutting down and termination.</span><br><span class="hljs-comment"> */</span><br>task-&gt;state = task_state_ready;<br><span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">return</span> (<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在处理完event挂载之后，isc_app_run()会：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (!atomic_load_acquire(&amp;ctx-&gt;want_shutdown)) <br>&#123;<br><span class="hljs-keyword">if</span> (isc_bind9) &#123;<br><span class="hljs-keyword">sigset_t</span> sset;<br><span class="hljs-keyword">int</span> sig;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * BIND9 internal; single context:</span><br><span class="hljs-comment"> * Wait for SIGHUP, SIGINT, or SIGTERM.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (sigemptyset(&amp;sset) != <span class="hljs-number">0</span> || sigaddset(&amp;sset, SIGHUP) != <span class="hljs-number">0</span> || sigaddset(&amp;sset, SIGINT) != <span class="hljs-number">0</span> || sigaddset(&amp;sset, SIGTERM) != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">char</span> strbuf[ISC_STRERRORSIZE];<br>strerror_r(errno, strbuf, <span class="hljs-keyword">sizeof</span>(strbuf));<br>isc_error_fatal(__FILE__, __LINE__,<br><span class="hljs-string">&quot;isc_app_run() sigsetops: %s&quot;</span>,<br>strbuf);<br>&#125;<br><br><span class="hljs-keyword">if</span> (sigwait(&amp;sset, &amp;sig) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">switch</span> (sig) &#123;<br><span class="hljs-keyword">case</span> SIGINT:<br><span class="hljs-keyword">case</span> SIGTERM:<br>atomic_store_release(<br>&amp;ctx-&gt;want_shutdown, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SIGHUP:<br>atomic_store_release(&amp;ctx-&gt;want_reload, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>INSIST(<span class="hljs-number">0</span>);<br>ISC_UNREACHABLE();<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * External, or BIND9 using multiple contexts:</span><br><span class="hljs-comment"> * wait until woken up.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (atomic_load_acquire(&amp;ctx-&gt;want_shutdown)) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!atomic_load_acquire(&amp;ctx-&gt;want_reload)) &#123;<br>LOCK(&amp;ctx-&gt;readylock);<br>WAIT(&amp;ctx-&gt;ready, &amp;ctx-&gt;readylock);<br>UNLOCK(&amp;ctx-&gt;readylock);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (atomic_compare_exchange_strong_acq_rel(&amp;ctx-&gt;want_reload, &amp;(<span class="hljs-keyword">bool</span>)&#123; <span class="hljs-literal">true</span> &#125;, <span class="hljs-literal">false</span>))<br>&#123;<br><span class="hljs-keyword">return</span> (ISC_R_RELOAD);<br>&#125;<br><br><span class="hljs-keyword">if</span> (atomic_load_acquire(&amp;ctx-&gt;want_shutdown) &amp;&amp; atomic_load_acquire(&amp;ctx-&gt;blocked))<br>&#123;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> (ISC_R_SUCCESS);<br></code></pre></td></tr></table></figure><h2 id="Unbound基本逻辑"><a href="#Unbound基本逻辑" class="headerlink" title="Unbound基本逻辑"></a>Unbound基本逻辑</h2><h3 id="worker的创建"><a href="#worker的创建" class="headerlink" title="worker的创建"></a>worker的创建</h3><p>unbound在初始化时先创建一个daemon结构，该结构用于管理所有的worker线程。daemon先创建所有线程的线程结构，然后启动所有线程。</p><h3 id="分配port策略"><a href="#分配port策略" class="headerlink" title="分配port策略"></a>分配port策略</h3><p>在初始化线程结构的时候，unbound首先会声明一个用于存放端口号1~65535的数组。利用daemon结构中的随机生成器对端口进行随机排序，将排序后的端口分配给各个线程。</p><h3 id="rand随机数"><a href="#rand随机数" class="headerlink" title="rand随机数"></a>rand随机数</h3><p>使用yarrow算法生成随机生成器。</p><h3 id="端口随机"><a href="#端口随机" class="headerlink" title="端口随机"></a>端口随机</h3><p>利用yarrow生成的随机生成器将1～65535个端口全部随机排序，之后依据每个线程使用的端口数量n，依次将n个端口分配给每个线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">shufport = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">65536</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;daemon-&gt;num; i++) &#123;<br>  <span class="hljs-keyword">if</span>(!(daemon-&gt;workers[i] = worker_create(daemon, i,<br>  shufport+numport*i/daemon-&gt;num, <br>  numport*(i+<span class="hljs-number">1</span>)/daemon-&gt;num - numport*i/daemon-&gt;num)))<br>  <span class="hljs-comment">/* the above is not ports/numthr, due to rounding */</span><br>  fatal_exit(<span class="hljs-string">&quot;could not create worker&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用port策略"><a href="#使用port策略" class="headerlink" title="使用port策略"></a>使用port策略</h3><p>unbound向上发送请求的接口结构体为<code>port_if</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Outgoing interface. Ports available and currently used are tracked</span><br><span class="hljs-comment"> * per interface</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">port_if</span> &#123;</span><br><span class="hljs-comment">/** address ready to allocate new socket (except port no). */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">addr</span>;</span><br><span class="hljs-comment">/** length of addr field */</span><br><span class="hljs-keyword">socklen_t</span> addrlen;<br><span class="hljs-comment">/** prefix length of network address (in bits), for randomisation.</span><br><span class="hljs-comment"> * if 0, no randomisation. */</span><br><span class="hljs-keyword">int</span> pfxlen;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DISABLE_EXPLICIT_PORT_RANDOMISATION</span><br><span class="hljs-comment">/** the available ports array. These are unused.</span><br><span class="hljs-comment"> * Only the first total-inuse part is filled. */</span><br><span class="hljs-keyword">int</span>* avail_ports;<br><span class="hljs-comment">/** the total number of available ports (size of the array) */</span><br><span class="hljs-keyword">int</span> avail_total;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-comment">/** array of the commpoints currently in use. </span><br><span class="hljs-comment"> * allocated for max number of fds, first part in use. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">port_comm</span>** <span class="hljs-title">out</span>;</span><br><span class="hljs-comment">/** max number of fds, size of out array */</span><br><span class="hljs-keyword">int</span> maxout;<br><span class="hljs-comment">/** number of commpoints (and thus also ports) in use */</span><br><span class="hljs-keyword">int</span> inuse;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>select_ifport()</code>函数实现了unbound随机选取源端口的功能。</p><h3 id="id的分配策略"><a href="#id的分配策略" class="headerlink" title="id的分配策略"></a>id的分配策略</h3><p>对于每条pending的请求，unbound都会为其随机一个transaction id。将pending的请求节点加入存储pending请求的红黑树中，如果出现节点重复的情况，则会重新随机一个transaction id。如果重新随机1000次，节点仍然与红黑树中的其他某个节点相同，unbound就会drop这个请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** Select random ID */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">select_id</span><span class="hljs-params">(struct outside_network* outnet, struct pending* pend,</span></span><br><span class="hljs-params"><span class="hljs-function">sldns_buffer* packet)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> id_tries = <span class="hljs-number">0</span>;<br>pend-&gt;id = ((<span class="hljs-keyword">unsigned</span>)ub_random(outnet-&gt;rnd)&gt;&gt;<span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xffff</span>;<br>LDNS_ID_SET(sldns_buffer_begin(packet), pend-&gt;id);<br><span class="hljs-comment">/* insert in tree */</span><br>pend-&gt;node.key = pend;<br><span class="hljs-keyword">while</span>(!rbtree_insert(outnet-&gt;pending, &amp;pend-&gt;node)) &#123;<br><span class="hljs-comment">/* change ID to avoid collision */</span><br>pend-&gt;id = ((<span class="hljs-keyword">unsigned</span>)ub_random(outnet-&gt;rnd)&gt;&gt;<span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xffff</span>;<br>LDNS_ID_SET(sldns_buffer_begin(packet), pend-&gt;id);<br>id_tries++;<br><span class="hljs-keyword">if</span>(id_tries == MAX_ID_RETRY) &#123;<br>pend-&gt;id=<span class="hljs-number">99999</span>; <span class="hljs-comment">/* non existant ID */</span><br>log_err(<span class="hljs-string">&quot;failed to generate unique ID, drop msg&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>verbose(VERB_ALGO, <span class="hljs-string">&quot;inserted new pending reply id=%4.4x&quot;</span>, pend-&gt;id);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而根据pending结构体中的提示，红黑树的key是<id,addr>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A query that has an answer pending for it.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pending</span> &#123;</span><br><span class="hljs-comment">/** redblacktree entry, key is the pending struct(id, addr). */</span><br>rbnode_type node;<br><span class="hljs-comment">/** the ID for the query. int so that a value out of range can</span><br><span class="hljs-comment"> * be used to signify a pending that is for certain not present in</span><br><span class="hljs-comment"> * the rbtree. (and for which deletion is safe). */</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> id;<br><span class="hljs-comment">/** remote address. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">addr</span>;</span><br>  .<br>  .<br>  .<br>&#125;<br></code></pre></td></tr></table></figure><p>addr的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span><span class="hljs-title">ss_sa</span>;</span><br><span class="hljs-keyword">char</span>__ss_pad2[_SS_PADSIZE];<br>&#125;;<br></code></pre></td></tr></table></figure><p>本质上该红黑树的key可以抽象成<id,dst_ip,port>。</p><h3 id="请求如何被worker获取"><a href="#请求如何被worker获取" class="headerlink" title="请求如何被worker获取"></a>请求如何被worker获取</h3><p>unbound在创建每个worker的结构之后，会先初始化其他线程，最后初始化主线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Now create the threads and init the workers.</span><br><span class="hljs-comment">*  By the way, this is thread #0 (the main thread).</span><br><span class="hljs-comment">*/</span><br>daemon_start_others(daemon);<br><span class="hljs-comment">/* Special handling for the main thread. This is the thread</span><br><span class="hljs-comment">*  that handles signals and remote control.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !(defined(HAVE_EV_LOOP) || defined(HAVE_EV_DEFAULT_LOOP))</span><br><span class="hljs-comment">/* libevent has the last inited base get signals (or any base) */</span><br><span class="hljs-keyword">if</span>(!worker_init(daemon-&gt;workers[<span class="hljs-number">0</span>], daemon-&gt;cfg, daemon-&gt;ports[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>))<br>fatal_exit(<span class="hljs-string">&quot;Could not initialize main thread&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>signal_handling_playback(daemon-&gt;workers[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p>每个线程初始化时，都会初始化本线程的监听client请求的接口和向上发送query的接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">worker-&gt;front = listen_create(worker-&gt;base, ports,<br>cfg-&gt;msg_buffer_size, (<span class="hljs-keyword">int</span>)cfg-&gt;incoming_num_tcp,<br>cfg-&gt;do_tcp_keepalive<br>? cfg-&gt;tcp_keepalive_timeout<br>: cfg-&gt;tcp_idle_timeout,<br>cfg-&gt;harden_large_queries, cfg-&gt;http_max_streams,<br>cfg-&gt;http_endpoint, cfg-&gt;http_notls_downstream,<br>worker-&gt;daemon-&gt;tcl, worker-&gt;daemon-&gt;listen_sslctx,<br>dtenv, worker_handle_request, worker);<br>worker-&gt;back = outside_network_create(worker-&gt;base,<br>cfg-&gt;msg_buffer_size, (<span class="hljs-keyword">size_t</span>)cfg-&gt;outgoing_num_ports, <br>cfg-&gt;out_ifs, cfg-&gt;num_out_ifs, cfg-&gt;do_ip4, cfg-&gt;do_ip6, <br>cfg-&gt;do_tcp?cfg-&gt;outgoing_num_tcp:<span class="hljs-number">0</span>, cfg-&gt;ip_dscp,<br>worker-&gt;daemon-&gt;env-&gt;infra_cache, worker-&gt;rndstate,<br>cfg-&gt;use_caps_bits_for_id, worker-&gt;ports, worker-&gt;numports,<br>cfg-&gt;unwanted_threshold, cfg-&gt;outgoing_tcp_mss,<br>&amp;worker_alloc_cleanup, worker,<br>cfg-&gt;do_udp || cfg-&gt;udp_upstream_without_downstream,<br>worker-&gt;daemon-&gt;connect_sslctx, cfg-&gt;delay_close,<br>cfg-&gt;tls_use_sni, dtenv, cfg-&gt;udp_connect);<br></code></pre></td></tr></table></figure><p>front的数据结构为<code>listen_port</code>，每个线程拥有一个udp buffer缓冲区以及一个listen_list事件队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Listening for queries structure.</span><br><span class="hljs-comment"> * Contains list of query-listen sockets.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listen_dnsport</span> &#123;</span><br><span class="hljs-comment">/** Base for select calls */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">comm_base</span>* <span class="hljs-title">base</span>;</span><br><span class="hljs-comment">/** buffer shared by UDP connections, since there is only one</span><br><span class="hljs-comment">    datagram at any time. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sldns_buffer</span>* <span class="hljs-title">udp_buff</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> USE_DNSCRYPT</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sldns_buffer</span>* <span class="hljs-title">dnscrypt_udp_buff</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-comment">/** list of comm points used to get incoming events */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listen_list</span>* <span class="hljs-title">cps</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在<code>listen_create()</code>函数中创建接受udp请求的event节点并将其加入到list中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(ports-&gt;ftype == listen_type_udp || ports-&gt;ftype == listen_type_udp_dnscrypt)<br>cp = comm_point_create_udp(base, ports-&gt;fd, front-&gt;udp_buff, cb, cb_arg);<br><span class="hljs-keyword">if</span>(!listen_cp_insert(cp, front)) &#123;<br>  log_err(<span class="hljs-string">&quot;malloc failed&quot;</span>);<br>  comm_point_delete(cp);<br>  listen_delete(front);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的callback是<code>worker_handle_request(worker)</code>，用来获取client的请求。由此可见unbound与bind9不同，unbound并没有一个全局的队列用于存储client发送的请求。unbound的每个worker线程都有自己的event list和udp buffer，所有worker以抢占式的方式来获取client的请求，然后再向上请求并接受NS返回的response。</p><h3 id="ip、port、id三者的映射关系"><a href="#ip、port、id三者的映射关系" class="headerlink" title="ip、port、id三者的映射关系"></a>ip、port、id三者的映射关系</h3><p>unbound实现了向NS发送请求和接收NS响应的接口：<code>outside_network</code>。unbound在<code>outside_network_create()</code>函数中unbound为每个port创建一个<code>port_comm</code>结构。<code>port_comm</code>用于管理从该端口向上发送的请求以及接收到的NS的响应。</p><p>比较重要的几个结构体：</p><ul><li><code>outside_network</code>：将请求发送到上游NS、从上游接受请求</li><li><code>port_comm</code>：负责该端口对外的socket通信</li><li><code>comm_point</code>：保存了unbound对外通信的一些基础信息</li><li><code>comm_reply</code>：<code>comm_point</code>向外通信后收到的回复消息</li></ul><p>unbound在接收NS发回的response时调用的callback为<code>outnet_udp_cb()</code>。该函数获取response的addr以及transaction id，组合成key进入红黑树查询。如果查询没有命中，则将response丢弃掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> </span><br><span class="hljs-function"><span class="hljs-title">pending_cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* key1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* key2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pending</span> *<span class="hljs-title">p1</span> =</span> (struct pending*)key1;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pending</span> *<span class="hljs-title">p2</span> =</span> (struct pending*)key2;<br><span class="hljs-keyword">if</span>(p1-&gt;id &lt; p2-&gt;id)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(p1-&gt;id &gt; p2-&gt;id)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>log_assert(p1-&gt;id == p2-&gt;id);<br><span class="hljs-keyword">return</span> sockaddr_cmp(&amp;p1-&gt;addr, p1-&gt;addrlen, &amp;p2-&gt;addr, p2-&gt;addrlen);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">sockaddr_cmp</span><span class="hljs-params">(struct sockaddr_storage* addr1, <span class="hljs-keyword">socklen_t</span> len1, </span></span><br><span class="hljs-params"><span class="hljs-function">struct sockaddr_storage* addr2, <span class="hljs-keyword">socklen_t</span> len2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span>* <span class="hljs-title">p1_in</span> =</span> (struct sockaddr_in*)addr1;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span>* <span class="hljs-title">p2_in</span> =</span> (struct sockaddr_in*)addr2;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span>* <span class="hljs-title">p1_in6</span> =</span> (struct sockaddr_in6*)addr1;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span>* <span class="hljs-title">p2_in6</span> =</span> (struct sockaddr_in6*)addr2;<br><span class="hljs-keyword">if</span>(len1 &lt; len2)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(len1 &gt; len2)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>log_assert(len1 == len2);<br><span class="hljs-keyword">if</span>( p1_in-&gt;sin_family &lt; p2_in-&gt;sin_family)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>( p1_in-&gt;sin_family &gt; p2_in-&gt;sin_family)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>log_assert( p1_in-&gt;sin_family == p2_in-&gt;sin_family );<br><span class="hljs-comment">/* compare ip4 */</span><br><span class="hljs-keyword">if</span>( p1_in-&gt;sin_family == AF_INET ) &#123;<br><span class="hljs-comment">/* just order it, ntohs not required */</span><br><span class="hljs-keyword">if</span>(p1_in-&gt;sin_port &lt; p2_in-&gt;sin_port)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(p1_in-&gt;sin_port &gt; p2_in-&gt;sin_port)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>log_assert(p1_in-&gt;sin_port == p2_in-&gt;sin_port);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">memcmp</span>(&amp;p1_in-&gt;sin_addr, &amp;p2_in-&gt;sin_addr, INET_SIZE);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1_in6-&gt;sin6_family == AF_INET6) &#123;<br><span class="hljs-comment">/* just order it, ntohs not required */</span><br><span class="hljs-keyword">if</span>(p1_in6-&gt;sin6_port &lt; p2_in6-&gt;sin6_port)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>(p1_in6-&gt;sin6_port &gt; p2_in6-&gt;sin6_port)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>log_assert(p1_in6-&gt;sin6_port == p2_in6-&gt;sin6_port);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">memcmp</span>(&amp;p1_in6-&gt;sin6_addr, &amp;p2_in6-&gt;sin6_addr, <br>INET6_SIZE);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* eek unknown type, perform this comparison for sanity. */</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">memcmp</span>(addr1, addr2, len1);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="server-failure"><a href="#server-failure" class="headerlink" title="server failure"></a>server failure</h3><p>unbound出于节省资源的目的，当访问一个域名没有响应时，unbound会通过延长time out来对NS进行探测。time out会从一个很小的值慢慢增长(…6，12,24,48,96)。当本轮的time out达到96秒并且client再次请求该zone下的子域名时，unbound会强制离开返回Server failure给client。以上信息会被记录在infra-cache的结构中，ttl为900s。</p><p>默认情况下，infra_cache最多缓存10000条条目。经过测试，实际环境下infra_cache缓存的条目在9300~9700之间，并且新进来的条目会覆盖之前的条目。client请求被覆盖的zone下的子域名时，time out重新计时。</p><p>具体可以参考unbound的<a href="https://nlnetlabs.nl/documentation/unbound/info-timeout/">document</a></p>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>joern使用</title>
    <link href="/2021/01/11/joern%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/01/11/joern%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://joern.io/">官方网站</a></p><p><a href="https://docs.joern.io/home">官方文档</a></p><p>安装环境：ubuntu 20.04</p><p>在这里做一下joern的使用记录。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单介绍一下joern的功能。</p><p>joern可以为C/C++代码生成代码属性图，将多个不同的程序表示形式合并到一个联合的图形数据结构中并允许用户通过查询语句遍历代码属性图来获取信息。</p><h3 id="CPG"><a href="#CPG" class="headerlink" title="CPG"></a>CPG</h3><p>CPG为每个应用唯一的代码版本提供可扩展的和多层的逻辑表示，包括控制流图、调用图、程序依赖图、目录结构等。CPG创建了代码的多层三维表示，具有很强的洞察力，这使得开发人员可充分了解应用程序每个版本执行的内容及可能带来的风险。</p><p>CPG由以下部分组成：</p><ul><li>节点及其对应的类型：每个节点都代表程序中的某个结构。</li><li>带有标记的有向边：程序构造之间的关系通过其相应节点之间的边表示。</li><li>键值对：节点带有键/值对（属性），其中有效键取决于节点类型。</li></ul><h4 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h4><p><strong>MetaData</strong></p><p><code>MetaData(language : String, version: String, overlays: List[String], [hash : String])</code></p><p>每个CPG都拥有一个元数据。</p><p><strong>AstNode</strong></p><p><code>AstNode(order : Int)</code></p><p>CPG中类型是语法树节点的节点。</p><p><strong>File</strong></p><p><code>File(name: String, [hash: String])</code></p><p><strong>NamespaceBlock</strong></p><p><code>NamespaceBlock(name : String, fullName : String, order: Int, filename: String)</code></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="test1-c"><a href="#test1-c" class="headerlink" title="test1.c"></a>test1.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vul</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n = ntohl(x);<br><span class="hljs-keyword">char</span> chunk1[<span class="hljs-number">20</span>] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);<br><span class="hljs-built_in">memcpy</span>(chunk1,<span class="hljs-string">&quot;a&quot;</span>,n);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> x = <span class="hljs-number">40</span>;<br>vul(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试用joern找出这段代码中存在overflow的函数。</p><p>因为常见的溢出(堆溢出、栈溢出)都是由于使用一些不安全函数而导致的，因此先找出调用诸如<code>memcpy</code>、<code>read</code>、<code>gets</code>等危险函数的函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">joern&gt; cpg.method.name(<span class="hljs-string">&quot;memcpy|recv|read|gets&quot;</span>).caller.l.map(method =&gt; method.name) <br>res6: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>(<span class="hljs-string">&quot;vul&quot;</span>)<br></code></pre></td></tr></table></figure><p>说明<code>vul</code>函数、<code>normal</code>函数中调用了以上几个syscall中其中的一个。</p><p>查看<code>vul</code>函数的语法树子节点，过滤出调用这几个函数的语句：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">joern&gt; cpg.method.name(<span class="hljs-string">&quot;vul&quot;</span>).astChildren.astChildren.isCall.code.l <br>res21: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>(<span class="hljs-string">&quot;* s = malloc(x)&quot;</span>, <span class="hljs-string">&quot;memcpy(buf, s, x)&quot;</span>)<br></code></pre></td></tr></table></figure><p>遍历一下<code>vul</code>函数中有关的赋值语句：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">cpg.method.name(<span class="hljs-string">&quot;vul&quot;</span>).repeat(_.astChildren)(_.until(_.isCall.name(<span class="hljs-string">&quot;&lt;operator&gt;.assignment&quot;</span>))).isCall.code.l <br>res23: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>(<span class="hljs-string">&quot;n = ntohl(x)&quot;</span>, <span class="hljs-string">&quot;chunk1[20] = malloc(20)&quot;</span>)<br></code></pre></td></tr></table></figure><p>chunk1的大小是20字节，n的大小取决于x。查看<code>vul</code>函数的参数以及局部变量：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala">joern&gt; cpg.method.name(<span class="hljs-string">&quot;vul&quot;</span>).local.code.l <br>res25: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>(<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;chunk1&quot;</span>)<br>joern&gt; cpg.method.name(<span class="hljs-string">&quot;vul&quot;</span>).parameter.code.l <br>res26: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>(<span class="hljs-string">&quot;int x&quot;</span>)<br></code></pre></td></tr></table></figure><p>查看调用<code>vul</code>函数的语句：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs scala">joern&gt; cpg.method.name(<span class="hljs-string">&quot;main&quot;</span>).repeat(_.astChildren)(_.until(_.isCall.name(<span class="hljs-string">&quot;vul&quot;</span>))).l <br>res28: <span class="hljs-type">List</span>[<span class="hljs-type">AstNode</span>] = <span class="hljs-type">List</span>(<br>  <span class="hljs-type">Call</span>(<br>    id -&gt; <span class="hljs-number">1000125</span>L,<br>    code -&gt; <span class="hljs-string">&quot;vul(x)&quot;</span>,<br>    name -&gt; <span class="hljs-string">&quot;vul&quot;</span>,<br>    order -&gt; <span class="hljs-number">3</span>,<br>    methodInstFullName -&gt; <span class="hljs-type">None</span>,<br>    methodFullName -&gt; <span class="hljs-string">&quot;vul&quot;</span>,<br>    argumentIndex -&gt; <span class="hljs-number">3</span>,<br>    dispatchType -&gt; <span class="hljs-string">&quot;STATIC_DISPATCH&quot;</span>,<br>    signature -&gt; <span class="hljs-string">&quot;TODO assignment signature&quot;</span>,<br>    typeFullName -&gt; <span class="hljs-string">&quot;ANY&quot;</span>,<br>    dynamicTypeHintFullName -&gt; <span class="hljs-type">List</span>(),<br>    lineNumber -&gt; <span class="hljs-type">Some</span>(value = <span class="hljs-number">14</span>),<br>    columnNumber -&gt; <span class="hljs-type">Some</span>(value = <span class="hljs-number">1</span>),<br>    resolved -&gt; <span class="hljs-type">None</span>,<br>    depthFirstOrder -&gt; <span class="hljs-type">None</span>,<br>    internalFlags -&gt; <span class="hljs-type">None</span><br>  )<br>)<br>joern&gt; cpg.method.name(<span class="hljs-string">&quot;main&quot;</span>).repeat(_.astChildren)(_.until(_.isCall.name(<span class="hljs-string">&quot;&lt;operator&gt;.assignment&quot;</span>))).l <br>res29: <span class="hljs-type">List</span>[<span class="hljs-type">AstNode</span>] = <span class="hljs-type">List</span>(<br>  <span class="hljs-type">Call</span>(<br>    id -&gt; <span class="hljs-number">1000122</span>L,<br>    code -&gt; <span class="hljs-string">&quot;x = 40&quot;</span>,<br>    name -&gt; <span class="hljs-string">&quot;&lt;operator&gt;.assignment&quot;</span>,<br>    order -&gt; <span class="hljs-number">2</span>,<br>    methodInstFullName -&gt; <span class="hljs-type">None</span>,<br>    methodFullName -&gt; <span class="hljs-string">&quot;&lt;operator&gt;.assignment&quot;</span>,<br>    argumentIndex -&gt; <span class="hljs-number">2</span>,<br>    dispatchType -&gt; <span class="hljs-string">&quot;STATIC_DISPATCH&quot;</span>,<br>    signature -&gt; <span class="hljs-string">&quot;TODO assignment signature&quot;</span>,<br>    typeFullName -&gt; <span class="hljs-string">&quot;ANY&quot;</span>,<br>    dynamicTypeHintFullName -&gt; <span class="hljs-type">List</span>(),<br>    lineNumber -&gt; <span class="hljs-type">Some</span>(value = <span class="hljs-number">13</span>),<br>    columnNumber -&gt; <span class="hljs-type">Some</span>(value = <span class="hljs-number">5</span>),<br>    resolved -&gt; <span class="hljs-type">None</span>,<br>    depthFirstOrder -&gt; <span class="hljs-type">None</span>,<br>    internalFlags -&gt; <span class="hljs-type">None</span><br>  )<br>)<br></code></pre></td></tr></table></figure><p>可以得知x=40，最后还需验证一下<code>n = ntohl(x)</code>以后，<code>n</code>的值有没有被修改：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getFlow</span></span>() = &#123;<br>  <span class="hljs-keyword">val</span> src = cpg.call.name(<span class="hljs-string">&quot;ntohl&quot;</span>)<br>  <span class="hljs-keyword">val</span> sink = cpg.call.name(<span class="hljs-string">&quot;memcpy&quot;</span>).argument.order(<span class="hljs-number">3</span>)<br>  sink.reachableByFlows(src).p<br>&#125; <br></code></pre></td></tr></table></figure><p>运行<code>getFlow()</code>函数，得到：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala">joern&gt; <span class="hljs-keyword">val</span> src = cpg.method.name(<span class="hljs-string">&quot;vul&quot;</span>).call.name(<span class="hljs-string">&quot;ntohl&quot;</span>) <br>src: <span class="hljs-type">Traversal</span>[<span class="hljs-type">Call</span>] = <span class="hljs-type">Traversal</span><br><br>joern&gt; <span class="hljs-keyword">val</span> sink = cpg.method.name(<span class="hljs-string">&quot;vul&quot;</span>).call.name(<span class="hljs-string">&quot;memcpy&quot;</span>).argument.order(<span class="hljs-number">3</span>) <br>sink: <span class="hljs-type">Traversal</span>[<span class="hljs-type">Expression</span>] = <span class="hljs-type">Traversal</span><br><br>joern&gt; sink.reachableByFlows(src).p <br>res33: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>(<br>  <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"> ____________________________________________________________________________________________</span><br><span class="hljs-string">| tracked              | lineNumber| method| file                                           |</span><br><span class="hljs-string">|===========================================================================================|</span><br><span class="hljs-string">| ntohl(x)             | 6         | vul   | /home/zhd/Desktop/joern-cli/test/test1/test1.c |</span><br><span class="hljs-string">| n = ntohl(x)         | 6         | vul   | /home/zhd/Desktop/joern-cli/test/test1/test1.c |</span><br><span class="hljs-string">| memcpy(chunk1,&quot;a&quot;,n) | 8         | vul   | /home/zhd/Desktop/joern-cli/test/test1/test1.c |</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>发现从控制流的角度来看，n在被复制之后就以参数的形式传入到了<code>memcpy</code>函数中，因此该函数存在堆溢出。</p><p>不过joern官方已经有了堆溢出的检测脚本：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala">joern&gt; cpg.runScript(<span class="hljs-string">&quot;/home/zhd/Desktop/joern-cli/scripts/c/malloc-leak.sc&quot;</span>) <br>res35: <span class="hljs-type">Any</span> = <span class="hljs-type">Set</span>(<span class="hljs-string">&quot;chunk1&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>malloc-leak.sc</code>的脚本内容如下(其实就是把查询语句封装起来)：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> io.shiftleft.codepropertygraph.<span class="hljs-type">Cpg</span><br><span class="hljs-keyword">import</span> io.shiftleft.dataflowengineoss.language._<br><span class="hljs-keyword">import</span> io.shiftleft.semanticcpg.language._<br><span class="hljs-keyword">import</span> io.shiftleft.semanticcpg.language.operatorextension.opnodes.<span class="hljs-type">Assignment</span><br><span class="hljs-keyword">import</span> overflowdb.traversal._<br><br><span class="hljs-meta">@main</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>() = &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allocated</span> </span>= cpg.call(<span class="hljs-string">&quot;malloc&quot;</span>).inAssignment.target.dedup<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">freed</span> </span>= cpg.call(<span class="hljs-string">&quot;free&quot;</span>).argument(<span class="hljs-number">1</span>)<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flowsFromAllocToFree</span> </span>= freed.reachableBy(allocated).toSet<br>  allocated.map(_.code).toSet.diff(flowsFromAllocToFree.map(_.code))<br>&#125;<br></code></pre></td></tr></table></figure><p>感受一下joern生成的<code>AST</code>、<code>CFG</code>、<code>CPG</code></p><p><img src="https://github.com/zhenghaodong/picture/raw/master/72.png" alt=""></p><p><img src="https://github.com/zhenghaodong/picture/raw/master/73.png" alt=""></p><p><img src="https://github.com/zhenghaodong/picture/raw/master/74.png" alt=""></p><h3 id="test2-c"><a href="#test2-c" class="headerlink" title="test2.c"></a>test2.c</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 DNS研究整理</title>
    <link href="/2020/12/03/2020-DNS%E7%A0%94%E7%A9%B6%E6%95%B4%E7%90%86/"/>
    <url>/2020/12/03/2020-DNS%E7%A0%94%E7%A9%B6%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>整理一下2020年针对dns的新的攻击方式。同样内容也更新在<a href="https://github.com/zhenghaodong/network-security-study-list">network-security-study-list</a>里面</p></blockquote><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>四大顶会论文：</p><ul><li>DNS Cache Poisoning Attack Reloaded: Revolutions with Side Channels</li><li>Poison Over Troubled Forwarders: A Cache Poisoning Attack Targeting DNS Forwarding Devices</li><li>NXNSAttack: Recursive DNS Inefficiencies and Vulnerabilities</li></ul><p><strong>其中与DNS缓存污染的相关工作有两项，dos有一项。</strong></p><p>爆出的严重CVE：</p><ul><li>CVE-2020-1350</li></ul><p><strong>新的攻击方案的切入点</strong>：</p><ul><li>针对RFC中对转发器功能描述不明确、转发器缺少必要的验证手段</li><li>在解析器解析的过程中，对于解析记录中的对象、解析数量没有做严格限制</li><li>存在其他协议上的侧信道</li></ul><p><strong>影响范围</strong>：</p><ul><li>从DNS软件栈上来说，两种缓存投毒攻击对于常见的BIND、Unbound、dnsmasq都会造成影响；dos攻击影响了bind、unbound、powerdns、CZ.NIC Knot Resolver (CVE-2020-12667), Cloudflare, Google, Amazon, Microsoft, Oracle (DYN), Verisign, IBM Quad9 and ICANN。<strong>这说明不同DNS软件栈在基本功能上的逻辑是类似的？</strong></li><li>从结构上来看，转发器、解析器都会被侧信道攻击影响，而dos影响了解析器，分片攻击主要攻击转发器。</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="DNS-Cache-Poisoning-Attack-Reloaded-Revolutions-with-Side-Channels"><a href="#DNS-Cache-Poisoning-Attack-Reloaded-Revolutions-with-Side-Channels" class="headerlink" title="DNS Cache Poisoning Attack Reloaded: Revolutions with Side Channels"></a>DNS Cache Poisoning Attack Reloaded: Revolutions with Side Channels</h3><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><blockquote><p>from Usenix 2020</p><p>这篇文章站在攻击者的角度，利用侧信道的方式通过icmp port unreachable嗅探源端口，改进了DNS缓存投毒的攻击方式，使得攻击时间代价由2^32减小到了2^16。</p></blockquote><h4 id="DNS缓存投毒限制"><a href="#DNS缓存投毒限制" class="headerlink" title="DNS缓存投毒限制"></a>DNS缓存投毒限制</h4><ul><li>源端口随机化+transaction id(client-&gt;server：源端口&gt;1023，目的端口=53；server-&gt;client：源端口=53，目的端口&gt;1023；server-&gt;server：udp均为53，tcp均&gt;1023)</li><li>0x20 bit encoding(使用不同大小写模式来判断是否为伪造响应)</li><li>DNSSEC</li></ul><h4 id="攻击模型"><a href="#攻击模型" class="headerlink" title="攻击模型"></a>攻击模型</h4><h5 id="icmp"><a href="#icmp" class="headerlink" title="icmp"></a>icmp</h5><blockquote><p>提供可靠传输，确认IP包是否到达目标地址并通知丢包原因。</p></blockquote><p>不同系统对ICMP error包都进行带宽限制，防止攻击者借此消耗更多资源。Linux：Per-IP/s一个，全局限制为1000个/s，最大并发为50个/ms。</p><h5 id="DNS软件栈"><a href="#DNS软件栈" class="headerlink" title="DNS软件栈"></a>DNS软件栈</h5><p>bind：采用connect()套接字来实现dns包通信，如果ip/端口不匹配，则返回ICMP port unreachable。</p><p>unbound、dnsmasq：使用sendto()和recvfm()来接、收dns包，端口不匹配返回ICMP port unreachable。</p><h5 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h5><h6 id="猜测源端口"><a href="#猜测源端口" class="headerlink" title="猜测源端口"></a>猜测源端口</h6><p><strong>unbound以及dnsmasq</strong>：</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/39.png" alt=""></p><p>绕过Per-IP limit：</p><ul><li>使用多个ip进行攻击</li><li>ipv6</li><li>受用dhcp</li></ul><p>50个数据包为一个batch向目标dns服务器发送(每个数据包的ip都不同)，如果返回50个icmp error包，则证明这50个端口均未开放；如果小于50，则证明50个端口中有开放的端口，此时用真实ip构造数据包二分查找端口。</p><p><strong>bind</strong>：</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/40.png" alt=""></p><p>使用上游dns服务器ip作为欺骗ip来构造udp数据包并发送给目标dns服务器。由于bind逻辑中，先检查全局icmp限制，再检查单个ip限制，因此单个ip限制不会影响全局的icmp error包带宽。因此先发50个包占满最大icmp error并发，收到1个icmp返回包后接着再用真实ip发送一个包，若收到ICMP响应，则证明前一个batch中有对应的端口开放。</p><h6 id="延长攻击窗口"><a href="#延长攻击窗口" class="headerlink" title="延长攻击窗口"></a>延长攻击窗口</h6><p><strong>forwarder</strong>：</p><p>转发器为了不重复解析器工作，在设计上完全信任上游DNS解析器及其响应。</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/31.png" alt=""></p><p><strong>resolver</strong>：</p><p>RRL机制：每秒返回给请求者的响应有最大限制，超过限制则会直接将数据包drop掉。因此可以利用这个机制，mute权威服务器使其不向被攻击的DNS服务器发包，迫使被攻击的DNS服务器的源端口一直保持开放。</p><h3 id="Poison-Over-Troubled-Forwarders-A-Cache-Poisoning-Attack-Targeting-DNS-Forwarding-Devices"><a href="#Poison-Over-Troubled-Forwarders-A-Cache-Poisoning-Attack-Targeting-DNS-Forwarding-Devices" class="headerlink" title="Poison Over Troubled Forwarders: A Cache Poisoning Attack Targeting DNS Forwarding Devices"></a>Poison Over Troubled Forwarders: A Cache Poisoning Attack Targeting DNS Forwarding Devices</h3><h4 id="abstract-1"><a href="#abstract-1" class="headerlink" title="abstract"></a>abstract</h4><blockquote><p>from Usenix 2020</p><p>这篇文章提出了一种针对于DNS转发器使用IP分片技术的DNS缓存投毒攻击。</p></blockquote><h4 id="基于IP分片的DNS污染"><a href="#基于IP分片的DNS污染" class="headerlink" title="基于IP分片的DNS污染"></a>基于IP分片的DNS污染</h4><p>碎片化的DNS响应包第二片段不含DNS或UDP包头，攻击者伪造第二片段然后发出受害域名DNS查询，通过分割权威服务器的响应将响应包的包头与第二片段合并。主要有以下两种方式：</p><ul><li>降低解析器到权威之间的路径最大传输单位</li><li>发送DNSSEC查询以使用DNSSEC记录来扩大响应，达到MTU限制(以太网为1500比特)</li></ul><p><strong>问题</strong>：只有0.7%的top 100kDNS服务器愿意将MTU减小至528比特(DNS响应通常小于512字节)；DNSSEC部署程度还比较低。</p><h4 id="转发器"><a href="#转发器" class="headerlink" title="转发器"></a>转发器</h4><p>充当客户端入口服务器，转发数据到上游递归解析器；用作客户端默认本地解析器，或对上游负载均衡并实施访问控制。递归解析器以递归模式对原始查询的最终答案进行响应并执行完整性检查。</p><p>但是转发器的实际标准功能以及实现比较杂乱，RFC并没有给出相应的明确细节规定。</p><h4 id="攻击模型-1"><a href="#攻击模型-1" class="headerlink" title="攻击模型"></a>攻击模型</h4><p>攻击者通过构造较大的DNS请求包迫使权威返回较大的DNS响应包，使得响应包的第一部分与转发器中被攻击者预先缓存的带有假解析记录的第二部分合并，从而污染转发器。</p><h5 id="IPID预测"><a href="#IPID预测" class="headerlink" title="IPID预测"></a>IPID预测</h5><p>IPID可以确定片段所属数据报，欺骗段段IPID与上游解析器IPID一致才可以被认为属于同一数据段并进行合并。</p><p>IP碎片整理通常缓存64个片段，攻击者可以对一系列IPID值进行预测，全局IPID分配和短时间内对hash-IPID分配都是可以预测的。</p><h5 id="CNAME链"><a href="#CNAME链" class="headerlink" title="CNAME链"></a>CNAME链</h5><p>攻击者构造超长的带有CNAME链的域名，迫使权威在解析该域名的时候返回给解析器大量CNAME结果与最终的A记录。</p><p>计算CNAME响应所需长度：以太网最长分片大小(1500比特) - IP包包头长度(20比特) - UDP包包头长度(20比特) = 1460比特。</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/37.png" alt=""></p><p>由于分片，第一分片到达转发器的时间要遭遇第二分片，如果攻击者事先先发送一系列包含恶意A解析记录伪造的第二分片数据到转发器，那么第一分片就会与恶意的第二分片结合，真实的第二分片就会被舍弃掉。结合后的包含恶意A解析记录的DNS解析记录就会缓存到转发器中。</p><h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h4><p><img src="https://github.com/zhenghaodong/picture/raw/master/38.png" alt=""></p><ul><li>攻击者准备好带有长CNAME链解析的域名S</li><li>随意发送一个请求，监听响应包获取当前IPID</li><li>预测IPID可能的值，将受害者域名的恶意A记录与预测的每个IPID分别制作成包的第二片段</li><li>将所有第二切片发送给转发器使其缓存</li><li>攻击者发起域名S的DNS请求</li><li>转发器缓存被污染</li></ul><h4 id="攻击成功条件"><a href="#攻击成功条件" class="headerlink" title="攻击成功条件"></a>攻击成功条件</h4><ul><li>EDNS机制(转发器支持在UDP协议上传输size比较大的DNS包)</li><li>不对包进行额外切片(转发器不对包进行再切片)</li><li>对DNS响应包不进行验证(转发器不支持DNSSEC等验证机制)</li><li>以每条解析记录为单位进行缓存(转发器以每条record如A记录、CNAME记录等为单位进行缓存，而不是以整个响应包为单位缓存)</li></ul><h4 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h4><ul><li>让转发器验证超大的DNS响应(重新响应CNAME中所有名称、别名或执行完整的DNSSEC)</li><li>以response为主体进行缓存</li><li>0x20编码(需要上游递归解析器进行修改)</li><li>随机化IPID</li></ul><h3 id="NXNSAttack-Recursive-DNS-Inefficiencies-and-Vulnerabilities"><a href="#NXNSAttack-Recursive-DNS-Inefficiencies-and-Vulnerabilities" class="headerlink" title="NXNSAttack: Recursive DNS Inefficiencies and Vulnerabilities"></a>NXNSAttack: Recursive DNS Inefficiencies and Vulnerabilities</h3><h4 id="abstract-2"><a href="#abstract-2" class="headerlink" title="abstract"></a>abstract</h4><blockquote><p>from Usenix 2020</p><p>本文探讨了递归解析器的脆弱性，分析递归解析器与权威性层次结构之间的交互，提出了一个基于递归解析器算法漏洞的攻击方式。</p></blockquote><h4 id="glue-record"><a href="#glue-record" class="headerlink" title="glue record"></a>glue record</h4><p>glue record要求当NS记录中的域名为request中域名的子域名时，要为NS中的域名配置A记录。</p><p>如果没有这类要求，则可能出现死循环情况：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">request: <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.com</span><br>response: <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.com</span>NS<span class="hljs-number">1</span><span class="hljs-selector-class">.a</span><span class="hljs-selector-class">.com</span><br>additional: 空<br></code></pre></td></tr></table></figure><p>解析器转而查询1.a.com时又会向a.com发起查询。</p><h4 id="bailwick"><a href="#bailwick" class="headerlink" title="bailwick"></a>bailwick</h4><p>bailwick对附加区内的域名进行检查，若不为请求域名的子域名，则不接受该A记录。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">问题区:<br>    www<span class="hljs-selector-class">.foo</span><span class="hljs-selector-class">.com</span>  A <span class="hljs-number">1.2</span>.<span class="hljs-number">3.4</span><br>权威区:<br>    foo<span class="hljs-selector-class">.com</span>     NS  ns1<span class="hljs-selector-class">.foo</span><span class="hljs-selector-class">.com</span><br>附加区:<br>    ns1<span class="hljs-selector-class">.foo</span><span class="hljs-selector-class">.com</span> A <span class="hljs-number">2.3</span>.<span class="hljs-number">4.5</span><br>    www<span class="hljs-selector-class">.bar</span><span class="hljs-selector-class">.com</span> A <span class="hljs-number">6.6</span>.<span class="hljs-number">6.6</span><br></code></pre></td></tr></table></figure><h4 id="攻击模型-2"><a href="#攻击模型-2" class="headerlink" title="攻击模型"></a>攻击模型</h4><p><strong>攻击者具备条件</strong>：拥有1个或多个DNS客户端、1个域名权威服务器。</p><p><strong>攻击对象</strong>：递归解析器、域名的权威服务器、根域名服务器。</p><p>利用不含glue records的NS记录，对NS记录中的域名进行递归解析实现dos攻击。</p><h5 id="攻击域名的权威服务器"><a href="#攻击域名的权威服务器" class="headerlink" title="攻击域名的权威服务器"></a>攻击域名的权威服务器</h5><p>流程如下图：</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/41.png" alt=""></p><ul><li>攻击者首先注册attacker.com的域名及其下的一些子域名</li><li>攻击者向解析器发出很多attacker.com的子域名的请求</li><li>对于每一条子域名，攻击者都设置其解析记录中包含n个NS记录，NS记录将委托受害者域名下的不同子域名承担解析工作</li><li>对于每条子域名的请求，解析器都会收到n个NS记录返回，由于包中没有glue record，解析器会对每个NS记录中的委托的域名进行一次额外解析(IPV4和IPV6都要)</li><li>所有攻击者发起请求的子域名的NS记录中的委托解析的域名都会被解析器发起解析道受害者的域名权威服务器victim.com，导致其服务瘫痪</li></ul><h5 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h5><p>流程如下图：</p><p><img src="https://github.com/zhenghaodong/picture/raw/master/43.png" alt=""></p><p>与正常方式不同的是，攻击者在对每个子域名进行第一个NS记录响应时采用了自我委托的策略。</p><p>流程如下：</p><ul><li>攻击者首先注册attacker.com的域名及其下的一些子域名</li><li>攻击者向解析器发出很多attacker.com的子域名的请求</li><li>对于每一条子域名，攻击者都设置其解析记录中包含n个NS记录，NS记录将委托attacker.com域名下与request中域名的不同子域名承担解析工作</li><li>接着解析器会对权威返回的NS中的n条Xni.attacker.com进行解析</li><li>对于第二次解析中每条子域名的请求，解析器都会收到n个NS记录返回，由于包中没有glue record，解析器会对每个NS记录中的委托的域名进行一次额外解析(IPV4和IPV6都要)</li><li>所有攻击者发起请求的子域名的NS记录中的委托解析的域名都会被解析器发起解析道受害者的域名权威服务器victim.com</li></ul><p>限制条件：</p><ul><li>委托响应中委托的域名的最大数量</li><li>max-recursion-queries</li></ul><p><img src="https://github.com/zhenghaodong/picture/raw/master/44.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intel MPX概述</title>
    <link href="/2020/03/03/2020-03-03-Intel-MPX/"/>
    <url>/2020/03/03/2020-03-03-Intel-MPX/</url>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Intel MPX的唯一目的是透明地将边界检查添加到遗留的C/ c++程序中，这里给出一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">obj</span> &#123;</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">100</span>];  <span class="hljs-keyword">int</span> len &#125;<br><span class="hljs-number">1</span>: obj* a[<span class="hljs-number">10</span>]                      <span class="hljs-comment">// Array of pointers to objs</span><br><span class="hljs-number">2</span>: total = <span class="hljs-number">0</span><br><span class="hljs-number">3</span>: <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;M; i++):<br><span class="hljs-number">4</span>:     ai = a + i                  <span class="hljs-comment">// Pointer arithmetic on a</span><br><span class="hljs-number">5</span>:     objptr = load ai            <span class="hljs-comment">// Pointer to obj at a[i]</span><br><span class="hljs-number">6</span>:     lenptr = objptr + <span class="hljs-number">100</span>       <span class="hljs-comment">// Pointer to obj.len</span><br><span class="hljs-number">7</span>:     len = load lenptr<br><span class="hljs-number">8</span>:     total += len                <span class="hljs-comment">// Total length of all objs</span><br></code></pre></td></tr></table></figure><p>这段C代码在MPX保护被启用的情况下会被翻译成以下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span>: obj* a[<span class="hljs-number">10</span>]<br><span class="hljs-number">2</span>: a_b = bndmk a, a+<span class="hljs-number">79</span>          <span class="hljs-comment">// Make bounds [a, a+79]</span><br><span class="hljs-number">3</span>: total = <span class="hljs-number">0</span><br><span class="hljs-number">4</span>: <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;M; i++):<br><span class="hljs-number">5</span>:     ai = a + i<br><span class="hljs-number">6</span>:     bndcl a_b, ai            <span class="hljs-comment">// Lower-bound check of a[i]</span><br><span class="hljs-number">7</span>:     bndcu a_b, ai+<span class="hljs-number">7</span>          <span class="hljs-comment">// Upper-bound check of a[i]</span><br><span class="hljs-number">8</span>:     objptr = load ai<br><span class="hljs-number">9</span>:     objptr_b = bndldx ai     <span class="hljs-comment">// Bounds for pointer at a[i]</span><br><span class="hljs-number">10</span>:    lenptr = objptr + <span class="hljs-number">100</span><br><span class="hljs-number">11</span>:    bndcl objptr_b, lenptr   <span class="hljs-comment">// Lower-bound check of obj.len</span><br><span class="hljs-number">12</span>:    bndcu objptr_b, lenptr+<span class="hljs-number">3</span> <span class="hljs-comment">// Upper-bound check of obj.len</span><br><span class="hljs-number">13</span>:    len = load lenptr<br><span class="hljs-number">14</span>:    total += len<br></code></pre></td></tr></table></figure><p>首先声明一个obj类型的数组指针，a_b表示为a的上下界。进入循环，在第6、7行会插入两条MPX检测语句检测ai是否在a_b中。</p><p>第8行程序从内存地址ai检索后去objptr指针，此时MPX会再使用bndldx从相同地址检索相关界限。</p><p>对于MPX来说，要从硬件和软件层面进行实现：</p><ul><li>硬件级别，添加了新的指令和一组128位寄存器。</li><li>操作系统级别，添加了一个新的#BR处理程序，它有两个主要功能:为按需边界分配存储以及在检测到违反边界时向程序发送信号。</li><li>编译器级别，添加新的MPX转换传递来插入MPX指令来创建、传播、存储和检查边界。</li><li>应用程序级别，受mpx保护的程序可能需要手动更改，因为有麻烦的C编码模式、多线程问题或其他ISA扩展的潜在问题。</li></ul><h2 id="硬件层面"><a href="#硬件层面" class="headerlink" title="硬件层面"></a>硬件层面</h2><p>Intel MPX提供了7条新的指令以及一组128位界限寄存器。</p><p>新的指令为以下：</p><ul><li>bndmk创建新的边界</li><li>bndcl和bndcu / bndcn比较指针值的上下界限</li><li>bndmov移动范围从一个寄存器注册到另一个</li><li>bndldx和bndstx分别在特殊的界限表中加载和存储指针界限</li></ul><blockquote><p>注：由于当前版本，MPX只有四个界限寄存器，因此所有附加的界限数据必须存储在内存中。一个简单且相对快速的选择是使用bndmov将它们直接复制到编译器定义的内存位置(在堆栈上)。但是，它只在一个堆栈框架内工作:如果一个指针后来在另一个函数中重用，它的边界将丢失。为了解决这个问题，引入了两种指令:bndstx和bndldx。它们存储/加载从指针本身的地址衍生的内存位置的界限数据，从而使查找指针界限变得很容易，而不需要任何额外的信息，尽管代价是更高的复杂性。</p><p>每个指针在一个界限表(Bounds Table, BT)中都有一个条目，这个条目是动态分配的，相当于一个页表。BTs的地址存储在Bounds Directory (BD)中，它对应于我们类比的页面目录。对于特定的指针，它在BD和BT中的条目是由指针所在的内存地址派生的。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcpszz18djj30fi0dhjt3.jpg" alt=""></p><p>首先加载需要的BD中存储的BTs的地址：</p><ol><li>从位20-47提取BD条目的偏移指针地址并向左偏移3位</li><li>从BNDCFGx中加载BD的基地址</li><li>通过基地址依旧偏移计算出BTs的地址</li></ol><p>其次要加载BT的条目：</p><ol><li>从指针地址的3-19位中提取偏移地址并左移5位</li><li>将BTs的地址取出并移除前3位包含的元数据</li><li>对基数和偏移量求和，根据结果加载到BT条目</li></ol><p>BT条目有一个附加的“指针”字段——如果实际指针值和该字段中的值不匹配，MPX将把界限标记为始终为真(INIT)。</p><h2 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h2><p>对于MPX，操作系统有两个主要职责:处理边界违规和管理BTs。，创建并删除它们。这两个操作都与一个新的异常类#BR相关联，#BR是专门为MPX引入的，类似于页面错误，但具有扩展功能。</p><p>如果系统检测到触发边界越界，就会触发#BR并陷入内核态，内核对指令进行解码，以获得违规地址和违规边界，并将它们存储在siginfo结构中。然后，它将SIGSEGV信号连同siginfo结构中的违规信息一起发送给应用程序。</p><h2 id="编译器层面"><a href="#编译器层面" class="headerlink" title="编译器层面"></a>编译器层面</h2><p>以新指令和寄存器的形式支持硬件MPX可以显著降低每个单独的边界检查操作的性能开销。然而，整个程序的有效、正确和完整的边界检查的主要负担在于编译器及其相关的运行时。</p><ol><li>为全局变量分配静态界限，为堆栈分配的变量插入bndmk指令。</li><li>每次从指针加载或存储之前，它都会插入bndcl和bndcu的边界检查指令。</li><li>每当从一个旧指针创建一个新指针时，它使用bndmov将界限从一个bnd寄存器移动到另一个bnd寄存器。</li><li>如果可用的bnd寄存器用完，它会通过bndmov将最少使用的边界赋值到堆栈。</li><li>每当从内存中加载/存储指针时，分别通过bndldx和bndstx加载和存储关联的界限。</li></ol><p>GCC为了提高性能而进行的优化：</p><ol><li>当编译器可以静态地证明内存访问的安全性时，删除边界检查，例如，在一个已知偏移量的数组中进行访问。</li><li>移动(提升)边界——检查出简单的循环。</li></ol><p>eg:回到上述例子，如果已知M&lt;=10，那么6、7两行的检查一定恒等于”真”，因此可以删掉；否则优化2可以在循环体之前插入并移动这些检查，在每次迭代中保存两条指令。</p><p>对于启动MPX来说还有一个必要条件：应用程序必须链接到两个特定于mpx的库:libmpx和libmpxwrappers：</p><ul><li>ibmpx库负责在程序启动时初始化MPX:它启用硬件和操作系统支持，并配置MPX运行时选项(通过环境变量传递)。</li><li>GCC中的libmpxwrappers库(以及ICC中的类似libchkp)包含来自标准C库(libc)的函数的包装器，MPX实现并不检测libc，而是用一个边界检查副本来包装它的所有功能。</li></ul>]]></content>
    
    
    <categories>
      
      <category>security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>system security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC Plugin实践</title>
    <link href="/2020/01/29/2020-01-29-GCC-Plugin/"/>
    <url>/2020/01/29/2020-01-29-GCC-Plugin/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这次深入到了编译器层面～</p></blockquote><h2 id="下载GCC"><a href="#下载GCC" class="headerlink" title="下载GCC"></a>下载GCC</h2><p>系统：ubuntu 16.04 64bit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">`# 定义下载路径<br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> BASEDIR=<span class="hljs-variable">$HOME</span>/gcc-plugins</span><br><span class="hljs-meta">#</span><span class="bash"> 创建下载文件夹</span><br><span class="hljs-meta">$</span><span class="bash"> mkdir -p <span class="hljs-variable">$BASEDIR</span></span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> <span class="hljs-variable">$BASEDIR</span></span><br><span class="hljs-meta">$</span><span class="bash"> wget http://ftp.gnu.org/gnu/gcc/gcc-5.2.0/gcc-5.2.0.tar.bz2</span><br><span class="hljs-meta">$</span><span class="bash"> tar xfj gcc-5.2.0.tar.bz2</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> ..</span><br><span class="hljs-meta">#</span><span class="bash"> 创建build文件夹</span><br><span class="hljs-meta">$</span><span class="bash"> mkdir gcc-build</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> gcc-build</span><br><span class="hljs-meta">#</span><span class="bash"> 定义路径</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> INSTALLDIR=<span class="hljs-variable">$BASEDIR</span>/gcc-install</span><br><span class="hljs-meta">#</span><span class="bash"> Configure GCC</span><br><span class="hljs-meta">$</span><span class="bash"> ../gcc-5.2.0/configure --prefix=<span class="hljs-variable">$INSTALLDIR</span> --enable-languages=c,c++</span><br><span class="hljs-meta">#</span><span class="bash"> make编译</span><br><span class="hljs-meta">$</span><span class="bash"> make -j$(getconf _NPROCESSORS_ONLN)</span><br><span class="hljs-meta">$</span><span class="bash"> make install</span><br></code></pre></td></tr></table></figure><p>检查下载：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 创建一个GCC路径的变量</span><br>$ <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GCCDIR</span>=<span class="hljs-variable">$INSTALLDIR</span>/bin<br>$ <span class="hljs-variable">$GCCDIR</span>/g++ --version<br>g++ (GCC) 5.2.0<br>Copyright (C) 2015 Free Software Foundation, Inc.<br>This is free software; see the source <span class="hljs-keyword">for</span> copying conditions.  There is <span class="hljs-literal">NO</span><br>warranty; <span class="hljs-keyword">not</span> even <span class="hljs-keyword">for</span> MERCHANTABILITY <span class="hljs-keyword">or</span> FITNESS <span class="hljs-keyword">FOR</span> A PARTICULAR PURPOSE.<br></code></pre></td></tr></table></figure><p>创建plugin文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir <span class="hljs-variable">$BASEDIR</span>/gcc-plugins</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> gcc-plugins</span><br></code></pre></td></tr></table></figure><p>编写build的Makefile：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs makefile">GCCDIR = &#123; put here the value of your $&#123;GCCDIR&#125; &#125;<br> <br>CXX = <span class="hljs-variable">$(GCCDIR)</span>/g++<br><span class="hljs-comment"># Flags for the C++ compiler: enable C++11 and all the warnings, -fno-rtti is required for GCC plugins</span><br>CXXFLAGS = -std=c++11 -Wall -fno-rtti <br><span class="hljs-comment"># Workaround for an issue of -std=c++11 and the current GCC headers</span><br>CXXFLAGS += -Wno-literal-suffix<br> <br><span class="hljs-comment"># Determine the plugin-dir and add it to the flags</span><br>PLUGINDIR=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> <span class="hljs-variable">$(CXX)</span> -print-<span class="hljs-built_in">file</span>-name=plugin)</span><br>CXXFLAGS += -I<span class="hljs-variable">$(PLUGINDIR)</span>/<span class="hljs-keyword">include</span><br> <br><span class="hljs-comment"># top level goal: build our plugin as a shared library</span><br><span class="hljs-section">all: warn_unused.so</span><br> <br><span class="hljs-section">warn_unused.so: warn_unused.o</span><br><span class="hljs-variable">$(CXX)</span> <span class="hljs-variable">$(LDFLAGS)</span> -shared -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br> <br>warn_unused.o : warn_unused.cc<br><span class="hljs-variable">$(CXX)</span> <span class="hljs-variable">$(CXXFLAGS)</span> -fPIC -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br> <br><span class="hljs-section">clean:</span><br>rm -f warn_unused.o warn_unused.so<br> <br><span class="hljs-section">check: warn_unused.so</span><br><span class="hljs-variable">$(CXX)</span> -fplugin=./warn_unused.so -c -x c++ /dev/null -o /dev/null<br> <br><span class="hljs-meta"><span class="hljs-meta-keyword">.PHONY</span>: all clean check</span><br></code></pre></td></tr></table></figure><p>编写一个测试的plugin：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-comment">// This is the first gcc header to be included</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gcc-plugin.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;plugin-version.h&quot;</span></span><br> <br><span class="hljs-comment">// We must assert that this plugin is GPL compatible</span><br><span class="hljs-keyword">int</span> plugin_is_GPL_compatible;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">plugin_init</span> <span class="hljs-params">(struct plugin_name_args *plugin_info,</span></span><br><span class="hljs-params"><span class="hljs-function">     struct plugin_gcc_version *version)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// We check the current gcc loading this plugin against the gcc we used to</span><br>  <span class="hljs-comment">// created this plugin</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  if (!plugin_default_version_check (version, &amp;gcc_version))</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">      std::cerr &lt;&lt; &quot;This GCC plugin is for version &quot; &lt;&lt; GCCPLUGIN_VERSION_MAJOR</span><br><span class="hljs-comment">&lt;&lt; &quot;.&quot; &lt;&lt; GCCPLUGIN_VERSION_MINOR &lt;&lt; &quot;\n&quot;;</span><br><span class="hljs-comment">      return 1;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-comment">// Let&#x27;s print all the information given to this plugin!</span><br> <br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Plugin info\n&quot;</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;===========\n\n&quot;</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Base name: &quot;</span> &lt;&lt; plugin_info-&gt;base_name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Full name: &quot;</span> &lt;&lt; plugin_info-&gt;full_name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Number of arguments of this plugin:&quot;</span> &lt;&lt; plugin_info-&gt;<br>    argc &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br> <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; plugin_info-&gt;argc; i++)<br>    &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Argument &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;: Key: &quot;</span> &lt;&lt; plugin_info-&gt;argv[i].<br>key &lt;&lt; <span class="hljs-string">&quot;. Value: &quot;</span> &lt;&lt; plugin_info-&gt;argv[i].value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br> <br>    &#125;<br>  <span class="hljs-keyword">if</span> (plugin_info-&gt;version != <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Version string of the plugin: &quot;</span> &lt;&lt; plugin_info-&gt;<br>      version &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-keyword">if</span> (plugin_info-&gt;help != <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Help string of the plugin: &quot;</span> &lt;&lt; plugin_info-&gt;help &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br> <br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Version info\n&quot;</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;============\n\n&quot;</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Base version: &quot;</span> &lt;&lt; version-&gt;basever &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Date stamp: &quot;</span> &lt;&lt; version-&gt;datestamp &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Dev phase: &quot;</span> &lt;&lt; version-&gt;devphase &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Revision: &quot;</span> &lt;&lt; version-&gt;devphase &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Configuration arguments: &quot;</span> &lt;&lt; version-&gt;<br>    configuration_arguments &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br> <br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Plugin successfully initialized\n&quot;</span>;<br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> make</span><br>/some/path/gcc-install/bin/g++ -std=c++11 -Wall -Wno-literal-suffix -I/home/roger/soft/gcc/gcc-5.2/lib/gcc/x86_64-unknown-linux-gnu/5.2.0/plugin/include -fPIC -c -o warn_unused.o warn_unused.cc<br>/some/path/gcc-install/bin/g++ -shared -o warn_unused.so warn_unused.o<br></code></pre></td></tr></table></figure><p>检测该plugin是否运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> make check</span><br>/some/path/gcc-install/bin/g++ -fplugin=./warn_unused.so -c -x c++ /dev/null -o /dev/null<br>Plugin info<br>===========<br> <br>Base name: warn_unused<br>Full name: ./warn_unused.so<br>Number of arguments of this plugin:0<br> <br>Version info<br>============<br> <br>Base version: 5.2.0<br>Date stamp: 20150716<br>Dev phase: <br>Revision: <br>Configuration arguments: ../gcc-5.2.0/configure --enable-languages=c,c++ --prefix=/some/path/gcc-install<br> <br>Plugin successfully initialized<br></code></pre></td></tr></table></figure><p>使用riscv架构下的gcc调用该plugin：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">riscv64-unknown-linux-gnu-gcc -fplugin=.<span class="hljs-regexp">/warn_unused.so -c -x c++ /</span>dev<span class="hljs-regexp">/null -o /</span>dev/<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h2 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo 1"></a>Demo 1</h2><blockquote><p>编写一个打印程序控制流图的plugin</p></blockquote><h3 id="控制流图"><a href="#控制流图" class="headerlink" title="控制流图"></a>控制流图</h3><p>控制流图(CFG)为有向图，是一个建立在中间代码(RTL或者Tree指令流)之上的数据结构，作用就是对编译函数的控制流行为进行抽象。</p><h4 id="basic-block"><a href="#basic-block" class="headerlink" title="basic_block"></a>basic_block</h4><p>Basic_block结构体包含了所有的基本块并且顺序不固定。基本块是一个只有入口和出口的直线代码序列，其中该结构体中有两个指针：<em>next_bb，</em>prev_bb用来维护与底层指令流顺序相同的基本块双向列表。有专门的基本块来表示</p><h2 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h2><p>每一条pass只计算一件事或以某种特定的方式转换代码，GCC会不断地对代码做各种变换，逐渐使代码向汇编代码靠近。每次变换可能只会转化一种类型的pattern，叫做一个pass。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gcc-plugin.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;plugin-version.h&quot;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tree-pass.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;context.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;basic-block.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gimple-pretty-print.h&quot;</span></span><br><span class="hljs-keyword">int</span> plugin_is_GPL_compatible;<br> <br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">plugin_info</span> <span class="hljs-title">my_gcc_plugin_info</span> =</span><br>&#123; <span class="hljs-string">&quot;1.0&quot;</span>, <span class="hljs-string">&quot;This is a very simple plugin&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><p>plugin_init部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">plugin_init</span><span class="hljs-params">(struct plugin_name_args *plugin_info,struct plugin_gcc_version *version)</span></span><br><span class="hljs-function"></span>&#123;<br>  register_callback(plugin_info-&gt;base_name,<br>                    <span class="hljs-comment">/* event */</span> PLUGIN_INFO,<span class="hljs-comment">//何时执行callback</span><br>                    <span class="hljs-comment">/* callback */</span> <span class="hljs-literal">NULL</span>,<span class="hljs-comment">//要执行的callback</span><br>                    <span class="hljs-comment">/* user_data */</span><br>                    &amp;my_gcc_plugin_info);<span class="hljs-comment">//callback收到的第二个参数</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">register_pass_info</span> <span class="hljs-title">pass_info</span>;</span><br>  pass_info.pass = <span class="hljs-keyword">new</span> my_first_gcc(g);<span class="hljs-comment">//创建pass实例</span><br>  pass_info.reference_pass_name = <span class="hljs-string">&quot;cfg&quot;</span>;<span class="hljs-comment">//cfg pass的目的：创建控制流图</span><br>  pass_info.ref_pass_instance_number = <span class="hljs-number">1</span>;<br>  pass_info.pos_op = PASS_POS_INSERT_AFTER;<br>  register_callback(plugin_info-&gt;base_name,PLUGIN_PASS_MANAGER_SETUP,<span class="hljs-literal">NULL</span>,&amp;pass_info);<span class="hljs-comment">//注册一个新的pass</span><br>  register_callback(plugin_info-&gt;base_name, PLUGIN_FINISH, finish_gcc, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//回掉函数，用来结束图形</span><br>  start_graph();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于start_graph()和finish_gcc()函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">namespace</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start_graph</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span>&lt;&lt;<span class="hljs-string">&quot;digraph cfg &#123;\n&quot;</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">end_graph</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span>&lt;&lt; <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finish_gcc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *gcc_data, <span class="hljs-keyword">void</span> *user_data)</span></span><br><span class="hljs-function">  </span>&#123;<br>    end_graph();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>pass被表示为一个继承自GCC类opt_pass的类。因为我们的类将在GIMPLE上工作，所以它将继承gimple_opt_pass:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_fisrt_pass</span>:</span>gimple_opt_pass<br>&#123;<br>my_first_pass(gcc::context * ctx):gimple_opt_pass(my_first_pass_data,ctx)<br>&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>pass_data定义了一些pass的属性，在类使用之前定义它并把它传给gimple_opt_pass的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">namespace</span> &#123;<br><span class="hljs-keyword">const</span> pass_data my_first_pass_data =<br>&#123;<br>  GIMPLE_PASS,<br>  <span class="hljs-string">&quot;my_first_pass&quot;</span>,<span class="hljs-comment">/* 名字 */</span><br>  OPTGROUP_NONE,<span class="hljs-comment">/* optinfo_flags */</span><br>  TV_NONE,<span class="hljs-comment">/* id */</span><br>  PROP_gimple_any,<span class="hljs-comment">/* properties_required */</span><br>  <span class="hljs-number">0</span>,<span class="hljs-comment">/* properties_provided */</span><br>  <span class="hljs-number">0</span>,<span class="hljs-comment">/* properties_destroyed */</span><br>  <span class="hljs-number">0</span>,<span class="hljs-comment">/* todo_flags_start */</span><br>  <span class="hljs-number">0</span><span class="hljs-comment">/* todo_flags_finish */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>pass的虚函数execute将在每个函数被编译时被调用，该函数本身作为函数类型的指针接收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">(function *fun)</span><span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>  basic_block bb;<span class="hljs-comment">//定义基本块</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span>&lt;&lt; <span class="hljs-string">&quot;subgraph fun_&quot;</span> &lt;&lt; fun &lt;&lt; <span class="hljs-string">&quot; &#123;\n&quot;</span>;<br>  FOR_ALL_BB_FN(bb,fun)<span class="hljs-comment">//迭代函数fun的所有基本块bb</span><br>  &#123;<br>  gimple_bb_info *bb_info = &amp;bb-&gt;il.gimple;<span class="hljs-comment">//定义基本块信息的对象</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;bb_&quot;</span> &lt;&lt; fun &lt;&lt; <span class="hljs-string">&quot;_&quot;</span> &lt;&lt; bb-&gt;index &lt;&lt; <span class="hljs-string">&quot;[label=\&quot;&quot;</span>;<br>  <span class="hljs-keyword">if</span> (bb-&gt;index == <span class="hljs-number">0</span>)<span class="hljs-comment">//基本块index=0代表函数入口</span><br>    &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;ENTRY: &quot;</span><br>                &lt;&lt; function_name(fun) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>                &lt;&lt; (LOCATION_FILE(fun-&gt;function_start_locus) ? : <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>)<br>                &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; LOCATION_LINE(fun-&gt;function_start_locus);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bb-&gt;index == <span class="hljs-number">1</span>)<span class="hljs-comment">//基本块index=1代表函数出口</span><br>    &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;EXIT: &quot;</span><br>                &lt;&lt; function_name(fun) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>                &lt;&lt; (LOCATION_FILE(fun-&gt;function_end_locus) ? : <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>) &lt;&lt;<br>                <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; LOCATION_LINE(fun-&gt;function_end_locus);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      print_gimple_seq(<span class="hljs-built_in">stderr</span>, bb_info-&gt;seq, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//输出gimple序列</span><br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;\&quot;];\n&quot;</span>;<br>    edge e;<span class="hljs-comment">//定义基本块的边</span><br>    edge_iterator ei;<span class="hljs-comment">//定义边的迭代器</span><br>    FOR_EACH_EDGE(e, ei, bb-&gt;succs)<br>    &#123;<br>      basic_block dest = e-&gt;dest;<br>      <span class="hljs-built_in">std</span>::<br>      <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;bb_&quot;</span> &lt;&lt; fun &lt;&lt; <span class="hljs-string">&quot;_&quot;</span> &lt;&lt; bb-&gt;index &lt;&lt; <span class="hljs-string">&quot; -&gt; bb_&quot;</span> &lt;&lt; fun &lt;&lt;<br>           <span class="hljs-string">&quot;_&quot;</span> &lt;&lt; dest-&gt;index &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>pass类仍然需要一个方法，这里给出其伪实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">virtual</span> my_first_pass *<span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// We do not clone ourselves</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整的插件代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// This is the first gcc header to be included</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gcc-plugin.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;plugin-version.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tree-pass.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;context.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;basic-block.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gimple-pretty-print.h&quot;</span></span><br><br><span class="hljs-comment">// We must assert that this plugin is GPL compatible</span><br><span class="hljs-keyword">int</span> plugin_is_GPL_compatible;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">plugin_info</span> <span class="hljs-title">my_gcc_plugin_info</span> =</span><br>&#123; <span class="hljs-string">&quot;1.0&quot;</span>, <span class="hljs-string">&quot;This is a very simple plugin&quot;</span> &#125;;<br><br><span class="hljs-keyword">namespace</span> &#123;<br><span class="hljs-keyword">const</span> pass_data my_first_pass_data =<br>&#123;<br>  GIMPLE_PASS,<br>  <span class="hljs-string">&quot;my_first_pass&quot;</span>, <span class="hljs-comment">/* name */</span><br>  OPTGROUP_NONE, <span class="hljs-comment">/* optinfo_flags */</span><br>  TV_NONE, <span class="hljs-comment">/* tv_id */</span><br>  PROP_gimple_any, <span class="hljs-comment">/* properties_required */</span><br>  <span class="hljs-number">0</span>, <span class="hljs-comment">/* properties_provided */</span><br>  <span class="hljs-number">0</span>, <span class="hljs-comment">/* properties_destroyed */</span><br>  <span class="hljs-number">0</span>, <span class="hljs-comment">/* todo_flags_start */</span><br>  <span class="hljs-number">0</span> <span class="hljs-comment">/* todo_flags_finish */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_first_pass</span> :</span> gimple_opt_pass<br>&#123;<br>  my_first_pass(gcc::context * ctx):gimple_opt_pass(my_first_pass_data, ctx)<br>  &#123;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">(function * fun)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">  </span>&#123;<br>    basic_block bb;<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;subgraph fun_&quot;</span> &lt;&lt; fun &lt;&lt; <span class="hljs-string">&quot; &#123;\n&quot;</span>;<br><br>    FOR_ALL_BB_FN(bb, fun)<br>    &#123;<br>      gimple_bb_info *bb_info = &amp;bb-&gt;il.gimple;<br><br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;bb_&quot;</span> &lt;&lt; fun &lt;&lt; <span class="hljs-string">&quot;_&quot;</span> &lt;&lt; bb-&gt;index &lt;&lt; <span class="hljs-string">&quot;[label=\&quot;&quot;</span>;<br>      <span class="hljs-keyword">if</span>(bb-&gt;index == <span class="hljs-number">0</span>)<br>      &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;ENTRY: &quot;</span><br>                  &lt;&lt; function_name(fun) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>                  &lt;&lt; (LOCATION_FILE(fun-&gt;function_start_locus) ? : <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>)<br>                  &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; LOCATION_LINE(fun-&gt;function_start_locus);<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bb-&gt;index == <span class="hljs-number">1</span>)<br>      &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;EXIT: &quot;</span><br>                  &lt;&lt; function_name(fun) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>                  &lt;&lt; (LOCATION_FILE(fun-&gt;function_end_locus) ? : <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>) &lt;&lt;<br>                  <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; LOCATION_LINE(fun-&gt;function_end_locus);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        print_gimple_seq(<span class="hljs-built_in">stderr</span>, bb_info-&gt;seq, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>      &#125;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;\&quot;];\n&quot;</span>;<br><br>      edge e;<br>      edge_iterator ei;<br><br>      FOR_EACH_EDGE(e, ei, bb-&gt;succs)<br>      &#123;<br>        basic_block dest = e-&gt;dest;<br>        <span class="hljs-built_in">std</span>::<br>        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;bb_&quot;</span> &lt;&lt; fun &lt;&lt; <span class="hljs-string">&quot;_&quot;</span> &lt;&lt; bb-&gt;index &lt;&lt; <span class="hljs-string">&quot; -&gt; bb_&quot;</span> &lt;&lt; fun &lt;&lt;<br>             <span class="hljs-string">&quot;_&quot;</span> &lt;&lt; dest-&gt;index &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br><br>    <span class="hljs-comment">// Nothing special todo</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> my_first_pass *<span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// We do not clone ourselves</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">namespace</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start_graph</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;digraph cfg &#123;\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">end_graph</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">finish_gcc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *gcc_data, <span class="hljs-keyword">void</span> *user_data)</span></span><br><span class="hljs-function"></span>&#123;<br> end_graph();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">plugin_init</span><span class="hljs-params">(struct plugin_name_args *plugin_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                struct plugin_gcc_version *version)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(!plugin_default_version_check(version, &amp;gcc_version))<br>  &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;This GCC plugin is for version &quot;</span> &lt;&lt; GCCPLUGIN_VERSION_MAJOR<br>              &lt;&lt; <span class="hljs-string">&quot;.&quot;</span> &lt;&lt; GCCPLUGIN_VERSION_MINOR &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  register_callback(plugin_info-&gt;base_name,<br>                    <span class="hljs-comment">/* event */</span> PLUGIN_INFO,<br>                    <span class="hljs-comment">/* callback */</span> <span class="hljs-literal">NULL</span>,<br>                    <span class="hljs-comment">/* user_data */</span><br>                    &amp;my_gcc_plugin_info);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">register_pass_info</span> <span class="hljs-title">pass_info</span>;</span><br>  pass_info.pass = <span class="hljs-keyword">new</span> my_first_pass(g);<br>  pass_info.reference_pass_name = <span class="hljs-string">&quot;cfg&quot;</span>;<br>  pass_info.ref_pass_instance_number = <span class="hljs-number">1</span>;<br>  pass_info.pos_op = PASS_POS_INSERT_AFTER;<br>  register_callback(plugin_info-&gt;base_name, PLUGIN_PASS_MANAGER_SETUP, <span class="hljs-literal">NULL</span>,<br>                    &amp;pass_info);<br>  register_callback(plugin_info-&gt;base_name, PLUGIN_FINISH, finish_gcc, <span class="hljs-literal">NULL</span>);<br>  start_graph();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fizz</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buzz</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fizzbuzz</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_number</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-keyword">bool</span> div_3 = i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">bool</span> div_5 = i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BITMAP2(x, y) ((x) | ((y) &lt;&lt; 1))</span><br><br>        <span class="hljs-keyword">switch</span> (BITMAP2(div_3, div_5))<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">BITMAP2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>: <span class="hljs-comment">// 3</span></span><br><span class="hljs-function">                <span class="hljs-title">fizz</span><span class="hljs-params">()</span></span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">BITMAP2</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</span>: <span class="hljs-comment">// 5</span></span><br><span class="hljs-function">                <span class="hljs-title">buzz</span><span class="hljs-params">()</span></span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-function"><span class="hljs-keyword">case</span> <span class="hljs-title">BITMAP2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span>: <span class="hljs-comment">// 15</span></span><br><span class="hljs-function">                <span class="hljs-title">fizzbuzz</span><span class="hljs-params">()</span></span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                print_number(i);<br>        &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> BITMAP2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo 2"></a>Demo 2</h2><blockquote><p>实现一个检测函数返回值是否被使用的plugin</p></blockquote><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>在上一个demo中涉及到一个gcc的中间表示：gimple。</p><blockquote><p>GIMPLE_ASSIGNMENT类型的语句用于表示类似以下语句的语句：</p><ul><li>a = b ⊕ c</li><li>a = b</li></ul><blockquote><p>这里的⊕代表着一个二进制运算，比如加法、减法、乘法等等。</p><p>第二种形式a = b;对应于值的副本。操作数b和c称为赋值的右侧(RHS)，而操作数a称为赋值的左侧(LHS)。</p></blockquote><p>GIMPLE_CALL类型的语句也表示对两种形式的调用:</p><ul><li>a = F(x0,x1,x2…..xn)</li><li>F(x0,x1,x2….xn)</li></ul></blockquote><ul><li>第一步，将收集位于函数语句左侧的人工声明的变量，并将它们放入到一个集合里</li><li>第二步，将再次遍历代码，并对函数返回未使用值并使用属性warn_unused_result标记函数的所有位置发出诊断信号。这种策略可以改进，但作为一个开始可能就足够了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">namespace</span>&#123;<br>  <span class="hljs-keyword">const</span> pass_data warn_unused_result_cxx_data = &#123;<br>    GIMPLE_PASS,<br>  <span class="hljs-string">&quot;warn_unused_result_cxx&quot;</span>, <span class="hljs-comment">/* name */</span><br>  OPTGROUP_NONE,             <span class="hljs-comment">/* optinfo_flags */</span><br>  TV_NONE,                   <span class="hljs-comment">/* tv_id */</span><br>  PROP_gimple_any,           <span class="hljs-comment">/* properties_required */</span><br>  <span class="hljs-number">0</span>,                         <span class="hljs-comment">/* properties_provided */</span><br>  <span class="hljs-number">0</span>,                         <span class="hljs-comment">/* properties_destroyed */</span><br>  <span class="hljs-number">0</span>,                         <span class="hljs-comment">/* todo_flags_start */</span><br>  <span class="hljs-number">0</span>                          <span class="hljs-comment">/* todo_flags_finish */</span><br>  &#125;<br>  struct warn_unused_result_cxx:gimple_opt_pass<br>  &#123;<br>  warn_unused_result_cxx(gcc::context *ctx):gimple_opt_pass(warn_unused_result_cxx_data,ctx)<br>  &#123;<br>  &#125;<br>  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> execute(function *fun)<span class="hljs-keyword">override</span><br>  &#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;tree&gt; unused_lhs = gather_unused_lhs(fun);<span class="hljs-comment">//寻找未使用的函数返回值</span><br>    warn_unused_result_lhs(unused_lhs, fun);<span class="hljs-comment">//发送警告信息</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> warn_unused_result_cxx* <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>  &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>gather_unused_lhs实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;tree&gt; <span class="hljs-title">gather_unused_lhs</span><span class="hljs-params">(function* fun)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;tree&gt; potential_unused_lhs;<br>  basic_block bb;<br>  FOR_ALL_BB_FN(bb,fun)<span class="hljs-comment">//遍历函数基本块</span><br>  &#123;<br>    gimple_stmt_iterator gsi;<span class="hljs-comment">//创建迭代器迭代gimple语句</span><br>    <span class="hljs-keyword">for</span>(gsi = gsi_start_bb(b);!gsi_end_p(gsi);gsi_next(&amp;gsi))<br>    &#123;<br>      gimple stmt = gsi_stmt(gsi);<br>      <span class="hljs-keyword">switch</span>(gimple_code(stmt))<br>      &#123;<br>        <span class="hljs-keyword">case</span> GIMPLE_CALL:<span class="hljs-comment">//发现是函数调用</span><br>          &#123;<br>            tree lhs = gimple_call_lhs(stmt);<br>            insert_potentially_unused_lhs(potential_unused_lhs, lhs);<br>            <span class="hljs-keyword">unsigned</span> nargs = gimple_call_num_args(stmt);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>;i &lt; nargs;i++)<br>            &#123;<br>              tree arg = gimple_call_arg(stmt,i);<br>              erase_if_used_lhs(potential_unused_lhs,arg);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        <span class="hljs-keyword">case</span> GIMPLE_ASSIGN:<span class="hljs-comment">//发现是赋值操作</span><br>          &#123;<br>            tree lhs = gimple_assign_lhs(stmt);<span class="hljs-comment">//检查左操作数</span><br>            erase_if_used_lhs(potential_unused_lhs, lhs);<br>            tree rhs1 = gimple_assign_rhs1(stmt);<span class="hljs-comment">//检查右边三个操作数</span><br>            erase_if_used_lhs(potential_unused_lhs, rhs1);<span class="hljs-comment">//如果被使用则将其从集合中删除</span><br>            tree rhs2 = gimple_assign_rhs2(stmt);<br>            <span class="hljs-keyword">if</span> (rhs2 != <span class="hljs-literal">NULL</span>)<br>              erase_if_used_lhs(potential_unused_lhs, rhs2);<br>          tree rhs3 = gimple_assign_rhs3(stmt);<br>            <span class="hljs-keyword">if</span> (rhs3 != <span class="hljs-literal">NULL</span>)<br>              erase_if_used_lhs(potential_unused_lhs, rhs3);<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入集合函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert_potentially_unused_lhs</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;tree&gt;&amp; potential_unused_lhs,tree t)</span><span class="hljs-comment">//potential_unused_lhs是一组树</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  注意，gimple语句不是树，但是gimple的操作数是树，因此当我们请求gimple_call的左侧的时候，我们可以得到一个树</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//如果左树为空</span><br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (TREE_CODE(t) == VAR_DECL &amp;&amp; DECL_ARTIFICIAL(t))<span class="hljs-comment">//使用宏DECL_ARTIFICIAL来验证它是否是编译器创建的一个人工变量</span><br>  &#123;<br>    potential_unused_lhs.insert(t);<span class="hljs-comment">//插入</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">erase_if_used_lhs</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;tree&gt;&amp; potential_unused_lhs,tree t)</span><span class="hljs-comment">//如果变量声明被使用，则从集合中将其删除</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span>;<br> <br>  <span class="hljs-keyword">switch</span> (TREE_CODE(t))<br>  &#123;<br>    <span class="hljs-keyword">case</span> VAR_DECL:<span class="hljs-comment">//t存储了一个声明了的变量</span><br>      <span class="hljs-keyword">if</span> (DECL_ARTIFICIAL(t) &amp;&amp; potential_unused_lhs.find(t) != potential_unused_lhs.end())<span class="hljs-comment">//如果该变量是一个人工变量并且恰好在集合中</span><br>      &#123;<br>        potential_unused_lhs.erase(t);<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> COMPONENT_REF:<br>      erase_if_used_lhs(potential_unused_lhs, TREE_OPERAND(t, <span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>提交警告信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">warn_unused_result_lhs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;tree&gt;&amp; unused_lhs, function *fun)</span></span><br><span class="hljs-function"></span>&#123;<br>  basic_block bb;<br>  FOR_ALL_BB_FN(bb, fun)<br>  &#123;<br>    gimple_stmt_iterator gsi;<br>    <span class="hljs-keyword">for</span> (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))<br>    &#123;<br>      gimple stmt = gsi_stmt (gsi);<br>      <span class="hljs-keyword">switch</span> (gimple_code(stmt))<br>      &#123;<br>        <span class="hljs-keyword">case</span> GIMPLE_CALL:<br>          &#123;<br>            tree lhs = gimple_call_lhs(stmt);<span class="hljs-comment">//获取函数调用的左侧</span><br>            <span class="hljs-keyword">if</span> (unused_lhs.find(lhs) != unused_lhs.end())<span class="hljs-comment">//如果该变量在集合中</span><br>            &#123;<br>              tree fdecl = gimple_call_fndecl (stmt);<span class="hljs-comment">//函数声明</span><br>              tree ftype = gimple_call_fntype (stmt);<span class="hljs-comment">//函数调用类型</span><br>              <span class="hljs-keyword">if</span> (lookup_attribute (<span class="hljs-string">&quot;warn_unused_result&quot;</span>, TYPE_ATTRIBUTES (ftype)))<br>              &#123;<span class="hljs-comment">//查询是否具有warn-unused_result的属性</span><br>                <span class="hljs-keyword">location_t</span> loc = gimple_location (stmt);<span class="hljs-comment">//声明位置</span><br>                <span class="hljs-keyword">if</span> (fdecl)<br>                  warning_at (loc, OPT_Wunused_result,<br>                      <span class="hljs-string">&quot;ignoring return value of %qD, &quot;</span><br>                      <span class="hljs-string">&quot;declared with attribute warn_unused_result&quot;</span>,<br>                      fdecl);<br>                <span class="hljs-keyword">else</span><br>                  warning_at (loc, OPT_Wunused_result,<br>                      <span class="hljs-string">&quot;ignoring return value of function &quot;</span><br>                      <span class="hljs-string">&quot;declared with attribute warn_unused_result&quot;</span>);<br>              &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        <span class="hljs-keyword">default</span>:<br>          <span class="hljs-comment">// Do nothing</span><br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整的插件代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// This is the first gcc header to be included</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gcc-plugin.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;plugin-version.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;cp/cp-tree.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;context.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;function.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;internal-fn.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;is-a.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;predict.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;basic-block.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tree.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tree-ssa-alias.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gimple-expr.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gimple.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gimple-ssa.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tree-pretty-print.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tree-pass.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tree-ssa-operands.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;tree-phinodes.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gimple-pretty-print.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gimple-iterator.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;gimple-walk.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;diagnostic.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stringpool.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ssa-iterators.h&quot;</span></span><br><br><span class="hljs-comment">// We must assert that this plugin is GPL compatible</span><br><span class="hljs-keyword">int</span> plugin_is_GPL_compatible;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">plugin_info</span> <span class="hljs-title">my_gcc_plugin_info</span> =</span> &#123; <span class="hljs-string">&quot;1.0&quot;</span>, <span class="hljs-string">&quot;This plugin emits warn_unused_result for C++&quot;</span> &#125;;<br><br><span class="hljs-keyword">namespace</span><br>&#123;<br>    <span class="hljs-keyword">const</span> pass_data warn_unused_result_cxx_data = <br>    &#123;<br>        GIMPLE_PASS,<br>        <span class="hljs-string">&quot;warn_unused_result_cxx&quot;</span>, <span class="hljs-comment">/* name */</span><br>        OPTGROUP_NONE,             <span class="hljs-comment">/* optinfo_flags */</span><br>        TV_NONE,                   <span class="hljs-comment">/* tv_id */</span><br>        PROP_gimple_any,           <span class="hljs-comment">/* properties_required */</span><br>        <span class="hljs-number">0</span>,                         <span class="hljs-comment">/* properties_provided */</span><br>        <span class="hljs-number">0</span>,                         <span class="hljs-comment">/* properties_destroyed */</span><br>        <span class="hljs-number">0</span>,                         <span class="hljs-comment">/* todo_flags_start */</span><br>        <span class="hljs-number">0</span>                          <span class="hljs-comment">/* todo_flags_finish */</span><br>    &#125;;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">warn_unused_result_cxx</span> :</span> gimple_opt_pass<br>    &#123;<br>        warn_unused_result_cxx(gcc::context *ctx)<br>            : gimple_opt_pass(warn_unused_result_cxx_data, ctx)<br>        &#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">(function *fun)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">// This phase has two steps, first we remove redundant LHS from GIMPLE_CALLs</span><br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;tree&gt; unused_lhs = gather_unused_lhs(fun);<br>            warn_unused_result_lhs(unused_lhs, fun);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> warn_unused_result_cxx* <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">// We do not clone ourselves</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert_potentially_unused_lhs</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;tree&gt;&amp; potential_unused_lhs,</span></span><br><span class="hljs-params"><span class="hljs-function">                tree t)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>)<br>                <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-keyword">if</span> (TREE_CODE(t) == VAR_DECL<br>                    &amp;&amp; DECL_ARTIFICIAL(t))<br>            &#123;<br>                potential_unused_lhs.insert(t);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">erase_if_used_lhs</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;tree&gt;&amp; potential_unused_lhs,</span></span><br><span class="hljs-params"><span class="hljs-function">                tree t,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">location_t</span> l)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">NULL</span>)<br>                <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-keyword">switch</span> (TREE_CODE(t))<br>            &#123;<br>                <span class="hljs-keyword">case</span> VAR_DECL:<br>                    <span class="hljs-keyword">if</span> (DECL_ARTIFICIAL(t)<br>                            &amp;&amp; potential_unused_lhs.find(t) != potential_unused_lhs.end())<br>                    &#123;<br>                        potential_unused_lhs.erase(t);<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> COMPONENT_REF:<br>                    erase_if_used_lhs(potential_unused_lhs, TREE_OPERAND(t, <span class="hljs-number">0</span>), l);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    &#123;<br>                        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> are there more cases?</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;tree&gt; <span class="hljs-title">gather_unused_lhs</span><span class="hljs-params">(function* fun)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;tree&gt; potential_unused_lhs;<br><br>            basic_block bb;<br>            FOR_ALL_BB_FN(bb, fun)<br>            &#123;<br>                gimple_stmt_iterator gsi;<br>                <span class="hljs-keyword">for</span> (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))<br>                &#123;<br>                    gimple stmt = gsi_stmt (gsi);<br><br>                    <span class="hljs-keyword">location_t</span> loc = gimple_location (stmt);<br>                    <span class="hljs-keyword">switch</span> (gimple_code(stmt))<br>                    &#123;<br>                        <span class="hljs-keyword">case</span> GIMPLE_CALL:<br>                            &#123;<br>                                tree lhs = gimple_call_lhs(stmt);<br>                                insert_potentially_unused_lhs(potential_unused_lhs, lhs);<br><br>                                <span class="hljs-keyword">unsigned</span> nargs = gimple_call_num_args(stmt);<br>                                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; nargs; i++)<br>                                &#123;<br>                                    tree arg = gimple_call_arg(stmt, i);<br>                                    erase_if_used_lhs(potential_unused_lhs, arg, loc);<br>                                &#125;<br>                                <span class="hljs-keyword">break</span>;<br><br>                            &#125;<br>                        <span class="hljs-keyword">case</span> GIMPLE_ASSIGN:<br>                            &#123;<br>                                tree lhs = gimple_assign_lhs(stmt);<br>                                erase_if_used_lhs(potential_unused_lhs, lhs, loc);<br><br>                                tree rhs1 = gimple_assign_rhs1(stmt);<br>                                erase_if_used_lhs(potential_unused_lhs, rhs1, loc);<br><br>                                tree rhs2 = gimple_assign_rhs2(stmt);<br>                                <span class="hljs-keyword">if</span> (rhs2 != <span class="hljs-literal">NULL</span>)<br>                                    erase_if_used_lhs(potential_unused_lhs, rhs2, loc);<br><br>                                tree rhs3 = gimple_assign_rhs3(stmt);<br>                                <span class="hljs-keyword">if</span> (rhs3 != <span class="hljs-literal">NULL</span>)<br>                                    erase_if_used_lhs(potential_unused_lhs, rhs3, loc);<br><br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        <span class="hljs-keyword">case</span> GIMPLE_ASM:<br>                        <span class="hljs-keyword">case</span> GIMPLE_COND:<br>                        <span class="hljs-keyword">case</span> GIMPLE_GOTO:<br>                        <span class="hljs-keyword">case</span> GIMPLE_LABEL:<br>                        <span class="hljs-keyword">case</span> GIMPLE_NOP:<br>                        <span class="hljs-keyword">case</span> GIMPLE_OMP_ATOMIC_LOAD :<br>                        <span class="hljs-keyword">case</span> GIMPLE_OMP_ATOMIC_STORE :<br>                        <span class="hljs-keyword">case</span> GIMPLE_OMP_CONTINUE :<br>                        <span class="hljs-keyword">case</span> GIMPLE_OMP_CRITICAL :<br>                        <span class="hljs-keyword">case</span> GIMPLE_OMP_FOR :<br>                        <span class="hljs-keyword">case</span> GIMPLE_OMP_MASTER :<br>                        <span class="hljs-keyword">case</span> GIMPLE_OMP_ORDERED :<br>                        <span class="hljs-keyword">case</span> GIMPLE_OMP_PARALLEL :<br>                        <span class="hljs-keyword">case</span> GIMPLE_OMP_RETURN :<br>                        <span class="hljs-keyword">case</span> GIMPLE_OMP_SECTION :<br>                        <span class="hljs-keyword">case</span> GIMPLE_OMP_SECTIONS :<br>                        <span class="hljs-keyword">case</span> GIMPLE_OMP_SECTIONS_SWITCH :<br>                        <span class="hljs-keyword">case</span> GIMPLE_OMP_SINGLE :<br>                        <span class="hljs-keyword">case</span> GIMPLE_PHI :<br>                        <span class="hljs-keyword">case</span> GIMPLE_RESX :<br>                        <span class="hljs-keyword">case</span> GIMPLE_RETURN :<br>                        <span class="hljs-keyword">case</span> GIMPLE_SWITCH :<br>                            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> complete the remaining trees</span><br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">default</span>:<br>                            gcc_unreachable();<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;tree&gt; <span class="hljs-title">unused_lhs</span><span class="hljs-params">( potential_unused_lhs)</span></span>;<br>            <span class="hljs-keyword">return</span> unused_lhs;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">warn_unused_result_lhs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;tree&gt;&amp; unused_lhs, function *fun)</span></span><br><span class="hljs-function">        </span>&#123;<br>            basic_block bb;<br>            FOR_ALL_BB_FN(bb, fun)<br>            &#123;<br>                gimple_stmt_iterator gsi;<br>                <span class="hljs-keyword">for</span> (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))<br>                &#123;<br>                    gimple stmt = gsi_stmt (gsi);<br><br>                    <span class="hljs-keyword">switch</span> (gimple_code(stmt))<br>                    &#123;<br>                        <span class="hljs-keyword">case</span> GIMPLE_CALL:<br>                            &#123;<br>                                tree lhs = gimple_call_lhs(stmt);<br>                                <span class="hljs-keyword">if</span> (unused_lhs.find(lhs) != unused_lhs.end())<br>                                &#123;<br>                                    <span class="hljs-comment">// Deliberately similar to the code in tree-cfg.c</span><br>                                    tree fdecl = gimple_call_fndecl (stmt);<br>                                    tree ftype = gimple_call_fntype (stmt);<br><br>                                    <span class="hljs-keyword">if</span> (lookup_attribute (<span class="hljs-string">&quot;warn_unused_result&quot;</span>, TYPE_ATTRIBUTES (ftype)))<br>                                    &#123;<br>                                        <span class="hljs-keyword">location_t</span> loc = gimple_location (stmt);<br><br>                                        <span class="hljs-keyword">if</span> (fdecl)<br>                                            warning_at (loc, OPT_Wunused_result,<br>                                                    <span class="hljs-string">&quot;ignoring return value of %qD, &quot;</span><br>                                                    <span class="hljs-string">&quot;declared with attribute warn_unused_result&quot;</span>,<br>                                                    fdecl);<br>                                        <span class="hljs-keyword">else</span><br>                                            warning_at (loc, OPT_Wunused_result,<br>                                                    <span class="hljs-string">&quot;ignoring return value of function &quot;</span><br>                                                    <span class="hljs-string">&quot;declared with attribute warn_unused_result&quot;</span>);<br>                                    &#125;<br>                                &#125;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        <span class="hljs-keyword">default</span>:<br>                            <span class="hljs-comment">// Do nothing</span><br>                            <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">plugin_init</span> <span class="hljs-params">(struct plugin_name_args *plugin_info,</span></span><br><span class="hljs-params"><span class="hljs-function">        struct plugin_gcc_version *version)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// We check the current gcc loading this plugin against the gcc we used to</span><br>    <span class="hljs-comment">// created this plugin</span><br>    <span class="hljs-keyword">if</span> (!plugin_default_version_check (version, &amp;gcc_version))<br>    &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;This GCC plugin is for version &quot;</span> &lt;&lt; GCCPLUGIN_VERSION_MAJOR &lt;&lt; <span class="hljs-string">&quot;.&quot;</span> &lt;&lt; GCCPLUGIN_VERSION_MINOR &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    register_callback(plugin_info-&gt;base_name,<br>            <span class="hljs-comment">/* event */</span> PLUGIN_INFO,<br>            <span class="hljs-comment">/* callback */</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">/* user_data */</span> &amp;my_gcc_plugin_info);<br><br>    <span class="hljs-comment">// Register the phase right after cfg</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">register_pass_info</span> <span class="hljs-title">pass_info</span>;</span><br><br>    pass_info.pass = <span class="hljs-keyword">new</span> warn_unused_result_cxx(g);<br>    pass_info.reference_pass_name = <span class="hljs-string">&quot;cfg&quot;</span>;<br>    pass_info.ref_pass_instance_number = <span class="hljs-number">1</span>;<br>    pass_info.pos_op = PASS_POS_INSERT_AFTER;<br><br>    register_callback (plugin_info-&gt;base_name, PLUGIN_PASS_MANAGER_SETUP, <span class="hljs-literal">NULL</span>, &amp;pass_info);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> x, y;<br>&#125; A;<br><br>__attribute__((warn_unused_result)) <span class="hljs-function">A <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-keyword">const</span> A&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    foo(); <span class="hljs-comment">// OK to diagnose</span><br><br>    h(foo()); <span class="hljs-comment">// ERROR: do not diagnose</span><br><br>    <span class="hljs-keyword">int</span> z = foo().y; <span class="hljs-comment">// ERROR: do not diagnose</span><br><br>    foo().y; <span class="hljs-comment">// arguable but OK</span><br><br>    m(foo().y); <span class="hljs-comment">// ERROR: do not diagnose</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>    ~B();<br>&#125;;<br><br>__attribute__((warn_unused_result)) <span class="hljs-function">B <span class="hljs-title">bar</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_bar</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    bar(); <span class="hljs-comment">// ERROR: do not diagnose</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ptmalloc解析</title>
    <link href="/2020/01/19/2019-02-07-Glibc-ptmalloc/"/>
    <url>/2020/01/19/2019-02-07-Glibc-ptmalloc/</url>
    
    <content type="html"><![CDATA[<blockquote><p>ptmalloc是glibc中内置分配器的原型，稍稍总结一下ptmalloc的原理以及常见的利用思路</p></blockquote><h2 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h2><p>从微观角度来看，堆有以下几种操作：</p><ul><li>申请内存</li><li>释放内存</li></ul><h3 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h3><p>本质上来讲，ptmalloc来申请内存，其实主要是执行以下过程。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cs2hk7bpj30ch0czjrp.jpg" alt=""></p><p>对于使用mmap还是<code>_brk</code>，ptmalloc有自己的规则，默认情况下当申请的内存小于128kb时，使用<code>_brk</code>，当申请的内存大小大于128kb时，ptmalloc使用mmap来申请内存。</p><h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><p>ptmalloc使用free函数来释放内存。free 函数会释放由free函数的参数所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p><p>此外，该函数也同样对异常情况进行了处理</p><ul><li>当 p 为空指针时，函数不执行任何操作。</li><li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li><li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</li></ul><h2 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h2><h3 id="chunk结构"><a href="#chunk结构" class="headerlink" title="chunk结构"></a>chunk结构</h3><p>在ptmalloc中最基本的分配单位是chunk块，其结构如下所示：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span> &#123;<br><br>  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  前一块为释放状态时的大小 */</span><br>  INTERNAL_SIZE_T      mchunk_size;       <span class="hljs-comment">/* Size in bytes, including overhead. 大小，以字节为单位，包括额外内容 */</span><br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* fd;         <span class="hljs-comment">/* double links -- used only if free. 双链表，只在为释放状态是使用 */</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* bk;<br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-comment">/* 只在large块时使用：指向下一个更大大小的指针 */</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* fd_nextsize; <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* bk_nextsize;<br>&#125;;<br></code></pre></td></tr></table></figure><p>直观来说是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9crel4vhzj30kd06275t.jpg" alt=""></p><blockquote><p> 注：</p><ul><li>chunk的第二个域的最低一位P表示前一个chunk是否是在使用当中（0代表前一个空闲，1代表在使用当中）。当P为0时，此时prev_size才有效，第一个域表示的是前一个chunk的size，可以通过这个值取到前一个chunk的开始地址；当P为1时，表示前一个chunk在使用当中，prev_size无效。<br>ptmalloc分配的第一个chunk总是将P设为1，以防止程序引用到不存在的区域。</li><li>chunk第二个域倒数第二位M（0表示是从mmap映射区域分配的，1表示heap区域分配）</li><li>chunk第二个域倒数第三位A（1表示主分配区，0非主分配区）</li></ul></blockquote><h3 id="管理结构"><a href="#管理结构" class="headerlink" title="管理结构"></a>管理结构</h3><p>ptmalloc在申请那么多个chunk之后为了效率，使用了自己本身的特殊结构来对其进行管理，也就是bins和fastbin等。</p><h4 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h4><p>直观来看，看下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cs74wi7dj30lo0awt9o.jpg" alt=""></p><p>所以说所谓的bins其实是一个大数组，bins数组总共分为三种：<strong>unsorted bin</strong>、<strong>small bin</strong>、<strong>large bin</strong>。</p><p>不同的bins内存储的chunk、存储规则、自身特性都是不一样的。</p><h5 id="unsorted-bins"><a href="#unsorted-bins" class="headerlink" title="unsorted bins"></a>unsorted bins</h5><p>作为bins数组中的第一部分，unsorted bin是一个遵循<strong>先进先出原则</strong>的双向链表，且其中存放的chunk是一个乱序状态（也就是说unsorted bin中的chunk的排序与chunk的属性如size、prev_size无关）。</p><p>unsorted bin中chunk的来源：</p><ul><li>一个较大的chunk A，A被分割成两半，如果剩下的部分&gt;MIN_SIZE，则这部分会被放进unsorted bin中</li><li>释放一个不属于fast bins的chunk且该chunk与top chunk相隔（top chunk待会讲）的时候，该chunk会被首先放进unsorted bin中</li></ul><p><strong>unsorted bin在内存分配中充当的角色</strong>：在进行 malloc 操作的时候，如果在 fast bins 中没有找到合适的 chunk，则 ptmalloc 会先在 unsorted bin 中查找合适的空闲 chunk，然后才查找 bins。如果 unsorted bin 不能满足分配要求。malloc便会将 unsorted bin 中的 chunk按照规则加入 bins 中。然后再从 bins 中继续进行查找和分配过程。</p><p>由此可见，其实unsorted bin相当于small bin和large bin的一个缓冲区。</p><h5 id="small-bin-amp-large-bin"><a href="#small-bin-amp-large-bin" class="headerlink" title="small bin &amp; large bin"></a>small bin &amp; large bin</h5><p>bins数组中从2开始编号前64个bin称为small bin，small bin中每个bin的大小都与其对应的index成以下关系：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">chunk_size</span> = <span class="hljs-number">2</span> * SIZE_SZ *index<br></code></pre></td></tr></table></figure><p>具体数值可以参考下表：（仔细看发现每个链表所存储的chunk的大小是成等差数列的）</p><div class="table-container"><table><thead><tr><th style="text-align:center">下标</th><th style="text-align:center">32bit</th><th style="text-align:center">64bit</th></tr></thead><tbody><tr><td style="text-align:center">2</td><td style="text-align:center">16</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">24</td><td style="text-align:center">48</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">32</td><td style="text-align:center">64</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">2 <em> 4 </em> a</td><td style="text-align:center">2 <em> 8 </em> a</td></tr><tr><td style="text-align:center">63</td><td style="text-align:center">504</td><td style="text-align:center">1008</td></tr></tbody></table></div><p>small bin中每个 bin 对应的双向链表采用 FIFO 的规则，同一个链表中先被释放的 chunk 会先被分配出去。</p><p>bins中剩下的就是large bin了，仔细算一下，large bin包含了63个bins，不过不同于small bin，large bin并不是把大小相等的chunk存储在同一个双向链表里面，相反，large bin中每个bin里存储的chunk的大小都是不一致的，不过每个bin（链表）中，存储的chunk的size都是一个等差数列，具体看下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">下标</th><th style="text-align:center">数量</th><th style="text-align:center">公差</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">32</td><td style="text-align:center">64B</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">16</td><td style="text-align:center">512B</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">8</td><td style="text-align:center">4096B</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">32768B</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">262144B</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">不限制</td></tr></tbody></table></div><p>这里可能有点抽象，可以通过一个例子来理解：<br>在32位机器下，large bin的启示存储chunk大小为512字节，那么这个large bin链表 可以存储的chunk的大小范围就是[512,512+64]。其中每一个链表中的 chunk 按大小序排列，相同大小的 chunk 同样按照最近使用顺序排列。</p><h4 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h4><p>试想一下一个只有bins结构的堆分配器，如果我们合并了几个相邻的chunk之后紧接着申请一个比较小的chunk，那作为分配器来讲，又需要从大内存块中申请一个小的内存块，这样看来似乎不是最佳的解决办法。因此ptmalloc引入了fast bins这个单向链表结构。</p><p>首先ptmalloc规定了一个常量：<strong>max_fast</strong> = 64B。</p><ul><li>从内存回收的角度来说，对于小于max_fast的被释放的chunk，ptmalloc会首先将其放入fast bins中，此时该chunk的P标志位（使用标志位）不被改变，也就是说在P不被改变的情况下，此时fast bins中的chunk不会被合并。</li><li>从内存分配的角度来讲，用户申请一个小于max_fast大小的chunk的时候，ptmalloc会首先在fast bins中查找是否有合适的chunk，有的话会直接分配，没有的话ptmalloc才会开始查找bins中是否有合适的chunk。</li></ul><p><strong>由此看来，fast bins相当于整个bins的一个缓冲区</strong>。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>并不是所有chunk都按照以上规则来分配，ptmalloc中有三种特殊的chunk：<strong>top chunk</strong>、<strong>mmaped chunk</strong>、<strong>last remainder</strong>。</p><h5 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h5><p>应用程序第一次malloc的时候，heap会被分为两段，一段给用户，另一段就是top chunk。从物理地址的角度来看，形象来说可以看下面这个图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9dwemdsz6j30ck0btq33.jpg" alt=""></p><p>top chunk的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</p><h5 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h5><p>当需要分配的 chunk 足够大，而且 fast bins 和 bins 都不能满足要求，甚至 top chunk 本身也不能满足分配需求时，ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空 间。这样分配的 chunk 在被 free 时将直接解除映射，于是就将内存归还给了操作系统，再 次对这样的内存区的引用将导致segmentation fault 错误。这样的 chunk 也不会包含在任何bin中。</p><h5 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h5><p>Last remainder 是另外一种特殊的 chunk，就像 top chunk 和 mmaped chunk 一样，不会 在任何 bins 中找到这种 chunk。当需要分配一个 small chunk，但在 small bins 中找不到合适 的 chunk，如果 last remainder chunk 的大小大于所需的 small chunk 大小，last remainder chunk 被分裂成两个 chunk，其中一个 chunk 返回给用户，另一个 chunk 变成新的 last remainder chuk。 </p><blockquote><p>那么ptmalloc的管理结构的介绍就结束了，接下来我们把它们整合一下，从整体来看，分配内存和释放内存时各个管理结构各自充当的角色。</p></blockquote><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ol><li>用户申请内存</li><li>ptmalloc判断所需分配的chunk的大小是否&lt;=max_fast(64B)，如果小于，则继续执行第3步；否则跳转到第4步</li><li>chunk大小小于max_fast，首先尝试在 fast bins 中取一个所需大小的 chunk 分配给用户。如果可以找到，则分配结束。否则转到下一步</li><li>chunk大小大于max_fast，判断所需大小是否处在 small bins 中，即判断 chunk_size &lt; 512B 是否成立。如果chunk 大小处在 small bins 中，则转至第5步，否则转至第6步</li><li>chunk大小处在small bins中，则找到具体的small bin，然后从这个bin的尾部取下一个chunk，分配结束</li><li>chunk大小不处在small bins中，此时说明用户申请的内存比较大，或者small bins中没有合适的小内存。因此ptmalloc会遍历fast bin，将相邻的chunk合并，合并后的chunk会链入unsorted bin中；紧接着ptmalloc会遍历unsorted bin中的chunk，寻找合适的chunk来分配给用户。如果 unsorted bin 只 有一个 chunk，并且这个 chunk 在上次分配时被使用过，并且所需分配的 chunk 大 小属于 small bins，并且 chunk 的大小大于等于需要分配的大小，这种情况下就直接将该 chunk 进行切割，分配结束，否则将根据 chunk 的空间大小将其放入 small bins 或是 large bins 中，遍历完成后，转入下一步。</li><li>如果此时还没有成功分配内存，就说明用户申请的是一块比较大的内存，或者说small bins和unsorted bin中没有找到相关的chunk，注意此时fast bins和unsorted bin中所有的chunk都已经清除干净了。那么就从large bins中寻找一个合适的chunk，从该chunk中划分出所需大小的chunk，剩下的部分链接回bins中。若操作成功，则分配完成。</li><li>如果large bins也分配失败，就说明需要使用top chunk来进行分配。如果top chunk大小满足所需分配的chunk的大小，就从top chunk中分离出一块来分配给用户。</li><li>如果top chunk也分配失败，那么此时有两个选择：主分配区来说调用sbrk()函数来增加top chunk的大小而非主分配区来说，调用mmap来形成一个新的sub-heap，增加top chunk的大小；直接利用mmap函数进行分配。对于是否使用mmap来分配内存，取决于所分配的chunk的大小是否大于、等于mmap分配的阈值，如果大于、等于，则使用mmap来分配，否则增加top chunk的大小。</li></ol><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><ol><li>判断所释放的chunk是否为mmaped chunk，如果是，则调用munmap()释放mmaped chunk，解除内存空间映射</li><li>判断chunk的大小以及位置，如果chunk的大小&lt;=max_fast，并且chunk并不位于heap的顶部，则说明该chunk并不与top chunk相邻，否则跳转到第4步</li><li>将chunk放到fast bin中(并不修改当前chunk的P位)，程序从free函数返回</li><li>判断前一个chunk是否在使用中，如果前一个chunk也是空闲块，则合并</li><li>判断当前释放chunk的下一块是否为top chunk，如果为top chunk，则将它与top chunk合并并更新top chunk的大小；如果不是，则判断下一个chunk是否在使用中，如果空闲，则合并并将其放入unsorted bin中</li><li>判断合并后的 chunk 的大小是否大于 FASTBIN_CONSOLIDATION_THRESHOLD (默认64kb)，如果是的话，则会触发进行fast bins的合并操作，fast bins中的chunk将被遍历并与相邻的空闲chunk进行合并放到unsorted bin中，结束后fast bins将会为空</li></ol><h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><p>tcache是glibc2.26(Ubuntu17.04之后)引入的一种新的技术，tcache的目的是提升堆管理的性能，是一个用于加速malloc分配的缓存结构，有由64个链表组成。其优先级很高，会先于全部的bin来处理。每个链表的个数是一定的，当缓存链表装满时，分配方式就与之前版本的malloc相同。但使用了tcache版本的malloc与free函数时，对于堆块的安全性检查就相比于之前的版本弱化很多。</p><h4 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h4><p><strong>tcache_entry</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br>typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">tcache_entry</span><br>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-type">tcache_entry</span> *next;<br>&#125; tcache_entry;<br></code></pre></td></tr></table></figure><p>作用：连接空闲的chunk结构体，其中的next指针指向下一个大小相同的chunk中的user data(fast bins中的fd指向的是chunk开头的地址)且tcache_entry 会复用空闲 chunk 的 user data 部分。</p><p><strong>tcache_perthread_struct</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_MAX_BINS                64</span><br><br><span class="hljs-keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>tcache_prethread_struct是整个tcache的管理结构，一共有TCACHE_MAX_BINS个计数器和TCACHE_MAX_BINS项 tcache_entry。</p><ul><li><code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</li><li><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk。</li></ul><p>借用ctf wiki上面一张图来清晰地展示一下这些结构：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9t2lhks4aj30ry0f0wgr.jpg" alt=""></p><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul><li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_prethread_struct</code> 。</li><li>free 内存，且 size 小于 small bin size 时</li><li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li><li>tcache 后：<ul><li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li><li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li><li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li></ul></li><li>malloc 内存，且 size 在 tcache 范围内</li><li>先从 tcache 取 chunk，直到 tcache 为空</li><li>tcache 为空后，从 bin 中找</li><li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk，会先把<code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在bin 中和 tcache 中的顺序会反过来</li></ul><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>unlink是发生在双向链表中取出空闲块的过程中的主要操作（例如 free 时和目前物理相邻的 free chunk 进行合并）。</p><p>借用CTF WIKI中的一张图：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9sm3jv3izj30ks0gnwh7.jpg" alt=""></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define unlink(P, BK, FD) &#123;                       \</span><br>    FD = P-&gt;fd;                                   <span class="hljs-string">\</span><br>    BK = P-&gt;bk;                                   <span class="hljs-string">\</span><br>    FD-&gt;bk = BK;                                  <span class="hljs-string">\</span><br>    BK-&gt;fd = FD;                                  <span class="hljs-string">\</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>对于free一个块的时候，会按以下步骤执行：</p><ul><li>glibc 判断这个块是 small chunk</li><li>判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</li><li>判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</li><li>继而对 Nextchunk 采取 unlink 操作</li></ul><p>执行unlink达到的效果：</p><ul><li>FD=P-&gt;fd = target addr -12</li><li>BK=P-&gt;bk = expect value</li><li>FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value</li><li>BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12</li></ul><p><strong>针对于这个效果，我们可以通过一些手段达到任意地址写的目的</strong>：</p><ul><li>首先FD = nextchunk-&gt;fd = free地址 – 12</li><li>然后BK = nextchunk-&gt;bk = shellcode起始地址；</li><li>再将BK赋值给FD-&gt;bk，即（free地址 – 12）-&gt;bk = shellcode起始地址；</li><li>最后将FD赋值给BK-&gt;fd，即(shellcode起始地址)-&gt;fd = free地址 – 12。</li></ul><p>我们结合chunk的结构来理解：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9smpdr89vj30us0bajt2.jpg" alt=""></p><p>32bit系统下，一个int型是4字节，因此从free addr-12，指针就指向了chunk的头部也就是nextchunk中fd指针指向的位置，第3步操作的结果就是将free addr处的数据替换为shellcode 的起始地址。由于已经将free addr处的数据替换为了shellcode的起始地址，所以当程序在代码处再次执行free的时候，就会转而执行shellcode了。</p><p>但是目前的ptmalloc对于这种利用unlink达到任意地址写的操作有了一个检测方式：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">// fd bk</span><br><span class="hljs-function"><span class="hljs-title">if</span> (__builtin_expect (FD-&gt;</span><span class="hljs-function"><span class="hljs-title">bk</span> != P || BK-&gt;</span>fd != P, <span class="hljs-number">0</span>))                      \<br>  malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \<br></code></pre></td></tr></table></figure><p>此时以上使用shellcode地址来执行任意地址写的方式失败，无法通过if判断条件。</p><p>新的利用方式：</p><ul><li>分配两个长度合适的堆块（两个堆块的fd、bk指针为空，原因是正在使用中）</li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">chunk0                malloc返回的ptr        chunk1        malloc返回的ptr<br>|<span class="hljs-string">                     </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">             </span>|<br>+-----------+---------+---+---+-------------+------+------+----+----+------+<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<span class="hljs-string">             </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<span class="hljs-string">             </span>|<span class="hljs-string"> prev </span>|<span class="hljs-string"> size&amp;</span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string"> prev_size </span>|<span class="hljs-string">size&amp;Flag</span>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<span class="hljs-string">             </span>|<span class="hljs-string"> size </span>|<span class="hljs-string"> flag </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<span class="hljs-string">             </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<span class="hljs-string">             </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>+-----------+---------+---+---+-------------+------+------+----+----+------+<br></code></pre></td></tr></table></figure><ul><li>对第一个chunk进行编辑，在第一个chunk的内部伪造一个假的chunk，编辑的过程中设置好第0块的bk和fd指针并溢出第一块，改好第一块的chunk头的控制信息</li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">chunk0                malloc返回的ptr           chunk1        malloc返回的pt<br>|<span class="hljs-string">                     </span>|<span class="hljs-string">                        </span>|<span class="hljs-string">             </span>|<br>+-----------+---------+----+----+----+----+----+------+------+----+----+------+<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">fake</span>|<span class="hljs-string">fake</span>|<span class="hljs-string">fake</span>|<span class="hljs-string">fake</span>|<span class="hljs-string"> D  </span>|<span class="hljs-string"> fake </span>|<span class="hljs-string"> fake </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">prev</span>|<span class="hljs-string">size</span>|<span class="hljs-string"> FD </span>|<span class="hljs-string"> BK </span>|<span class="hljs-string"> A  </span>|<span class="hljs-string"> prev </span>|<span class="hljs-string"> size&amp;</span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string"> prev_size </span>|<span class="hljs-string">size&amp;Flag</span>|<span class="hljs-string">size</span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> T  </span>|<span class="hljs-string"> size </span>|<span class="hljs-string"> flag </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> A  </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>+-----------+---------+----+----+----+----+----+------+------+----+----+------+<br>                      |<span class="hljs-string">--------new_size--------</span>|<br></code></pre></td></tr></table></figure><ul><li>伪造了prev_size和size的部分，然后溢出堆块1，改掉第1个堆块的prev_size,数值应该是上图所示 <code>new_size</code> 的大小；另外第1块的size部分还要把prev_inuse的flag给去掉</li></ul><p>具体的伪造数据：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">p32</span>(<span class="hljs-number">0</span>) + p<span class="hljs-number">32</span>(<span class="hljs-number">81</span>) + p<span class="hljs-number">32</span>(&amp;fake_chunk-<span class="hljs-number">12</span>) + p<span class="hljs-number">32</span>(&amp;fake_chunk-<span class="hljs-number">8</span>) + <span class="hljs-string">&quot;A&quot;</span>*(<span class="hljs-number">80</span>-<span class="hljs-number">4</span>*<span class="hljs-number">4</span>) + p<span class="hljs-number">32</span>(<span class="hljs-number">80</span>) + p<span class="hljs-number">32</span>(<span class="hljs-number">88</span>)<br></code></pre></td></tr></table></figure><p>这样的话将chunk 0的mem空间伪造成一个fake_chunk，其中fake_fd=p32(&amp;fake_chunk-12) 代表伪造的chunk头在程序内存空间中的地址-12， fake_bk=p32(&amp;fake_chunk-8) 这样做的话执行unlink操作时就会按以下内容进行：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FD</span>=P-&gt;fd = &amp;fake_chunk-<span class="hljs-number">12</span> ，<br><span class="hljs-attribute">BK</span>=P-&gt;bk = &amp;fake_chunk-<span class="hljs-number">8</span> ，<br><span class="hljs-attribute">FD</span>-&gt;bk ，即 *(&amp;fake_chunk-<span class="hljs-number">12</span>+<span class="hljs-number">12</span>) = *(&amp;fake_chunk) = buf[<span class="hljs-number">0</span>] = fake_chunk = p <br><span class="hljs-attribute">BK</span>-&gt;fd ，即*(&amp;fake_chunk-<span class="hljs-number">8</span>+<span class="hljs-number">8</span>) = *(&amp;fake_chunk) = buf[<span class="hljs-number">0</span>] = fake_chunk = p<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code-Pointer Integrity</title>
    <link href="/2020/01/03/2019-12-31-Code-Pointer%20Integrity/"/>
    <url>/2020/01/03/2019-12-31-Code-Pointer%20Integrity/</url>
    
    <content type="html"><![CDATA[<h1 id="Code-Pointer-Integrity"><a href="#Code-Pointer-Integrity" class="headerlink" title="Code-Pointer Integrity"></a>Code-Pointer Integrity</h1><p><strong>这篇论文发表在osdi 14会议上的论文，提出了一种新的保护方式：CPI(代码指针完整性)</strong></p><h2 id="摘要部分"><a href="#摘要部分" class="headerlink" title="摘要部分"></a>摘要部分</h2><p>这篇文章在摘要就指出现在大多数程序员所使用的编程语言如C和C++，在提供强大功能的同时也过度将内存管理这个任务委托给了程序员，因此内存安全问题成了一个让大多数安全人员头疼的问题。作者同时也指出了目前针对这个问题所提出的一些防御机制，如CFi，存在开销较高且保障工作有限的问题，因此这篇文章站在这些问题的基础上提出了本文的核心：作者引出了”代码指针完整性”这一保护机制，它的优势总体来说有以下几点：</p><ul><li>保证所有代码指针的完整性从而防止控制流劫持攻击</li><li>高效低开销</li></ul><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><blockquote><p>关于敏感指针的定义：</p><ul><li>函数指针</li><li>指向敏感类型的指针</li><li>指向有一或多个成员是敏感类型的复合类型（结构体或数组）</li><li>所有在编译或运行是隐式生成的代码指针（返回地址，C++虚函数表，setjmp缓存）</li></ul></blockquote><h3 id="代码指针完整性属性"><a href="#代码指针完整性属性" class="headerlink" title="代码指针完整性属性"></a>代码指针完整性属性</h3><p>对于一个程序，只有它的间接引用或者访问的敏感指针是安全的，它才是满足代码指针完整性属性的程序。关于敏感指针可以参考下面这张图片：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga8rwyeyg1j30h109rdgp.jpg" alt=""></p><p>在此图的结构中，CPI保护机制保护指针1、2、3、4(由于3、4直接指向函数a和b，而1和2可能会指向3和4，因此1、2、3、4都会被保护) ，同时敏感指针的定义是一个动态的，比如指针2指向3或4时，它是一个敏感指针，而它指向int整数时，它不是敏感的。</p><p>除此之外，本文的团队通过研究其他最先进的内存保护机制，发现一个程序中的所有指针其实只有一小部分负责进行控制流传输，因此，通过仅对控制敏感数据强制执行内存安全(不会对所有其他数据产生开销)就可以获得了重要的安全保障，同时保持实施安全保护的成本较低。</p><h3 id="CPI执行机制"><a href="#CPI执行机制" class="headerlink" title="CPI执行机制"></a>CPI执行机制</h3><p>为了把CPI应用到具体环境中，本文设计了一个利用静态分析和运行时支持的将CPI保护添加到程序的方法：包括一个静态分析遍历，它标识程序中的所有敏感指针以及对它们进行操作的所有指令，检测所有敏感指针的传递，将它们存储在单独的、安全的内存区域中，并根据元数据关联、传播和检查它们；同时利用指令级别的隔离机制有效防止非受保护的内存操作访问安全区域。为了性能考虑，程序会使用安全的堆栈机制处理存储在堆栈上的返回地址，与其他代码指针分开处理。</p><h3 id="CPI静态分析"><a href="#CPI静态分析" class="headerlink" title="CPI静态分析"></a>CPI静态分析</h3><p>静态分析的意义是查找所有对敏感指针进行操作的指令。这些操作包括：指针解引用、指针的运算以及指针内存分配、相关标准库函数、C++的new/delete操作符、自实现的分配算法。</p><h3 id="CPI插桩"><a href="#CPI插桩" class="headerlink" title="CPI插桩"></a>CPI插桩</h3><p>CPI插桩有三个目的，分别是：保证所有敏感指针存储在安全区；在运行时能够创建和传递这类指针的相关元数据；在对这类指针进行解引用时，检查元数据。</p><p>在内存布局上，CPI引入了安全区，CPI在安全区和常规区为敏感指针都分配了存储空间，但二者同时只能有一个是有效的。（通用指针在运行时的敏感性可能发生变化，同时也可以避免因为改变了内存空间分布而产生的一些兼容性问题）。CPI也将指针在常规区的地址来计算指针在安全区的相应地址。元数据描述了指针指向的目标对象，其中包括以下信息：内存地址的上下界、id、指针的值。这种做法的好处就是CPI无需到所有指针访问处都插桩的前提下保证指针数据安全。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga97fbtr3nj30tq059mxt.jpg" alt=""></p><p>如上图所示，安全区包含了安全指针存储区、安全栈两个部分。左边(阴影部分)的敏感指针的位置仍未使用，而该指针的值及其元数据存储在安全指针存储区中。安全栈T1、T2、T3在常规内存中有对应的栈T1 ‘、T2 ‘、T3 ‘分配不安全的栈对象。</p><h3 id="安全区隔离"><a href="#安全区隔离" class="headerlink" title="安全区隔离"></a>安全区隔离</h3><p>安全区只能通过CPI固有指令访问。</p><h4 id="x86-32"><a href="#x86-32" class="headerlink" title="x86-32"></a>x86-32</h4><p>依赖于硬件段保护，安全区只能通过特定段寄存器访问（这个段寄存器不会再有其他用途），这里CPI将这个段寄存器也看做Program loader，CPI也将其他通过syscall来设置段寄存器的方式禁掉了。（这里感觉有点勉强，实验中测试的程序有限，如果真的应用到工业实践中，不能保证所有的程序和系统都不会用到这个段寄存器）</p><h4 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h4><p>尽管仍提供了两个段寄存器，X64中不再受到段限制。与x86类似，CPI使用了其中一个寄存器，同时还为安全区随机选择一个基址。</p><h4 id="其他架构"><a href="#其他架构" class="headerlink" title="其他架构"></a>其他架构</h4><p>其他架构也可以使用基于随机的保护，或者依赖于精确的软件故障隔离(SFI)，SFI要求程序中的所有内存操作都是轻量级插装的，如果安全区域占据了进程的整个上半部分地址空间，那么插装可能只有单个或全部操作那么小。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>安全指针存储是高度稀疏的，为了节省内存，设计者可以将其组织为散列表、多级查找表或依赖于底层操作系统的稀疏地址空间支持的简单数组。</p><h3 id="安全栈"><a href="#安全栈" class="headerlink" title="安全栈"></a>安全栈</h3><p>对于堆、栈进行特殊处理是有原因的，因为堆栈上有被频繁访问的值，比如每次函数调用时访问的代码指针的返回地址，以及溢出的寄存器。跟踪这些值中哪些将在运行时出现在内存中(因此需要保护)，哪些将出现在寄存器中，比较困难，因为编译器仅在代码生成的后期(CPI的检测通过之后很久)才发现哪些寄存器会产生安全问题。而研究者对于此的发现是，对堆栈对象的大多数访问都可以在编译期间静态地检查安全性。因此这种访问不需要运行时检查或元数据。大多数堆栈帧只包含在相应函数中独占访问的内存对象，并且只能通过具有常量偏移量的堆栈指针寄存器访问。将所有这些源安全的对象放到位于安全区域的安全堆栈中。可以在不进行任何检查的情况下访问安全堆栈。对于堆栈上有需要检查的内存对象的函数(例如，数组或地址传递给其他函数的对象)，我们在常规内存区域中分配单独的堆栈帧。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gagcfs3jv8j30ht0mk788.jpg" alt=""></p><p>通过整理所有统计于上表，研究者发现只有不到25%的函数需要额外的堆栈帧(见表2)。此外，在短函数中，这一比例要小得多。</p><h3 id="代码指针隔离-CPI"><a href="#代码指针隔离-CPI" class="headerlink" title="代码指针隔离(CPI)"></a>代码指针隔离(CPI)</h3><p>CPS的执行与CPI类似，除了</p><ul><li><p>静态分析期间用以识别敏感指针的准则;及</p></li><li><p>CPS不需要任何元数据。控制流目的地(由代码指针指向)没有边界，因为指针值必须始终与目的地完全匹配，因此不需要边界元数据。</p></li></ul><p>CPS保证</p><ul><li><p>代码指针只能通过代码指针存储指令存储到内存中或在内存中修改代码指针，(ii)代码指针只能通过代码指针加载指令从内存位置加载指令，而以前代码指针存储指令存储的是一个值。结合安全堆栈，CPS可以精确地保护返回地址。CPS比大多数CFI实现更强大[1,54,53]，它允许程序中的任何脆弱指令修改任何代码指针;它们只检查代码指针的值(用于间接控制传输时)是否指向程序中定义的函数(用于函数指针)，或是否直接跟随调用指令(用于返回地址)。CPS guarantee (i)以上限制攻击面，而guarantee</p></li><li><p>通过限制控件可重定向到的位置集来限制攻击者的灵活性——该集合只包含函数的入口点，而这些函数的地址是程序显式获取的。</p></li></ul><h3 id="保护机制实现"><a href="#保护机制实现" class="headerlink" title="保护机制实现"></a>保护机制实现</h3><p>本文作者在LLVM 3.3编译器基础架构的基础上，对LLVM li-braries、clang编译器和compiler-rt运行时进行了修改，为C/ C++实现了一个名为Levee的CPI/CPS增强工具。要使用Levee，只需向编译器传递额外的标志来启用CPI (-fcpi)、CPS (-fcps)或safe- stack protection (-fstack-protector-safe)。Levee工作在未经修改的程序上，并支持Linux、FreeBSD和Mac OS X的32位和64位模式。</p><h2 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h2><p>CPI基于RIPE进行了测试，对新出现的几种能绕过DEP、ASLR、CFI等机制的攻击实现了防御。同时，CPI基于SPEC CPU2006标准，对100多个软件包进行了测试，结果如下：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah0iqwfzzj30l10n477s.jpg" alt=""></p><p>作者制作的统计表：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah0jm1ogrj30m408nq4l.jpg" alt=""></p><p>在web平台((FreeBSD + Apache + SQLite + mod wsgi + Python +Django))上的测试结果：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah0mdpfosj30px063jsm.jpg" alt=""></p><h2 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h2><blockquote><p>本节鉴于本人水平有限，后面的一些式子的理解参考于<a href="https://www.anquanke.com/post/id/193818">这篇文章的形式化验证部分</a></p></blockquote><p>在本节中考虑的C子集的语法规则：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah5jyuj41j30nl0acq4p.jpg" alt=""></p><p>定义运行时环境为E，将E表示成一个三元组的形势：(S,Mu,Ms)。</p><blockquote><p>S表示将某变量映射到其类型和地址，Mu是常规区的某一地址，存储着一个值v，Ms是安全区某一地址，存储着某值和其上下界信息v(b,e)，b为下界，e为上界，不存在被标记为none。</p></blockquote><p>对Mu和Ms两个地址的所有操作类型(假设内存操作在所有其他方面都遵循读/写/malloc操作的标准行为，例如，read返回以前写到相同位置的值，malloc分配内存的一个区域，这个区域与任何其他分配的区域不相交。)：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah5l9odajj30nz08ymz3.jpg" alt=""></p><p>对于操作的结构，都可以用以下形势来表示：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah5n8lqnoj30o201xgls.jpg" alt=""></p><p>具体解释一下来说，v(b,e)和v表示安全,OK意味着操作成功，OutOfMem和Abort是错误编码，我们假设语言的所有操作语义规则传播这些错误代码，直到程序结束时都保持不变。</p><p>使用上述定义，作者使用规则形式化CPI的操作语义，a表示原子类型int或者是指针，左表达式lhs包括某变量，结构体成员，指针解引用，右表达式包括整数、函数地址，左表达式、左表达式地址、指针大小、为右表达式分配内存情况。特别地，lhs=rhs表示变量赋值等操作。</p><p>规则指定将左侧表达式分别分配到安全位置或常规位置：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6hcp5j4j30jv026mx7.jpg" alt=""></p><p>规则指定如何将表达式计算为带有边界或规则值的安全值，同时可能伴有环境的转换：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6eiezrrj30pw03ejrn.jpg" alt=""></p><p>规则指定执行命令c得到结果r同时可能伴有环境的转换：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6f7sbjuj308x025aa0.jpg" alt=""></p><p>规则表示分配i单位内存，得到某位置上下界l、l+i，同时返回结果r：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6oo5noij30oz04v74w.jpg" alt=""></p><p>以下三个式子表示对敏感指针的操作（如解引用等）将会被判定，返回结果r。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6pdcmfmj30o209xjsi.jpg" alt=""></p><p>这三个表达式是对读写操作进行判定。对从安全区读出的值进行检查，如果与元数据信息（上下界）相符，则可以进行后续操作，否则返回Abort（错误）。对写入安全区的数据也进行检查，通过之后返回OK：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6pzmqizj30qg0g9gnz.jpg" alt=""></p><p>该式表示任何经由常规区对安全区的访问都是非法的，返回Abort：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6sbkdt7j30lz04aq3c.jpg" alt=""></p><p>该式处理了泛型指针的敏感性会动态变化的情形。由于泛型指针在安全区和常规区均占有内存，读取时先在安全区标记为none，然后从常规区直接取值。写操作是类似的，直接写入常规区，然后将安全区标记为none,成功返回OK：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6sxk8ujj30n307v0u2.jpg" alt=""></p><p>该式表示对于常规区的操作无需任何干涉，也不会产生任何问题，直接返回OK：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6tmlzyoj30lh07cgml.jpg" alt=""></p><p>该式表示如果函数指针位于安全区（ls）,则返回OK，位于常规区（lu）则返回Abort。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6u3atxaj30nr03iweu.jpg" alt=""></p><p>根据上述敏感条件和安全位置取消引用和间接函数调用规则，所有需要根据CPI属性进行保护的指针的取消引用在运行时都是安全的，否则程序将中止。因此，上述定义的操作语义确实保证了CPI属性。</p>]]></content>
    
    
    <categories>
      
      <category>security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>system security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intel SGX</title>
    <link href="/2019/11/03/Intel%20SGX/"/>
    <url>/2019/11/03/Intel%20SGX/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>SGX(software guard extensions)使应用程序在一段位于Enclave的地址空间中开辟一段地址空间。在enclave中运行的受保护程序还拥有一个密码学测度，这可被发送给客户端来验证程序的可信执行和为远程终端或不可信平台提供secrets。</p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><ul><li>允许应用程序开发者保护敏感数据不被未授权访问或者更高特权级别软件的修改</li><li>使得应用程序能够拥有保护敏感代码和数据的机密性与完整性的能力, 而不会中断这些资源被合法程序和系统调度、使用和管理的能力</li><li>使得计算设备的消费者能够控制自己平台, 并且具有自由安装和卸载应用与服务的能力</li><li>使得平台能够度量应用程序的可信代码, 生成签名验证, 并且度量和认证过程的代码都能够在可信赖的环境中正确的初始化</li><li>使得可信应用程序的开发过程中能够使用原来的工具和流程</li><li>允许可信应用程序的性能能够随着处理器的能力增强而得到扩展</li><li>使得软件代理商能够使用它们选择的分发通道来分发、更新可信应用程序</li><li>使得应用程序可以定义一个安全代码和数据区域, 这一区域可以维护其机密性, 即使攻击者能够物理上控制这个平台以及产生对内存的直接攻击, 也能够有效加以抵御</li></ul><h2 id="Enclave安全容器"><a href="#Enclave安全容器" class="headerlink" title="Enclave安全容器"></a>Enclave安全容器</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95of2rhnvj30sg0cp0wy.jpg" alt="enclaves保护后的攻击面"></p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>Enclave俗称安全区，是一个被保护的安全内容容器，用于存放敏感代码与数据。对于加载进Enclave的代码和数据，系统会对其进行度量。在认证方面，Enclave会向远程认证者证明自己的身份，并提供必需的功能结构用于安全提供密钥，同时用户也可以请求独有的密钥，结合Enclave身份和平台的身份做到独一无二。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="EPC"><a href="#EPC" class="headerlink" title="EPC"></a>EPC</h4><p>Enclave代码和数据放置在被称为Enclave Page Cache（EPC）的特殊内存区域中，该内存区域使用内存加密引擎MEE进行加密，因此对于页面来说，只有在处理器内核才会被解密，而内存总线上的外部读取只会读到加密后的数据。关于MME加密所使用的密钥，该密钥只会在Enclave页面缓慢启动时生成并存储在CPU中。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95susnr6pj30lw0eygo1.jpg" alt=""></p><h4 id="EPCM"><a href="#EPCM" class="headerlink" title="EPCM"></a>EPCM</h4><p>EPCM是维护EPC的入口地址，并且包含CPU跟踪EPC内存页元数据的状态表。EPC内存以页的形式进行管理，一个页面对应EPCM的一个表项。它来保证每个EPC由一个Enclave独享。EPCM包含了每个页面的配置、权限和类型。</p><h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><h5 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h5><ul><li><p>为防止Enclave的内存不被特权软件染指，Intel专门保留了一块物理内存来支持SGX的相关功能：<strong>RPM</strong>。RPM也使用分页内存管理，使得EPC的内存页只能在处理器运行于Enclave模式下才能够被访问，enclave之外的软件无法访问EPC。</p></li><li><p>为了跟踪Enclave的身份，在每个Enclave中SGX使用了一个EPC页维护结构体SECS记录其元数据（enclave密码学测度等敏感信息）因此这段结构体只能被CPU的SGX管理机制访问修改。</p></li></ul><h5 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h5><p>Enclave与原宿主进程共享虚拟地址空间，从某种角度上来说，Enclave相当于源程序的动态链接库。部分Enclave中映射到EPC页的虚拟内存称为（enclave linear address range）ELRANGE。当从EPC页地址转换到物理地址时，CPU使用在SECS中存储的初始分配信息来保证传递给地址转换过程的EPC页虚拟地址与EPCM中保留的EPC入口地址相匹配。这样来防止操作系统将ELRANGE地址映射到不受保护的内存，使得ELRANGE内存对enclave之外的软件不可见。</p><p>SGX使用TCS来保存enclave内的预定义入口点信息，TCS保留在专门的EPC页中并且只能被SGX管理机制修改。</p><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><h4 id="Enclave"><a href="#Enclave" class="headerlink" title="Enclave"></a>Enclave</h4><p>每个Enclave都由其属性以及页面的位置、内容和保护的哈希值表示。每个Enclave也由其管理者进行签名， MRSIGNER包含管理者公钥的哈希值，MRENCLAVE和MRSIGNER使用SHA-256哈希函数生成。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>Einit指令使用EINITTOKEN结构来检查是否允许执行enclave。它包含enclave的属性，哈希和签名者身份，它使用启动密钥执行的HMAC进行身份验证。</p><p>SIGSTRUCT：每个enclave都与一个SIGSTRUCT结构相关联，该结构由管理者签名并包含enclave方法，签名者公钥，版本号（ISV，反映安全级别）和产品标识符（ISVPRODID，以区分同一管理者的enclave） 。它负责确保enclave未被修改，然后使用其他密钥重新签名。</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul><li>应用程序会请求将其enclave加载到内存中</li><li>ECREATE指令负责创建并填充SECS结构</li><li>使用EADD指令将每个页面加载到受保护的内存中</li><li>使用EEXTEND指令将每个页面添加到enclave检查中</li><li>EINIT指令最终完成对enclave的创建</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95youg6ogj30p40h1472.jpg" alt=""></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><h4 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h4><p>SGX有两种密钥：RootProvisionKey和RootSealKey。</p><ul><li>RootProvisionKey：RPKs被交付到不同的，被英特尔的正式出版物命名为“大容量制造系统”的生产设施中，被集成烧入到处理器内。Intel存储所有RPK，因为它们是SGX处理器通过在线供应协议验证其身份的基础。</li><li>RootSealKey:RSK也被保证在统计上不同部分的RSK是不同的，每个SGX都假设它的RSK值是唯一的，并且只有它自己知道。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9755rsqkrj30ig0bc42i.jpg" alt=""></p><h4 id="Root密钥派生"><a href="#Root密钥派生" class="headerlink" title="Root密钥派生"></a>Root密钥派生</h4><p>Enclave使用EGETKEY指令基于不同的请求参数和请求生成的密钥类型结合烧入的Root密钥来生成不同用途的密钥。</p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><h4 id="本地认证"><a href="#本地认证" class="headerlink" title="本地认证"></a>本地认证</h4><p>在enclaveA和enclaveB之间建立一个通道，enclaveA使用该通道来检索enclaveB的MRENCLAVE。Enclave A使用Enclave B的MRENCLAVE调用EREPORT来为Enclave B生成签名报告，通过使用ERREPORT指令，enclave可以获取用来描述其软件和硬件TCB的硬件断言。返回的Report包含enclave的属性、测度值和ISV附加数据。Enclave B调用EGETKEY来检索其报告密钥并验证EREPORT结构的MAC，如果有效，则enclave是预期的并且在合法平台上运行。</p><p>在本地认证中第一次成功过后，因为可以确保是使用真正调用者属性填充的REPORT，因此后续对于认证过的enclave见证只需要根据预期认证要求验证报告字段就行了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g975wapfvtj30ke06oq46.jpg" alt=""></p><h4 id="远程认证"><a href="#远程认证" class="headerlink" title="远程认证"></a>远程认证</h4><h5 id="获取远程认证密钥"><a href="#获取远程认证密钥" class="headerlink" title="获取远程认证密钥"></a>获取远程认证密钥</h5><p>SGX的预备服务和远程认证过程是使用Intel设计的称为EPID的组签名方法，为了实现EPID预备过程Intel提供了一个特殊的Enclave Povision Enclave(PvE)。</p><p><strong>PvE</strong>：负责在平台上使用Intel的在线供应服务器执行预备过程。PvE使用一些只能由特殊enclave生成的SGX特权密钥。这两种密钥分别是Provision Key和Provision Seal Key。基于特殊enclave他们直接被intel签名的SIGSTRUCT证书，因此使用特权属性启动的特殊enclave能够使用EGETKEY来获取这两种特权密钥。</p><h5 id="预备协议"><a href="#预备协议" class="headerlink" title="预备协议"></a>预备协议</h5><ul><li><p>Enclave hello：得到硬件TCB的特定PrK之后，PvE使用两个值来初始化预备协议</p></li><li><p>服务器挑战：Intel适用PPID来判断平台以前是否已经预备化过，如果已经完成预备化，则服</p><p>务器将加密过后的以往生成的认证密钥添加到挑战中去。其他情况则是服务器验证是否给此EPID组提供服务，接着将EPID组参数、随机参数(nouce)和预计算的TCB挑战返回给平台。</p></li><li><p>Enclave回复：PvE解开挑战之后，通过使用TCB挑战作为密钥计算CMAC来生成TCB证明，接着PvE自己产生一个随机EPID成员密钥是用数学方法隐藏密钥从而避免Intel的Provision服务器获取到平台生成的成员密钥信息获得一定的匿名性。</p></li><li><p>完成：服务器收到回复之后，首先验证TCB证明中使用的值是否余iKGF中收到的一样，如果一致则继续EPID参与协议。紧接着处理隐藏的成员密钥创建使用EPID组发布者密钥签名的唯一证书并与加密的成员密钥一起存储。</p></li><li><p>解密：PvE使用PSK解密认证密钥，并将其奉存在Enclave外以备后用。由于EPID组按照TCB级别进行分类，因此平台的EPID签名可以在以后使用。</p></li></ul><h5 id="远程认证-1"><a href="#远程认证-1" class="headerlink" title="远程认证"></a>远程认证</h5><p>远程认证涉及到两个独立的参与者：证明者和参与者。</p><ul><li><p>最初，enclave会通知应用程序，它需要在位于平台外部的某个位置加密。此时，应用程序与服务器建立安全通信，服务器对此请求进行回应，以认证正在执行的enclave没有被篡改，并且它执行的平台是合法的；</p></li><li><p>该应用程序为其enclave提供了Quoting Enclave标识和认证请求；</p></li><li><p>enclave产生一个包括认证回应和临时公钥的清单，该公钥将在稍后被用于保护服务器和enclave之间的通信。而生成的哈希，则包含在EREPORT指令的用户数据部分中。该指令为Quoting Enclave生成一个报告，将清单与enclave关联起来，此时，enclave将REPORT发送给应用程序；</p></li><li><p>该应用程序将REPORT发送到Quoting Enclave进行验证和签名；</p></li><li><p>QE使用EGETKEY指令检索其报告密钥并验证REPORT，它会创建QUOTE结构，并在将其提供给应用程序之前使用其Provisioning Key对其进行签名；</p></li><li><p>应用程序将QUOTE和关联的清单发送到服务器进行验证；</p></li><li><p>服务器使用Intel提供的认证服务来验证QUOTE签名，然后，它使用QUOTE用户数据中的哈希检查清单完整性。以确保清单包含对认证的预期响应。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g99hblefenj30g2074tap.jpg" alt=""></p><h2 id="相关研究"><a href="#相关研究" class="headerlink" title="相关研究"></a>相关研究</h2><h3 id="针对SGX的攻击"><a href="#针对SGX的攻击" class="headerlink" title="针对SGX的攻击"></a>针对SGX的攻击</h3><h4 id="side-channel-attack"><a href="#side-channel-attack" class="headerlink" title="side-channel attack"></a>side-channel attack</h4><ul><li>丰富的攻击面：Enclave运行环境有大量资源与外面的non-enclave公用，如cache、页表、TLB、DRAM以及分支预测器等。</li><li>操作系统不可信：操作系统负责管理系统的资源：页表、内存、中断、进程调度等，但操作系统本身并不可信</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g99j89mxeej30o40he41n.jpg" alt=""></p><h4 id="基于页表进行攻击"><a href="#基于页表进行攻击" class="headerlink" title="基于页表进行攻击"></a>基于页表进行攻击</h4><p>利用页表对enclave页面的访问控制权设置enclave的页面为不可访问。此时访问enclave页面就会触发缺页异常，进而可以区分出enclave访问了哪些页面，按照”时间”将信息按顺序组合，就可以反推出enclave的某些状态和保护的数据。</p><ul><li>优点：可以获得大量有用的信息</li><li>缺点：该攻击只能达到页粒度，无法区分更细粒度的信息</li></ul><p><strong>变种</strong>：利用页表的状态位，通过观察这些状态位，攻击者可以获取类似的大量有用信息。</p><h4 id="基于TLB的攻击"><a href="#基于TLB的攻击" class="headerlink" title="基于TLB的攻击"></a>基于TLB的攻击</h4><p>目前出现的都是以TLB作为辅助手段的侧信道攻击</p><h4 id="基于cache的攻击"><a href="#基于cache的攻击" class="headerlink" title="基于cache的攻击"></a>基于cache的攻击</h4><p>优点：SGX环境中攻击者可以控制整个系统的资源，因此攻击者可以有针对的调度资源并减少侧信道的噪音增加攻击的成功率。</p><p><strong>降低噪音的方式</strong>：</p><ul><li>核隔离：让Enclave独自占用一个核</li><li>缓存隔离：尽量使用L1或者L2级别的cache进行侧信道攻击，L3的cache会被所有核共用，会引入不必要的噪音</li><li>不间断运行：不触发或尽量少触发AEX（AEX和后续的ISR都会使用cache从而引入不必要的噪音）</li></ul><p><strong>提高攻击精度的方式</strong>：</p><ul><li>高精度时钟：采用APIC提供的高精度时钟和硬件TSC</li><li>放大时间差异：攻击者可以配置侧信道攻击代码所在的CPU以最高频率运行，而对Enclave所在的CPU进行降频处理</li></ul><h4 id="基于DRAM的攻击"><a href="#基于DRAM的攻击" class="headerlink" title="基于DRAM的攻击"></a>基于DRAM的攻击</h4><p>缺点：enclave 使用的内存通常都在缓存里面，只有少部分需要从DRAM 里面去取；DRAM的精度不够；DRAM里面存在很难避免的噪音干扰，因为一个DRAM row 被很多页面使用，同时同一个bank 不同row的数据读取也会对时间测量造成干扰，使得误报时常发生。</p><h4 id="基于CPU内部结构的攻击"><a href="#基于CPU内部结构的攻击" class="headerlink" title="基于CPU内部结构的攻击"></a>基于CPU内部结构的攻击</h4><p>CPU 内部有大量的结构是在enclave 和non-enclave 之间共用的。这就给侧信道攻击提供了大量的攻击面素材。</p><p>注：关于利用CPU内部结构攻击SGX的研究才刚刚开始，因此这里不进行概括。</p><h4 id="混合侧信道攻击"><a href="#混合侧信道攻击" class="headerlink" title="混合侧信道攻击"></a>混合侧信道攻击</h4><p>混合侧信道攻击是同时采集多个侧信道攻击面的信息，或通过多个攻击面共同作用放大差异增加准确度。</p><p>做法：</p><ul><li>TLB 和页表混合攻击。比如TLB miss 的时候会加载页表，这个时候CPU 会设置页表的Access bit。</li><li>Cache 和DRAM 混合攻击。</li></ul><h4 id="侧信道攻击的防御"><a href="#侧信道攻击的防御" class="headerlink" title="侧信道攻击的防御"></a>侧信道攻击的防御</h4><h5 id="在源码层面进行防御"><a href="#在源码层面进行防御" class="headerlink" title="在源码层面进行防御"></a>在源码层面进行防御</h5><p>修改源码从而隐藏控制流和程序流。</p><h5 id="系统层次防御"><a href="#系统层次防御" class="headerlink" title="系统层次防御"></a>系统层次防御</h5><ul><li>将随机化技术应用在控制流和数据流上面，从而大大增加侧信道攻击的代价。</li><li>检测可疑的中断或异常从而抵御最原始的controlled-channel 攻击</li><li>检测时间的异常，如果攻击者中断或减缓enclave 的运行，enclave就可以通过自己的时钟检测出时间上的异常。目前，绝大多数侧信道攻击都会引起enclave 的显著性能下降。因此，检测时间异常还是一个比较有效的方案。</li><li>Cache隔离</li></ul><h5 id="硬件层次防御"><a href="#硬件层次防御" class="headerlink" title="硬件层次防御"></a>硬件层次防御</h5><p>目前针对于硬件层次的防御还处于探索阶段，目前主要有两种解决思路：</p><ul><li>硬件分割，类似于ARM的Trust Zone那样，有自己的cache、memory等硬件资源</li><li>硬件隔离，类似于Intel CAT技术，可以单独为每一个enclave 提供一个动态隔离出的cache。当enclave 销毁的时候，隔离出的cache 可以被收回。</li></ul><h4 id="同步攻击"><a href="#同步攻击" class="headerlink" title="同步攻击"></a>同步攻击</h4><p>AsyncShock攻击的原理就是充分利用enclave内现有的同步错误，特别是，它有助于利用Use After Free（UAF）漏洞和Time Of Check Time Of Use（TOCTOU）漏洞。控制该平台的攻击者（在英特尔SGX的攻击模型中）可以随时中断enclave线程。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9ajwmrt2gj30ga0f73zq.jpg" alt=""></p><p>不过这类攻击需要完全控制平台，知道enclave内运行的代码，并在其中发现同步漏洞。防止这种攻击的最佳方法是在enclave内禁用多线程，但这显然会妨碍程序的性能。另一种解决方案是加密enclave的代码，并使用远程认证过程为enclave提供解密其代码所需的密钥。</p><h4 id="分支追踪推断SGX-Enclave内部的详细控制流程"><a href="#分支追踪推断SGX-Enclave内部的详细控制流程" class="headerlink" title="分支追踪推断SGX Enclave内部的详细控制流程"></a>分支追踪推断SGX Enclave内部的详细控制流程</h4><p>在不受信任的环境中复制enclave程序的控制流程，然后仔细的选择映射此新代码的地址，以便在BTB（Branch Target Buffer）内部引入冲突事件。首先在enclave代码内执行分支，然后在被跟踪的代码中执行分支，此时第二个分支的预测将受到第一个分支的结果的影响。要知道CPU预测的内容，最后一个分支记录（ Last Branch Record，LBR）只能在不受信任的环境中使用，因为它对于enclave来说是禁用的。</p>]]></content>
    
    
    <categories>
      
      <category>security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>system security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PCAM设计</title>
    <link href="/2019/08/03/PCAM%E8%AE%BE%E8%AE%A1/"/>
    <url>/2019/08/03/PCAM%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这个项目是我和同学参加全国大学生信息安全竞赛作品赛时开发的项目，特此记录一下整个项目的流程以及部分细节。</p><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><p>PCAM使用 flask 框架和 HTML+CSS 开发了一个集用户注册、文件上传、文件下载、转发视频数据流功能 为一体的云平台，利用 RTMP 协议以及流媒体传输技术实现了视频实时观看。除此之外我们还开发了一套搭配 TPM 安全芯片并依托于商用密码体系的安全中间件，使用 TPM 在系统启动时实现系统可信环境自检，并将密钥、证书等信息存储在 安全芯片中;利用商用密码 SM2、SM3、SM4、ZUC 算法实现了加密存储以及视频数据 流加密传输，同时我们还使用 flask 框架搭建了 CA 认证中心后端并结合了 SM2、SM3 加密算法实现了 CA 认证中心的功能:证书的请求、生成、发送，为用户与中间件的密钥协商提供支持。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtkke9v8uj30hy0d8ab1.jpg" alt=""></p><h2 id="部署与硬件拓扑"><a href="#部署与硬件拓扑" class="headerlink" title="部署与硬件拓扑"></a>部署与硬件拓扑</h2><p>用户初始部署本项目时，用户在局域网内初始化整个系统并与中间件通过 CA认证中心进行密钥协商：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtk4p2ohoj30dj0bugn3.jpg" alt=""></p><p>整个项目初始化之后，用户即可随时随地观看过去的视频文件或实时观看摄 像头拍摄的视频：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtk5lk6c1j30h706st96.jpg" alt=""></p><h2 id="具体流程设计"><a href="#具体流程设计" class="headerlink" title="具体流程设计"></a>具体流程设计</h2><h3 id="中间件设计"><a href="#中间件设计" class="headerlink" title="中间件设计"></a>中间件设计</h3><p>中间件为整个系统提供安全服务，中间件包括以下功能：</p><ul><li>系统可信环境度量</li><li>密钥协商</li><li>密钥芯片存储</li><li>生成对称密钥</li><li>生成 ZUC 密钥</li><li>视频文件加密</li><li>视频数据流编码后加密</li><li>对文件进行签名</li></ul><p>系统硬件搭载TPM芯片，在系统启动过程中建立并传递信任链，对系统中的操作系统及关键文件进行完整 性度量验证，保证在操作系统获得控制权之前，确定系统是完整可信的。同时， 在运行过程中，利用可信软件栈提供的密码服务接口，对系统服务和应用软件进 行完整性度量，阻止未授权程序运行。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtkljc0jpj30ur0fh773.jpg" alt=""></p><p>TPM工作流程：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtkma8176j30km0jwdho.jpg" alt=""></p><p>整个中间件工作流程：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtkn0v1vqj30o90e0gmr.jpg" alt=""></p><h3 id="CA认证中心设计"><a href="#CA认证中心设计" class="headerlink" title="CA认证中心设计"></a>CA认证中心设计</h3><p>部署在局域网内主机上的 CA 认证中心为用户的 SM2 公钥签发证书，证书为 X.509 格式，在签发完证书之后 CA 认证中心将证书发送给中间件供中间件使用。 在一个新的用户想要通过 CA 制作自己的证书的时候，CA 认证中心的具体工作流程如下:</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtkpy6l55j30jq0e6my0.jpg" alt=""></p><h3 id="云平台设计"><a href="#云平台设计" class="headerlink" title="云平台设计"></a>云平台设计</h3><p>云平台的主要功能为备份存储视频文件以及转发加密后的视频数据流。用户可以通过访问云平台来下载加密视频文件以及加密后的密钥或点击实时观看按钮来在客户端程序上实时观看摄像头拍摄的视频。在整个项目投入使用的情况下，云平台的结构以及工作流程如下：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtkswk7lkj30l209x3zt.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtkrl93rrj30hs0aydgq.jpg" alt=""></p><p>在线观看部分的流程：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtks7zzvuj30l10ay759.jpg" alt=""></p><h2 id="项目测试部分"><a href="#项目测试部分" class="headerlink" title="项目测试部分"></a>项目测试部分</h2><p>由于资源有限，我们最终选择使用树莓派+TPM+云服务器搭建这套系统。(不过对亏指导老师我们能用上从德国买来的英飞凌TPM2.0芯片hhhhh)</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtkuvio3aj30fh09qwfg.jpg" alt=""></p><p>配置TPM(给内核打patch，使其识别TPM驱动)：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtkwnpt0ej30m809y400.jpg" alt=""></p><p>云平台界面：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtkvahj2bj30m40gugml.jpg" alt=""></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtkvtuadlj30ks0c774v.jpg" alt=""></p><p>客户端总共四个功能，都集成在一个界面里面：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtkw6ed9rj30m70azmxp.jpg" alt=""></p><p>选择待解密文件以及密钥的路径即可解密：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtl0dy515j30m80b5dgi.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]李建华.网络空间威胁情报感知、共享与分析技术综述[J] .网络与信息安全学报， 2016, Vol. 2(2): 16-29. (样例)<br>[2] Christof Paar, Jan Pelzl.深入浅出密码学[M]. 北京: 清华大学出版社,2012.9 </p><p>[3]Jhajharia Smita. Implementation of Elliptic curve cryptosystem[M]. LAP Lambert Academic Publishing. 2015.7.2 </p><p>[4]Bruce Schneier. Applied Cryptography[M].Wiley. 2015.3.30</p><p>[5]Al Sweigart. Cracking Codes with Python[M]. No Starch Press. 2018.1.23<br>[6]Simon Monk. Raspberry Pi Cookbook. O’Reilly Media. 2016.6.12</p><p>[7]Alex Bradbury, Ben Everard. Learning Python with Raspberry Pi[M]. Wiley.<br>2014.3.10</p><p>[8]Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft. Java 8 in Action[M]. Manning<br>Publications. 2014.8.28</p><p>[9]SM2椭圆曲线公钥密码算法推荐曲线参数 国家密码管理局2010.12</p><p>[10]SM2 椭圆曲线公钥密码算法 国家密码管理局 2010.12</p><p>[11]SM3密码杂凑算法 国家密码管理局 2010.12</p><p>[12] WANG X, MIZUNO M,NEILSEN M,et al.Secure RTOS architecture for building<br>automation[C]//ACM Workshop on Cyber-Physical Systems-Security and/or<br>Privacy. 2015:79-90.</p><p>[13] SERPANOS D,PAPLAMBROU A.Security and privacy in distributed smart</p><p>camera[J].Proceeding softhe IEEE，2008,96(10):1678-1687. [14] 基于 TPM 的防泄漏方法 周亚建，彭维平，平源 2011.08.03 [15] 基于 TPM 的文件保护系统的研究与实现 张静 2014.07.23 </p><p>[16] 适用于移动通信视频点播的感知加密算法 2016.09.22<br>[17] 祖冲之算法在数字图像加密中的应用与实现 2012.10.11<br>[18] 基于国密 SM4 和 SM2 的混合密码算法研究与实现 2017.09.12<br>[19] An Efficient Image Encryption Scheme Based on ZUC Stream Cipher and Chaotic Logistic Map 2015.9.17 </p><p>[20] Power Analysis and Optimization of the ZUC Stream Cipher for LTE-Advanced<br>Mobile Terminals 2012.2.22</p>]]></content>
    
    
    <categories>
      
      <category>security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
