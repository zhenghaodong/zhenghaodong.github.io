<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;dark&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/17.jpeg"><link rel="icon" href="/img/17.jpeg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="Intel SGX机制"><meta name="author" content="wizard"><meta name="keywords" content="SGX"><title>Intel SGX - zhd&#39;s blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:30,cursorChar:"/",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>zhd's blog</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://tva1.sinaimg.cn/large/0082zybply1gbral1op4fj31ch0u0u10.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Intel SGX"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2019-11-03 17:35" pubdate>2019年11月3日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 42 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Intel SGX</h1><div class="markdown-body"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>SGX(software guard extensions)使应用程序在一段位于Enclave的地址空间中开辟一段地址空间。在enclave中运行的受保护程序还拥有一个密码学测度，这可被发送给客户端来验证程序的可信执行和为远程终端或不可信平台提供secrets。</p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><ul><li>允许应用程序开发者保护敏感数据不被未授权访问或者更高特权级别软件的修改</li><li>使得应用程序能够拥有保护敏感代码和数据的机密性与完整性的能力, 而不会中断这些资源被合法程序和系统调度、使用和管理的能力</li><li>使得计算设备的消费者能够控制自己平台, 并且具有自由安装和卸载应用与服务的能力</li><li>使得平台能够度量应用程序的可信代码, 生成签名验证, 并且度量和认证过程的代码都能够在可信赖的环境中正确的初始化</li><li>使得可信应用程序的开发过程中能够使用原来的工具和流程</li><li>允许可信应用程序的性能能够随着处理器的能力增强而得到扩展</li><li>使得软件代理商能够使用它们选择的分发通道来分发、更新可信应用程序</li><li>使得应用程序可以定义一个安全代码和数据区域, 这一区域可以维护其机密性, 即使攻击者能够物理上控制这个平台以及产生对内存的直接攻击, 也能够有效加以抵御</li></ul><h2 id="Enclave安全容器"><a href="#Enclave安全容器" class="headerlink" title="Enclave安全容器"></a>Enclave安全容器</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95of2rhnvj30sg0cp0wy.jpg" srcset="/img/loading.gif" lazyload alt="enclaves保护后的攻击面"></p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>Enclave俗称安全区，是一个被保护的安全内容容器，用于存放敏感代码与数据。对于加载进Enclave的代码和数据，系统会对其进行度量。在认证方面，Enclave会向远程认证者证明自己的身份，并提供必需的功能结构用于安全提供密钥，同时用户也可以请求独有的密钥，结合Enclave身份和平台的身份做到独一无二。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="EPC"><a href="#EPC" class="headerlink" title="EPC"></a>EPC</h4><p>Enclave代码和数据放置在被称为Enclave Page Cache（EPC）的特殊内存区域中，该内存区域使用内存加密引擎MEE进行加密，因此对于页面来说，只有在处理器内核才会被解密，而内存总线上的外部读取只会读到加密后的数据。关于MME加密所使用的密钥，该密钥只会在Enclave页面缓慢启动时生成并存储在CPU中。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95susnr6pj30lw0eygo1.jpg" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="EPCM"><a href="#EPCM" class="headerlink" title="EPCM"></a>EPCM</h4><p>EPCM是维护EPC的入口地址，并且包含CPU跟踪EPC内存页元数据的状态表。EPC内存以页的形式进行管理，一个页面对应EPCM的一个表项。它来保证每个EPC由一个Enclave独享。EPCM包含了每个页面的配置、权限和类型。</p><h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><h5 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h5><ul><li><p>为防止Enclave的内存不被特权软件染指，Intel专门保留了一块物理内存来支持SGX的相关功能：<strong>RPM</strong>。RPM也使用分页内存管理，使得EPC的内存页只能在处理器运行于Enclave模式下才能够被访问，enclave之外的软件无法访问EPC。</p></li><li><p>为了跟踪Enclave的身份，在每个Enclave中SGX使用了一个EPC页维护结构体SECS记录其元数据（enclave密码学测度等敏感信息）因此这段结构体只能被CPU的SGX管理机制访问修改。</p></li></ul><h5 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h5><p>Enclave与原宿主进程共享虚拟地址空间，从某种角度上来说，Enclave相当于源程序的动态链接库。部分Enclave中映射到EPC页的虚拟内存称为（enclave linear address range）ELRANGE。当从EPC页地址转换到物理地址时，CPU使用在SECS中存储的初始分配信息来保证传递给地址转换过程的EPC页虚拟地址与EPCM中保留的EPC入口地址相匹配。这样来防止操作系统将ELRANGE地址映射到不受保护的内存，使得ELRANGE内存对enclave之外的软件不可见。</p><p>SGX使用TCS来保存enclave内的预定义入口点信息，TCS保留在专门的EPC页中并且只能被SGX管理机制修改。</p><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><h4 id="Enclave"><a href="#Enclave" class="headerlink" title="Enclave"></a>Enclave</h4><p>每个Enclave都由其属性以及页面的位置、内容和保护的哈希值表示。每个Enclave也由其管理者进行签名， MRSIGNER包含管理者公钥的哈希值，MRENCLAVE和MRSIGNER使用SHA-256哈希函数生成。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>Einit指令使用EINITTOKEN结构来检查是否允许执行enclave。它包含enclave的属性，哈希和签名者身份，它使用启动密钥执行的HMAC进行身份验证。</p><p>SIGSTRUCT：每个enclave都与一个SIGSTRUCT结构相关联，该结构由管理者签名并包含enclave方法，签名者公钥，版本号（ISV，反映安全级别）和产品标识符（ISVPRODID，以区分同一管理者的enclave） 。它负责确保enclave未被修改，然后使用其他密钥重新签名。</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul><li>应用程序会请求将其enclave加载到内存中</li><li>ECREATE指令负责创建并填充SECS结构</li><li>使用EADD指令将每个页面加载到受保护的内存中</li><li>使用EEXTEND指令将每个页面添加到enclave检查中</li><li>EINIT指令最终完成对enclave的创建</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g95youg6ogj30p40h1472.jpg" srcset="/img/loading.gif" lazyload alt=""></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><h4 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h4><p>SGX有两种密钥：RootProvisionKey和RootSealKey。</p><ul><li>RootProvisionKey：RPKs被交付到不同的，被英特尔的正式出版物命名为“大容量制造系统”的生产设施中，被集成烧入到处理器内。Intel存储所有RPK，因为它们是SGX处理器通过在线供应协议验证其身份的基础。</li><li>RootSealKey:RSK也被保证在统计上不同部分的RSK是不同的，每个SGX都假设它的RSK值是唯一的，并且只有它自己知道。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9755rsqkrj30ig0bc42i.jpg" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="Root密钥派生"><a href="#Root密钥派生" class="headerlink" title="Root密钥派生"></a>Root密钥派生</h4><p>Enclave使用EGETKEY指令基于不同的请求参数和请求生成的密钥类型结合烧入的Root密钥来生成不同用途的密钥。</p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><h4 id="本地认证"><a href="#本地认证" class="headerlink" title="本地认证"></a>本地认证</h4><p>在enclaveA和enclaveB之间建立一个通道，enclaveA使用该通道来检索enclaveB的MRENCLAVE。Enclave A使用Enclave B的MRENCLAVE调用EREPORT来为Enclave B生成签名报告，通过使用ERREPORT指令，enclave可以获取用来描述其软件和硬件TCB的硬件断言。返回的Report包含enclave的属性、测度值和ISV附加数据。Enclave B调用EGETKEY来检索其报告密钥并验证EREPORT结构的MAC，如果有效，则enclave是预期的并且在合法平台上运行。</p><p>在本地认证中第一次成功过后，因为可以确保是使用真正调用者属性填充的REPORT，因此后续对于认证过的enclave见证只需要根据预期认证要求验证报告字段就行了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g975wapfvtj30ke06oq46.jpg" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="远程认证"><a href="#远程认证" class="headerlink" title="远程认证"></a>远程认证</h4><h5 id="获取远程认证密钥"><a href="#获取远程认证密钥" class="headerlink" title="获取远程认证密钥"></a>获取远程认证密钥</h5><p>SGX的预备服务和远程认证过程是使用Intel设计的称为EPID的组签名方法，为了实现EPID预备过程Intel提供了一个特殊的Enclave Povision Enclave(PvE)。</p><p><strong>PvE</strong>：负责在平台上使用Intel的在线供应服务器执行预备过程。PvE使用一些只能由特殊enclave生成的SGX特权密钥。这两种密钥分别是Provision Key和Provision Seal Key。基于特殊enclave他们直接被intel签名的SIGSTRUCT证书，因此使用特权属性启动的特殊enclave能够使用EGETKEY来获取这两种特权密钥。</p><h5 id="预备协议"><a href="#预备协议" class="headerlink" title="预备协议"></a>预备协议</h5><ul><li><p>Enclave hello：得到硬件TCB的特定PrK之后，PvE使用两个值来初始化预备协议</p></li><li><p>服务器挑战：Intel适用PPID来判断平台以前是否已经预备化过，如果已经完成预备化，则服</p><p>务器将加密过后的以往生成的认证密钥添加到挑战中去。其他情况则是服务器验证是否给此EPID组提供服务，接着将EPID组参数、随机参数(nouce)和预计算的TCB挑战返回给平台。</p></li><li><p>Enclave回复：PvE解开挑战之后，通过使用TCB挑战作为密钥计算CMAC来生成TCB证明，接着PvE自己产生一个随机EPID成员密钥是用数学方法隐藏密钥从而避免Intel的Provision服务器获取到平台生成的成员密钥信息获得一定的匿名性。</p></li><li><p>完成：服务器收到回复之后，首先验证TCB证明中使用的值是否余iKGF中收到的一样，如果一致则继续EPID参与协议。紧接着处理隐藏的成员密钥创建使用EPID组发布者密钥签名的唯一证书并与加密的成员密钥一起存储。</p></li><li><p>解密：PvE使用PSK解密认证密钥，并将其奉存在Enclave外以备后用。由于EPID组按照TCB级别进行分类，因此平台的EPID签名可以在以后使用。</p></li></ul><h5 id="远程认证-1"><a href="#远程认证-1" class="headerlink" title="远程认证"></a>远程认证</h5><p>远程认证涉及到两个独立的参与者：证明者和参与者。</p><ul><li><p>最初，enclave会通知应用程序，它需要在位于平台外部的某个位置加密。此时，应用程序与服务器建立安全通信，服务器对此请求进行回应，以认证正在执行的enclave没有被篡改，并且它执行的平台是合法的；</p></li><li><p>该应用程序为其enclave提供了Quoting Enclave标识和认证请求；</p></li><li><p>enclave产生一个包括认证回应和临时公钥的清单，该公钥将在稍后被用于保护服务器和enclave之间的通信。而生成的哈希，则包含在EREPORT指令的用户数据部分中。该指令为Quoting Enclave生成一个报告，将清单与enclave关联起来，此时，enclave将REPORT发送给应用程序；</p></li><li><p>该应用程序将REPORT发送到Quoting Enclave进行验证和签名；</p></li><li><p>QE使用EGETKEY指令检索其报告密钥并验证REPORT，它会创建QUOTE结构，并在将其提供给应用程序之前使用其Provisioning Key对其进行签名；</p></li><li><p>应用程序将QUOTE和关联的清单发送到服务器进行验证；</p></li><li><p>服务器使用Intel提供的认证服务来验证QUOTE签名，然后，它使用QUOTE用户数据中的哈希检查清单完整性。以确保清单包含对认证的预期响应。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g99hblefenj30g2074tap.jpg" srcset="/img/loading.gif" lazyload alt=""></p><h2 id="相关研究"><a href="#相关研究" class="headerlink" title="相关研究"></a>相关研究</h2><h3 id="针对SGX的攻击"><a href="#针对SGX的攻击" class="headerlink" title="针对SGX的攻击"></a>针对SGX的攻击</h3><h4 id="side-channel-attack"><a href="#side-channel-attack" class="headerlink" title="side-channel attack"></a>side-channel attack</h4><ul><li>丰富的攻击面：Enclave运行环境有大量资源与外面的non-enclave公用，如cache、页表、TLB、DRAM以及分支预测器等。</li><li>操作系统不可信：操作系统负责管理系统的资源：页表、内存、中断、进程调度等，但操作系统本身并不可信</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g99j89mxeej30o40he41n.jpg" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="基于页表进行攻击"><a href="#基于页表进行攻击" class="headerlink" title="基于页表进行攻击"></a>基于页表进行攻击</h4><p>利用页表对enclave页面的访问控制权设置enclave的页面为不可访问。此时访问enclave页面就会触发缺页异常，进而可以区分出enclave访问了哪些页面，按照”时间”将信息按顺序组合，就可以反推出enclave的某些状态和保护的数据。</p><ul><li>优点：可以获得大量有用的信息</li><li>缺点：该攻击只能达到页粒度，无法区分更细粒度的信息</li></ul><p><strong>变种</strong>：利用页表的状态位，通过观察这些状态位，攻击者可以获取类似的大量有用信息。</p><h4 id="基于TLB的攻击"><a href="#基于TLB的攻击" class="headerlink" title="基于TLB的攻击"></a>基于TLB的攻击</h4><p>目前出现的都是以TLB作为辅助手段的侧信道攻击</p><h4 id="基于cache的攻击"><a href="#基于cache的攻击" class="headerlink" title="基于cache的攻击"></a>基于cache的攻击</h4><p>优点：SGX环境中攻击者可以控制整个系统的资源，因此攻击者可以有针对的调度资源并减少侧信道的噪音增加攻击的成功率。</p><p><strong>降低噪音的方式</strong>：</p><ul><li>核隔离：让Enclave独自占用一个核</li><li>缓存隔离：尽量使用L1或者L2级别的cache进行侧信道攻击，L3的cache会被所有核共用，会引入不必要的噪音</li><li>不间断运行：不触发或尽量少触发AEX（AEX和后续的ISR都会使用cache从而引入不必要的噪音）</li></ul><p><strong>提高攻击精度的方式</strong>：</p><ul><li>高精度时钟：采用APIC提供的高精度时钟和硬件TSC</li><li>放大时间差异：攻击者可以配置侧信道攻击代码所在的CPU以最高频率运行，而对Enclave所在的CPU进行降频处理</li></ul><h4 id="基于DRAM的攻击"><a href="#基于DRAM的攻击" class="headerlink" title="基于DRAM的攻击"></a>基于DRAM的攻击</h4><p>缺点：enclave 使用的内存通常都在缓存里面，只有少部分需要从DRAM 里面去取；DRAM的精度不够；DRAM里面存在很难避免的噪音干扰，因为一个DRAM row 被很多页面使用，同时同一个bank 不同row的数据读取也会对时间测量造成干扰，使得误报时常发生。</p><h4 id="基于CPU内部结构的攻击"><a href="#基于CPU内部结构的攻击" class="headerlink" title="基于CPU内部结构的攻击"></a>基于CPU内部结构的攻击</h4><p>CPU 内部有大量的结构是在enclave 和non-enclave 之间共用的。这就给侧信道攻击提供了大量的攻击面素材。</p><p>注：关于利用CPU内部结构攻击SGX的研究才刚刚开始，因此这里不进行概括。</p><h4 id="混合侧信道攻击"><a href="#混合侧信道攻击" class="headerlink" title="混合侧信道攻击"></a>混合侧信道攻击</h4><p>混合侧信道攻击是同时采集多个侧信道攻击面的信息，或通过多个攻击面共同作用放大差异增加准确度。</p><p>做法：</p><ul><li>TLB 和页表混合攻击。比如TLB miss 的时候会加载页表，这个时候CPU 会设置页表的Access bit。</li><li>Cache 和DRAM 混合攻击。</li></ul><h4 id="侧信道攻击的防御"><a href="#侧信道攻击的防御" class="headerlink" title="侧信道攻击的防御"></a>侧信道攻击的防御</h4><h5 id="在源码层面进行防御"><a href="#在源码层面进行防御" class="headerlink" title="在源码层面进行防御"></a>在源码层面进行防御</h5><p>修改源码从而隐藏控制流和程序流。</p><h5 id="系统层次防御"><a href="#系统层次防御" class="headerlink" title="系统层次防御"></a>系统层次防御</h5><ul><li>将随机化技术应用在控制流和数据流上面，从而大大增加侧信道攻击的代价。</li><li>检测可疑的中断或异常从而抵御最原始的controlled-channel 攻击</li><li>检测时间的异常，如果攻击者中断或减缓enclave 的运行，enclave就可以通过自己的时钟检测出时间上的异常。目前，绝大多数侧信道攻击都会引起enclave 的显著性能下降。因此，检测时间异常还是一个比较有效的方案。</li><li>Cache隔离</li></ul><h5 id="硬件层次防御"><a href="#硬件层次防御" class="headerlink" title="硬件层次防御"></a>硬件层次防御</h5><p>目前针对于硬件层次的防御还处于探索阶段，目前主要有两种解决思路：</p><ul><li>硬件分割，类似于ARM的Trust Zone那样，有自己的cache、memory等硬件资源</li><li>硬件隔离，类似于Intel CAT技术，可以单独为每一个enclave 提供一个动态隔离出的cache。当enclave 销毁的时候，隔离出的cache 可以被收回。</li></ul><h4 id="同步攻击"><a href="#同步攻击" class="headerlink" title="同步攻击"></a>同步攻击</h4><p>AsyncShock攻击的原理就是充分利用enclave内现有的同步错误，特别是，它有助于利用Use After Free（UAF）漏洞和Time Of Check Time Of Use（TOCTOU）漏洞。控制该平台的攻击者（在英特尔SGX的攻击模型中）可以随时中断enclave线程。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9ajwmrt2gj30ga0f73zq.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>不过这类攻击需要完全控制平台，知道enclave内运行的代码，并在其中发现同步漏洞。防止这种攻击的最佳方法是在enclave内禁用多线程，但这显然会妨碍程序的性能。另一种解决方案是加密enclave的代码，并使用远程认证过程为enclave提供解密其代码所需的密钥。</p><h4 id="分支追踪推断SGX-Enclave内部的详细控制流程"><a href="#分支追踪推断SGX-Enclave内部的详细控制流程" class="headerlink" title="分支追踪推断SGX Enclave内部的详细控制流程"></a>分支追踪推断SGX Enclave内部的详细控制流程</h4><p>在不受信任的环境中复制enclave程序的控制流程，然后仔细的选择映射此新代码的地址，以便在BTB（Branch Target Buffer）内部引入冲突事件。首先在enclave代码内执行分支，然后在被跟踪的代码中执行分支，此时第二个分支的预测将受到第一个分支的结果的影响。要知道CPU预测的内容，最后一个分支记录（ Last Branch Record，LBR）只能在不受信任的环境中使用，因为它对于enclave来说是禁用的。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/security/">security</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/system-security/">system security</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2020/01/03/2019-12-31-Code-Pointer%20Integrity/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Code-Pointer Integrity</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2019/08/03/PCAM%E8%AE%BE%E8%AE%A1/"><span class="hidden-mobile">PCAM设计</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/boot.js"></script></body></html>