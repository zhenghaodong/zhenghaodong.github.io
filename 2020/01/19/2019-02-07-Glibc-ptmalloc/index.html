<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;dark&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/17.jpeg"><link rel="icon" href="/img/17.jpeg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="学习堆内存分配安全的必经之路"><meta name="author" content="wizard"><meta name="keywords" content="ptmalloc"><title>ptmalloc解析 - zhd&#39;s blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:30,cursorChar:"/",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>zhd's blog</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://tva1.sinaimg.cn/large/0082zybply1gbss5d0prgj31900u0npq.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="ptmalloc解析"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-01-19 09:22" pubdate>2020年1月19日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 53 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">ptmalloc解析</h1><div class="markdown-body"><blockquote><p>ptmalloc是glibc中内置分配器的原型，稍稍总结一下ptmalloc的原理以及常见的利用思路</p></blockquote><h2 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h2><p>从微观角度来看，堆有以下几种操作：</p><ul><li>申请内存</li><li>释放内存</li></ul><h3 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h3><p>本质上来讲，ptmalloc来申请内存，其实主要是执行以下过程。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cs2hk7bpj30ch0czjrp.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>对于使用mmap还是<code>_brk</code>，ptmalloc有自己的规则，默认情况下当申请的内存小于128kb时，使用<code>_brk</code>，当申请的内存大小大于128kb时，ptmalloc使用mmap来申请内存。</p><h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><p>ptmalloc使用free函数来释放内存。free 函数会释放由free函数的参数所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p><p>此外，该函数也同样对异常情况进行了处理</p><ul><li>当 p 为空指针时，函数不执行任何操作。</li><li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li><li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</li></ul><h2 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h2><h3 id="chunk结构"><a href="#chunk结构" class="headerlink" title="chunk结构"></a>chunk结构</h3><p>在ptmalloc中最基本的分配单位是chunk块，其结构如下所示：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span> &#123;<br><br>  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  前一块为释放状态时的大小 */</span><br>  INTERNAL_SIZE_T      mchunk_size;       <span class="hljs-comment">/* Size in bytes, including overhead. 大小，以字节为单位，包括额外内容 */</span><br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* fd;         <span class="hljs-comment">/* double links -- used only if free. 双链表，只在为释放状态是使用 */</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* bk;<br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-comment">/* 只在large块时使用：指向下一个更大大小的指针 */</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* fd_nextsize; <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-type">malloc_chunk</span>* bk_nextsize;<br>&#125;;<br></code></pre></td></tr></table></figure><p>直观来说是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9crel4vhzj30kd06275t.jpg" srcset="/img/loading.gif" lazyload alt=""></p><blockquote><p>注：</p><ul><li>chunk的第二个域的最低一位P表示前一个chunk是否是在使用当中（0代表前一个空闲，1代表在使用当中）。当P为0时，此时prev_size才有效，第一个域表示的是前一个chunk的size，可以通过这个值取到前一个chunk的开始地址；当P为1时，表示前一个chunk在使用当中，prev_size无效。<br>ptmalloc分配的第一个chunk总是将P设为1，以防止程序引用到不存在的区域。</li><li>chunk第二个域倒数第二位M（0表示是从mmap映射区域分配的，1表示heap区域分配）</li><li>chunk第二个域倒数第三位A（1表示主分配区，0非主分配区）</li></ul></blockquote><h3 id="管理结构"><a href="#管理结构" class="headerlink" title="管理结构"></a>管理结构</h3><p>ptmalloc在申请那么多个chunk之后为了效率，使用了自己本身的特殊结构来对其进行管理，也就是bins和fastbin等。</p><h4 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h4><p>直观来看，看下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9cs74wi7dj30lo0awt9o.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>所以说所谓的bins其实是一个大数组，bins数组总共分为三种：<strong>unsorted bin</strong>、<strong>small bin</strong>、<strong>large bin</strong>。</p><p>不同的bins内存储的chunk、存储规则、自身特性都是不一样的。</p><h5 id="unsorted-bins"><a href="#unsorted-bins" class="headerlink" title="unsorted bins"></a>unsorted bins</h5><p>作为bins数组中的第一部分，unsorted bin是一个遵循<strong>先进先出原则</strong>的双向链表，且其中存放的chunk是一个乱序状态（也就是说unsorted bin中的chunk的排序与chunk的属性如size、prev_size无关）。</p><p>unsorted bin中chunk的来源：</p><ul><li>一个较大的chunk A，A被分割成两半，如果剩下的部分&gt;MIN_SIZE，则这部分会被放进unsorted bin中</li><li>释放一个不属于fast bins的chunk且该chunk与top chunk相隔（top chunk待会讲）的时候，该chunk会被首先放进unsorted bin中</li></ul><p><strong>unsorted bin在内存分配中充当的角色</strong>：在进行 malloc 操作的时候，如果在 fast bins 中没有找到合适的 chunk，则 ptmalloc 会先在 unsorted bin 中查找合适的空闲 chunk，然后才查找 bins。如果 unsorted bin 不能满足分配要求。malloc便会将 unsorted bin 中的 chunk按照规则加入 bins 中。然后再从 bins 中继续进行查找和分配过程。</p><p>由此可见，其实unsorted bin相当于small bin和large bin的一个缓冲区。</p><h5 id="small-bin-amp-large-bin"><a href="#small-bin-amp-large-bin" class="headerlink" title="small bin &amp; large bin"></a>small bin &amp; large bin</h5><p>bins数组中从2开始编号前64个bin称为small bin，small bin中每个bin的大小都与其对应的index成以下关系：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">chunk_size</span> = <span class="hljs-number">2</span> * SIZE_SZ *index<br></code></pre></td></tr></table></figure><p>具体数值可以参考下表：（仔细看发现每个链表所存储的chunk的大小是成等差数列的）</p><div class="table-container"><table><thead><tr><th style="text-align:center">下标</th><th style="text-align:center">32bit</th><th style="text-align:center">64bit</th></tr></thead><tbody><tr><td style="text-align:center">2</td><td style="text-align:center">16</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">24</td><td style="text-align:center">48</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">32</td><td style="text-align:center">64</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">2 <em>4 </em>a</td><td style="text-align:center">2 <em>8 </em>a</td></tr><tr><td style="text-align:center">63</td><td style="text-align:center">504</td><td style="text-align:center">1008</td></tr></tbody></table></div><p>small bin中每个 bin 对应的双向链表采用 FIFO 的规则，同一个链表中先被释放的 chunk 会先被分配出去。</p><p>bins中剩下的就是large bin了，仔细算一下，large bin包含了63个bins，不过不同于small bin，large bin并不是把大小相等的chunk存储在同一个双向链表里面，相反，large bin中每个bin里存储的chunk的大小都是不一致的，不过每个bin（链表）中，存储的chunk的size都是一个等差数列，具体看下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">下标</th><th style="text-align:center">数量</th><th style="text-align:center">公差</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">32</td><td style="text-align:center">64B</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">16</td><td style="text-align:center">512B</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">8</td><td style="text-align:center">4096B</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">32768B</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">262144B</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">1</td><td style="text-align:center">不限制</td></tr></tbody></table></div><p>这里可能有点抽象，可以通过一个例子来理解：<br>在32位机器下，large bin的启示存储chunk大小为512字节，那么这个large bin链表 可以存储的chunk的大小范围就是[512,512+64]。其中每一个链表中的 chunk 按大小序排列，相同大小的 chunk 同样按照最近使用顺序排列。</p><h4 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h4><p>试想一下一个只有bins结构的堆分配器，如果我们合并了几个相邻的chunk之后紧接着申请一个比较小的chunk，那作为分配器来讲，又需要从大内存块中申请一个小的内存块，这样看来似乎不是最佳的解决办法。因此ptmalloc引入了fast bins这个单向链表结构。</p><p>首先ptmalloc规定了一个常量：<strong>max_fast</strong> = 64B。</p><ul><li>从内存回收的角度来说，对于小于max_fast的被释放的chunk，ptmalloc会首先将其放入fast bins中，此时该chunk的P标志位（使用标志位）不被改变，也就是说在P不被改变的情况下，此时fast bins中的chunk不会被合并。</li><li>从内存分配的角度来讲，用户申请一个小于max_fast大小的chunk的时候，ptmalloc会首先在fast bins中查找是否有合适的chunk，有的话会直接分配，没有的话ptmalloc才会开始查找bins中是否有合适的chunk。</li></ul><p><strong>由此看来，fast bins相当于整个bins的一个缓冲区</strong>。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>并不是所有chunk都按照以上规则来分配，ptmalloc中有三种特殊的chunk：<strong>top chunk</strong>、<strong>mmaped chunk</strong>、<strong>last remainder</strong>。</p><h5 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h5><p>应用程序第一次malloc的时候，heap会被分为两段，一段给用户，另一段就是top chunk。从物理地址的角度来看，形象来说可以看下面这个图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9dwemdsz6j30ck0btq33.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>top chunk的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</p><h5 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h5><p>当需要分配的 chunk 足够大，而且 fast bins 和 bins 都不能满足要求，甚至 top chunk 本身也不能满足分配需求时，ptmalloc 会使用 mmap 来直接使用内存映射来将页映射到进程空 间。这样分配的 chunk 在被 free 时将直接解除映射，于是就将内存归还给了操作系统，再 次对这样的内存区的引用将导致segmentation fault 错误。这样的 chunk 也不会包含在任何bin中。</p><h5 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h5><p>Last remainder 是另外一种特殊的 chunk，就像 top chunk 和 mmaped chunk 一样，不会 在任何 bins 中找到这种 chunk。当需要分配一个 small chunk，但在 small bins 中找不到合适 的 chunk，如果 last remainder chunk 的大小大于所需的 small chunk 大小，last remainder chunk 被分裂成两个 chunk，其中一个 chunk 返回给用户，另一个 chunk 变成新的 last remainder chuk。</p><blockquote><p>那么ptmalloc的管理结构的介绍就结束了，接下来我们把它们整合一下，从整体来看，分配内存和释放内存时各个管理结构各自充当的角色。</p></blockquote><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ol><li>用户申请内存</li><li>ptmalloc判断所需分配的chunk的大小是否&lt;=max_fast(64B)，如果小于，则继续执行第3步；否则跳转到第4步</li><li>chunk大小小于max_fast，首先尝试在 fast bins 中取一个所需大小的 chunk 分配给用户。如果可以找到，则分配结束。否则转到下一步</li><li>chunk大小大于max_fast，判断所需大小是否处在 small bins 中，即判断 chunk_size &lt; 512B 是否成立。如果chunk 大小处在 small bins 中，则转至第5步，否则转至第6步</li><li>chunk大小处在small bins中，则找到具体的small bin，然后从这个bin的尾部取下一个chunk，分配结束</li><li>chunk大小不处在small bins中，此时说明用户申请的内存比较大，或者small bins中没有合适的小内存。因此ptmalloc会遍历fast bin，将相邻的chunk合并，合并后的chunk会链入unsorted bin中；紧接着ptmalloc会遍历unsorted bin中的chunk，寻找合适的chunk来分配给用户。如果 unsorted bin 只 有一个 chunk，并且这个 chunk 在上次分配时被使用过，并且所需分配的 chunk 大 小属于 small bins，并且 chunk 的大小大于等于需要分配的大小，这种情况下就直接将该 chunk 进行切割，分配结束，否则将根据 chunk 的空间大小将其放入 small bins 或是 large bins 中，遍历完成后，转入下一步。</li><li>如果此时还没有成功分配内存，就说明用户申请的是一块比较大的内存，或者说small bins和unsorted bin中没有找到相关的chunk，注意此时fast bins和unsorted bin中所有的chunk都已经清除干净了。那么就从large bins中寻找一个合适的chunk，从该chunk中划分出所需大小的chunk，剩下的部分链接回bins中。若操作成功，则分配完成。</li><li>如果large bins也分配失败，就说明需要使用top chunk来进行分配。如果top chunk大小满足所需分配的chunk的大小，就从top chunk中分离出一块来分配给用户。</li><li>如果top chunk也分配失败，那么此时有两个选择：主分配区来说调用sbrk()函数来增加top chunk的大小而非主分配区来说，调用mmap来形成一个新的sub-heap，增加top chunk的大小；直接利用mmap函数进行分配。对于是否使用mmap来分配内存，取决于所分配的chunk的大小是否大于、等于mmap分配的阈值，如果大于、等于，则使用mmap来分配，否则增加top chunk的大小。</li></ol><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><ol><li>判断所释放的chunk是否为mmaped chunk，如果是，则调用munmap()释放mmaped chunk，解除内存空间映射</li><li>判断chunk的大小以及位置，如果chunk的大小&lt;=max_fast，并且chunk并不位于heap的顶部，则说明该chunk并不与top chunk相邻，否则跳转到第4步</li><li>将chunk放到fast bin中(并不修改当前chunk的P位)，程序从free函数返回</li><li>判断前一个chunk是否在使用中，如果前一个chunk也是空闲块，则合并</li><li>判断当前释放chunk的下一块是否为top chunk，如果为top chunk，则将它与top chunk合并并更新top chunk的大小；如果不是，则判断下一个chunk是否在使用中，如果空闲，则合并并将其放入unsorted bin中</li><li>判断合并后的 chunk 的大小是否大于 FASTBIN_CONSOLIDATION_THRESHOLD (默认64kb)，如果是的话，则会触发进行fast bins的合并操作，fast bins中的chunk将被遍历并与相邻的空闲chunk进行合并放到unsorted bin中，结束后fast bins将会为空</li></ol><h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><p>tcache是glibc2.26(Ubuntu17.04之后)引入的一种新的技术，tcache的目的是提升堆管理的性能，是一个用于加速malloc分配的缓存结构，有由64个链表组成。其优先级很高，会先于全部的bin来处理。每个链表的个数是一定的，当缓存链表装满时，分配方式就与之前版本的malloc相同。但使用了tcache版本的malloc与free函数时，对于堆块的安全性检查就相比于之前的版本弱化很多。</p><h4 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h4><p><strong>tcache_entry</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br>typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">tcache_entry</span><br>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-type">tcache_entry</span> *next;<br>&#125; tcache_entry;<br></code></pre></td></tr></table></figure><p>作用：连接空闲的chunk结构体，其中的next指针指向下一个大小相同的chunk中的user data(fast bins中的fd指向的是chunk开头的地址)且tcache_entry 会复用空闲 chunk 的 user data 部分。</p><p><strong>tcache_perthread_struct</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> TCACHE_MAX_BINS                64</span><br><br><span class="hljs-keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>tcache_prethread_struct是整个tcache的管理结构，一共有TCACHE_MAX_BINS个计数器和TCACHE_MAX_BINS项 tcache_entry。</p><ul><li><code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</li><li><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk。</li></ul><p>借用ctf wiki上面一张图来清晰地展示一下这些结构：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9t2lhks4aj30ry0f0wgr.jpg" srcset="/img/loading.gif" lazyload alt=""></p><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul><li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_prethread_struct</code> 。</li><li>free 内存，且 size 小于 small bin size 时</li><li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li><li>tcache 后：<ul><li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li><li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li><li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li></ul></li><li>malloc 内存，且 size 在 tcache 范围内</li><li>先从 tcache 取 chunk，直到 tcache 为空</li><li>tcache 为空后，从 bin 中找</li><li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk，会先把<code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在bin 中和 tcache 中的顺序会反过来</li></ul><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>unlink是发生在双向链表中取出空闲块的过程中的主要操作（例如 free 时和目前物理相邻的 free chunk 进行合并）。</p><p>借用CTF WIKI中的一张图：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9sm3jv3izj30ks0gnwh7.jpg" srcset="/img/loading.gif" lazyload alt=""></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define unlink(P, BK, FD) &#123;                       \</span><br>    FD = P-&gt;fd;                                   <span class="hljs-string">\</span><br>    BK = P-&gt;bk;                                   <span class="hljs-string">\</span><br>    FD-&gt;bk = BK;                                  <span class="hljs-string">\</span><br>    BK-&gt;fd = FD;                                  <span class="hljs-string">\</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>对于free一个块的时候，会按以下步骤执行：</p><ul><li>glibc 判断这个块是 small chunk</li><li>判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</li><li>判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</li><li>继而对 Nextchunk 采取 unlink 操作</li></ul><p>执行unlink达到的效果：</p><ul><li>FD=P-&gt;fd = target addr -12</li><li>BK=P-&gt;bk = expect value</li><li>FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value</li><li>BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12</li></ul><p><strong>针对于这个效果，我们可以通过一些手段达到任意地址写的目的</strong>：</p><ul><li>首先FD = nextchunk-&gt;fd = free地址 – 12</li><li>然后BK = nextchunk-&gt;bk = shellcode起始地址；</li><li>再将BK赋值给FD-&gt;bk，即（free地址 – 12）-&gt;bk = shellcode起始地址；</li><li>最后将FD赋值给BK-&gt;fd，即(shellcode起始地址)-&gt;fd = free地址 – 12。</li></ul><p>我们结合chunk的结构来理解：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9smpdr89vj30us0bajt2.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>32bit系统下，一个int型是4字节，因此从free addr-12，指针就指向了chunk的头部也就是nextchunk中fd指针指向的位置，第3步操作的结果就是将free addr处的数据替换为shellcode 的起始地址。由于已经将free addr处的数据替换为了shellcode的起始地址，所以当程序在代码处再次执行free的时候，就会转而执行shellcode了。</p><p>但是目前的ptmalloc对于这种利用unlink达到任意地址写的操作有了一个检测方式：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">// fd bk</span><br><span class="hljs-function"><span class="hljs-title">if</span> (__builtin_expect (FD-&gt;</span><span class="hljs-function"><span class="hljs-title">bk</span> != P || BK-&gt;</span>fd != P, <span class="hljs-number">0</span>))                      \<br>  malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \<br></code></pre></td></tr></table></figure><p>此时以上使用shellcode地址来执行任意地址写的方式失败，无法通过if判断条件。</p><p>新的利用方式：</p><ul><li>分配两个长度合适的堆块（两个堆块的fd、bk指针为空，原因是正在使用中）</li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">chunk0                malloc返回的ptr        chunk1        malloc返回的ptr<br>|<span class="hljs-string">                     </span>|<span class="hljs-string">                     </span>|<span class="hljs-string">             </span>|<br>+-----------+---------+---+---+-------------+------+------+----+----+------+<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<span class="hljs-string">             </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<span class="hljs-string">             </span>|<span class="hljs-string"> prev </span>|<span class="hljs-string"> size&amp;</span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string"> prev_size </span>|<span class="hljs-string">size&amp;Flag</span>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<span class="hljs-string">             </span>|<span class="hljs-string"> size </span>|<span class="hljs-string"> flag </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<span class="hljs-string">             </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<span class="hljs-string">             </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>+-----------+---------+---+---+-------------+------+------+----+----+------+<br></code></pre></td></tr></table></figure><ul><li>对第一个chunk进行编辑，在第一个chunk的内部伪造一个假的chunk，编辑的过程中设置好第0块的bk和fd指针并溢出第一块，改好第一块的chunk头的控制信息</li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">chunk0                malloc返回的ptr           chunk1        malloc返回的pt<br>|<span class="hljs-string">                     </span>|<span class="hljs-string">                        </span>|<span class="hljs-string">             </span>|<br>+-----------+---------+----+----+----+----+----+------+------+----+----+------+<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">fake</span>|<span class="hljs-string">fake</span>|<span class="hljs-string">fake</span>|<span class="hljs-string">fake</span>|<span class="hljs-string"> D  </span>|<span class="hljs-string"> fake </span>|<span class="hljs-string"> fake </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">prev</span>|<span class="hljs-string">size</span>|<span class="hljs-string"> FD </span>|<span class="hljs-string"> BK </span>|<span class="hljs-string"> A  </span>|<span class="hljs-string"> prev </span>|<span class="hljs-string"> size&amp;</span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string"> prev_size </span>|<span class="hljs-string">size&amp;Flag</span>|<span class="hljs-string">size</span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> T  </span>|<span class="hljs-string"> size </span>|<span class="hljs-string"> flag </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> A  </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<span class="hljs-string">      </span>|<span class="hljs-string">    </span>|<span class="hljs-string">    </span>|<span class="hljs-string">      </span>|<br>+-----------+---------+----+----+----+----+----+------+------+----+----+------+<br>                      |<span class="hljs-string">--------new_size--------</span>|<br></code></pre></td></tr></table></figure><ul><li>伪造了prev_size和size的部分，然后溢出堆块1，改掉第1个堆块的prev_size,数值应该是上图所示 <code>new_size</code> 的大小；另外第1块的size部分还要把prev_inuse的flag给去掉</li></ul><p>具体的伪造数据：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">p32</span>(<span class="hljs-number">0</span>) + p<span class="hljs-number">32</span>(<span class="hljs-number">81</span>) + p<span class="hljs-number">32</span>(&amp;fake_chunk-<span class="hljs-number">12</span>) + p<span class="hljs-number">32</span>(&amp;fake_chunk-<span class="hljs-number">8</span>) + <span class="hljs-string">&quot;A&quot;</span>*(<span class="hljs-number">80</span>-<span class="hljs-number">4</span>*<span class="hljs-number">4</span>) + p<span class="hljs-number">32</span>(<span class="hljs-number">80</span>) + p<span class="hljs-number">32</span>(<span class="hljs-number">88</span>)<br></code></pre></td></tr></table></figure><p>这样的话将chunk 0的mem空间伪造成一个fake_chunk，其中fake_fd=p32(&amp;fake_chunk-12) 代表伪造的chunk头在程序内存空间中的地址-12， fake_bk=p32(&amp;fake_chunk-8) 这样做的话执行unlink操作时就会按以下内容进行：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FD</span>=P-&gt;fd = &amp;fake_chunk-<span class="hljs-number">12</span> ，<br><span class="hljs-attribute">BK</span>=P-&gt;bk = &amp;fake_chunk-<span class="hljs-number">8</span> ，<br><span class="hljs-attribute">FD</span>-&gt;bk ，即 *(&amp;fake_chunk-<span class="hljs-number">12</span>+<span class="hljs-number">12</span>) = *(&amp;fake_chunk) = buf[<span class="hljs-number">0</span>] = fake_chunk = p <br><span class="hljs-attribute">BK</span>-&gt;fd ，即*(&amp;fake_chunk-<span class="hljs-number">8</span>+<span class="hljs-number">8</span>) = *(&amp;fake_chunk) = buf[<span class="hljs-number">0</span>] = fake_chunk = p<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/CTF/">CTF</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/PWN/">PWN</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2020/01/29/2020-01-29-GCC-Plugin/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">GCC Plugin实践</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2020/01/03/2019-12-31-Code-Pointer%20Integrity/"><span class="hidden-mobile">Code-Pointer Integrity</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/boot.js"></script></body></html>