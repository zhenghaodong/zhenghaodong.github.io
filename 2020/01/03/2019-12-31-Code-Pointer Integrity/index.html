<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;dark&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/17.jpeg"><link rel="icon" href="/img/17.jpeg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="关于代码指针完整性的论文阅读"><meta name="author" content="wizard"><meta name="keywords" content="Memory safety"><title>Code-Pointer Integrity - zhd&#39;s blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:30,cursorChar:"/",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>zhd's blog</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(https://tva1.sinaimg.cn/large/0082zybply1gbss5d0prgj31900u0npq.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="Code-Pointer Integrity"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-01-03 09:22" pubdate>2020年1月3日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 35 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">Code-Pointer Integrity</h1><div class="markdown-body"><h1 id="Code-Pointer-Integrity"><a href="#Code-Pointer-Integrity" class="headerlink" title="Code-Pointer Integrity"></a>Code-Pointer Integrity</h1><p><strong>这篇论文发表在osdi 14会议上的论文，提出了一种新的保护方式：CPI(代码指针完整性)</strong></p><h2 id="摘要部分"><a href="#摘要部分" class="headerlink" title="摘要部分"></a>摘要部分</h2><p>这篇文章在摘要就指出现在大多数程序员所使用的编程语言如C和C++，在提供强大功能的同时也过度将内存管理这个任务委托给了程序员，因此内存安全问题成了一个让大多数安全人员头疼的问题。作者同时也指出了目前针对这个问题所提出的一些防御机制，如CFi，存在开销较高且保障工作有限的问题，因此这篇文章站在这些问题的基础上提出了本文的核心：作者引出了”代码指针完整性”这一保护机制，它的优势总体来说有以下几点：</p><ul><li>保证所有代码指针的完整性从而防止控制流劫持攻击</li><li>高效低开销</li></ul><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><blockquote><p>关于敏感指针的定义：</p><ul><li>函数指针</li><li>指向敏感类型的指针</li><li>指向有一或多个成员是敏感类型的复合类型（结构体或数组）</li><li>所有在编译或运行是隐式生成的代码指针（返回地址，C++虚函数表，setjmp缓存）</li></ul></blockquote><h3 id="代码指针完整性属性"><a href="#代码指针完整性属性" class="headerlink" title="代码指针完整性属性"></a>代码指针完整性属性</h3><p>对于一个程序，只有它的间接引用或者访问的敏感指针是安全的，它才是满足代码指针完整性属性的程序。关于敏感指针可以参考下面这张图片：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga8rwyeyg1j30h109rdgp.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>在此图的结构中，CPI保护机制保护指针1、2、3、4(由于3、4直接指向函数a和b，而1和2可能会指向3和4，因此1、2、3、4都会被保护) ，同时敏感指针的定义是一个动态的，比如指针2指向3或4时，它是一个敏感指针，而它指向int整数时，它不是敏感的。</p><p>除此之外，本文的团队通过研究其他最先进的内存保护机制，发现一个程序中的所有指针其实只有一小部分负责进行控制流传输，因此，通过仅对控制敏感数据强制执行内存安全(不会对所有其他数据产生开销)就可以获得了重要的安全保障，同时保持实施安全保护的成本较低。</p><h3 id="CPI执行机制"><a href="#CPI执行机制" class="headerlink" title="CPI执行机制"></a>CPI执行机制</h3><p>为了把CPI应用到具体环境中，本文设计了一个利用静态分析和运行时支持的将CPI保护添加到程序的方法：包括一个静态分析遍历，它标识程序中的所有敏感指针以及对它们进行操作的所有指令，检测所有敏感指针的传递，将它们存储在单独的、安全的内存区域中，并根据元数据关联、传播和检查它们；同时利用指令级别的隔离机制有效防止非受保护的内存操作访问安全区域。为了性能考虑，程序会使用安全的堆栈机制处理存储在堆栈上的返回地址，与其他代码指针分开处理。</p><h3 id="CPI静态分析"><a href="#CPI静态分析" class="headerlink" title="CPI静态分析"></a>CPI静态分析</h3><p>静态分析的意义是查找所有对敏感指针进行操作的指令。这些操作包括：指针解引用、指针的运算以及指针内存分配、相关标准库函数、C++的new/delete操作符、自实现的分配算法。</p><h3 id="CPI插桩"><a href="#CPI插桩" class="headerlink" title="CPI插桩"></a>CPI插桩</h3><p>CPI插桩有三个目的，分别是：保证所有敏感指针存储在安全区；在运行时能够创建和传递这类指针的相关元数据；在对这类指针进行解引用时，检查元数据。</p><p>在内存布局上，CPI引入了安全区，CPI在安全区和常规区为敏感指针都分配了存储空间，但二者同时只能有一个是有效的。（通用指针在运行时的敏感性可能发生变化，同时也可以避免因为改变了内存空间分布而产生的一些兼容性问题）。CPI也将指针在常规区的地址来计算指针在安全区的相应地址。元数据描述了指针指向的目标对象，其中包括以下信息：内存地址的上下界、id、指针的值。这种做法的好处就是CPI无需到所有指针访问处都插桩的前提下保证指针数据安全。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga97fbtr3nj30tq059mxt.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>如上图所示，安全区包含了安全指针存储区、安全栈两个部分。左边(阴影部分)的敏感指针的位置仍未使用，而该指针的值及其元数据存储在安全指针存储区中。安全栈T1、T2、T3在常规内存中有对应的栈T1 ‘、T2 ‘、T3 ‘分配不安全的栈对象。</p><h3 id="安全区隔离"><a href="#安全区隔离" class="headerlink" title="安全区隔离"></a>安全区隔离</h3><p>安全区只能通过CPI固有指令访问。</p><h4 id="x86-32"><a href="#x86-32" class="headerlink" title="x86-32"></a>x86-32</h4><p>依赖于硬件段保护，安全区只能通过特定段寄存器访问（这个段寄存器不会再有其他用途），这里CPI将这个段寄存器也看做Program loader，CPI也将其他通过syscall来设置段寄存器的方式禁掉了。（这里感觉有点勉强，实验中测试的程序有限，如果真的应用到工业实践中，不能保证所有的程序和系统都不会用到这个段寄存器）</p><h4 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h4><p>尽管仍提供了两个段寄存器，X64中不再受到段限制。与x86类似，CPI使用了其中一个寄存器，同时还为安全区随机选择一个基址。</p><h4 id="其他架构"><a href="#其他架构" class="headerlink" title="其他架构"></a>其他架构</h4><p>其他架构也可以使用基于随机的保护，或者依赖于精确的软件故障隔离(SFI)，SFI要求程序中的所有内存操作都是轻量级插装的，如果安全区域占据了进程的整个上半部分地址空间，那么插装可能只有单个或全部操作那么小。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>安全指针存储是高度稀疏的，为了节省内存，设计者可以将其组织为散列表、多级查找表或依赖于底层操作系统的稀疏地址空间支持的简单数组。</p><h3 id="安全栈"><a href="#安全栈" class="headerlink" title="安全栈"></a>安全栈</h3><p>对于堆、栈进行特殊处理是有原因的，因为堆栈上有被频繁访问的值，比如每次函数调用时访问的代码指针的返回地址，以及溢出的寄存器。跟踪这些值中哪些将在运行时出现在内存中(因此需要保护)，哪些将出现在寄存器中，比较困难，因为编译器仅在代码生成的后期(CPI的检测通过之后很久)才发现哪些寄存器会产生安全问题。而研究者对于此的发现是，对堆栈对象的大多数访问都可以在编译期间静态地检查安全性。因此这种访问不需要运行时检查或元数据。大多数堆栈帧只包含在相应函数中独占访问的内存对象，并且只能通过具有常量偏移量的堆栈指针寄存器访问。将所有这些源安全的对象放到位于安全区域的安全堆栈中。可以在不进行任何检查的情况下访问安全堆栈。对于堆栈上有需要检查的内存对象的函数(例如，数组或地址传递给其他函数的对象)，我们在常规内存区域中分配单独的堆栈帧。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gagcfs3jv8j30ht0mk788.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>通过整理所有统计于上表，研究者发现只有不到25%的函数需要额外的堆栈帧(见表2)。此外，在短函数中，这一比例要小得多。</p><h3 id="代码指针隔离-CPI"><a href="#代码指针隔离-CPI" class="headerlink" title="代码指针隔离(CPI)"></a>代码指针隔离(CPI)</h3><p>CPS的执行与CPI类似，除了</p><ul><li><p>静态分析期间用以识别敏感指针的准则;及</p></li><li><p>CPS不需要任何元数据。控制流目的地(由代码指针指向)没有边界，因为指针值必须始终与目的地完全匹配，因此不需要边界元数据。</p></li></ul><p>CPS保证</p><ul><li><p>代码指针只能通过代码指针存储指令存储到内存中或在内存中修改代码指针，(ii)代码指针只能通过代码指针加载指令从内存位置加载指令，而以前代码指针存储指令存储的是一个值。结合安全堆栈，CPS可以精确地保护返回地址。CPS比大多数CFI实现更强大[1,54,53]，它允许程序中的任何脆弱指令修改任何代码指针;它们只检查代码指针的值(用于间接控制传输时)是否指向程序中定义的函数(用于函数指针)，或是否直接跟随调用指令(用于返回地址)。CPS guarantee (i)以上限制攻击面，而guarantee</p></li><li><p>通过限制控件可重定向到的位置集来限制攻击者的灵活性——该集合只包含函数的入口点，而这些函数的地址是程序显式获取的。</p></li></ul><h3 id="保护机制实现"><a href="#保护机制实现" class="headerlink" title="保护机制实现"></a>保护机制实现</h3><p>本文作者在LLVM 3.3编译器基础架构的基础上，对LLVM li-braries、clang编译器和compiler-rt运行时进行了修改，为C/ C++实现了一个名为Levee的CPI/CPS增强工具。要使用Levee，只需向编译器传递额外的标志来启用CPI (-fcpi)、CPS (-fcps)或safe- stack protection (-fstack-protector-safe)。Levee工作在未经修改的程序上，并支持Linux、FreeBSD和Mac OS X的32位和64位模式。</p><h2 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h2><p>CPI基于RIPE进行了测试，对新出现的几种能绕过DEP、ASLR、CFI等机制的攻击实现了防御。同时，CPI基于SPEC CPU2006标准，对100多个软件包进行了测试，结果如下：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah0iqwfzzj30l10n477s.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>作者制作的统计表：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah0jm1ogrj30m408nq4l.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>在web平台((FreeBSD + Apache + SQLite + mod wsgi + Python +Django))上的测试结果：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah0mdpfosj30px063jsm.jpg" srcset="/img/loading.gif" lazyload alt=""></p><h2 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h2><blockquote><p>本节鉴于本人水平有限，后面的一些式子的理解参考于<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/193818">这篇文章的形式化验证部分</a></p></blockquote><p>在本节中考虑的C子集的语法规则：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah5jyuj41j30nl0acq4p.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>定义运行时环境为E，将E表示成一个三元组的形势：(S,Mu,Ms)。</p><blockquote><p>S表示将某变量映射到其类型和地址，Mu是常规区的某一地址，存储着一个值v，Ms是安全区某一地址，存储着某值和其上下界信息v(b,e)，b为下界，e为上界，不存在被标记为none。</p></blockquote><p>对Mu和Ms两个地址的所有操作类型(假设内存操作在所有其他方面都遵循读/写/malloc操作的标准行为，例如，read返回以前写到相同位置的值，malloc分配内存的一个区域，这个区域与任何其他分配的区域不相交。)：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah5l9odajj30nz08ymz3.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>对于操作的结构，都可以用以下形势来表示：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah5n8lqnoj30o201xgls.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>具体解释一下来说，v(b,e)和v表示安全,OK意味着操作成功，OutOfMem和Abort是错误编码，我们假设语言的所有操作语义规则传播这些错误代码，直到程序结束时都保持不变。</p><p>使用上述定义，作者使用规则形式化CPI的操作语义，a表示原子类型int或者是指针，左表达式lhs包括某变量，结构体成员，指针解引用，右表达式包括整数、函数地址，左表达式、左表达式地址、指针大小、为右表达式分配内存情况。特别地，lhs=rhs表示变量赋值等操作。</p><p>规则指定将左侧表达式分别分配到安全位置或常规位置：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6hcp5j4j30jv026mx7.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>规则指定如何将表达式计算为带有边界或规则值的安全值，同时可能伴有环境的转换：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6eiezrrj30pw03ejrn.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>规则指定执行命令c得到结果r同时可能伴有环境的转换：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6f7sbjuj308x025aa0.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>规则表示分配i单位内存，得到某位置上下界l、l+i，同时返回结果r：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6oo5noij30oz04v74w.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>以下三个式子表示对敏感指针的操作（如解引用等）将会被判定，返回结果r。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6pdcmfmj30o209xjsi.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>这三个表达式是对读写操作进行判定。对从安全区读出的值进行检查，如果与元数据信息（上下界）相符，则可以进行后续操作，否则返回Abort（错误）。对写入安全区的数据也进行检查，通过之后返回OK：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6pzmqizj30qg0g9gnz.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>该式表示任何经由常规区对安全区的访问都是非法的，返回Abort：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6sbkdt7j30lz04aq3c.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>该式处理了泛型指针的敏感性会动态变化的情形。由于泛型指针在安全区和常规区均占有内存，读取时先在安全区标记为none，然后从常规区直接取值。写操作是类似的，直接写入常规区，然后将安全区标记为none,成功返回OK：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6sxk8ujj30n307v0u2.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>该式表示对于常规区的操作无需任何干涉，也不会产生任何问题，直接返回OK：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6tmlzyoj30lh07cgml.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>该式表示如果函数指针位于安全区（ls）,则返回OK，位于常规区（lu）则返回Abort。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gah6u3atxaj30nr03iweu.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>根据上述敏感条件和安全位置取消引用和间接函数调用规则，所有需要根据CPI属性进行保护的指针的取消引用在运行时都是安全的，否则程序将中止。因此，上述定义的操作语义确实保证了CPI属性。</p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/security/">security</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/system-security/">system security</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2020/01/19/2019-02-07-Glibc-ptmalloc/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">ptmalloc解析</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2019/11/03/Intel%20SGX/"><span class="hidden-mobile">Intel SGX</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/boot.js"></script></body></html>